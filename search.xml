<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式总结。]]></title>
    <url>%2F2018%2F10%2F09%2F2018-10-09%2F</url>
    <content type="text"><![CDATA[已经将head first一书看完了，应该总结一下这本书学到了些什么。总的来说就是学到了设计模式，下面就将自己学习的设计模式整理一个目录，方便自己后期复习，以及简短的描述各个设计模式的定义，以及在哪些方面需要使用到设计模式。 整理一下模式需要用到的词汇(23个) 创建型 singleton 单例 builder 生成器 prototype 原型 abstract factory 抽象工厂 factory method 工厂方法 行为型 template method 模版方法 command 命令 observer 观察者 iterator 迭代器 strategy 策略 interpreter 解释器 visitor 访问者 mediator 中介 memento 备忘录 chain of responsibility 责任链 state 状态 结构型 proxy 代理 decorator 装饰 composite 复合 flyweight 享元 bridge 桥接 adapter 适配器 facade 外观 模式的定义和自己理解的用途一、策略模式 定义：封装可以交互的行为，并使用委托来决定要使用那一个 用途：策略模式就是通过不同的策略可以给对象组装不同的行为，比如给小猫小狗添加不同的行为等。 二、观察者模式 定义：让对象在状态改变时被通知 用途：观察者模式就是相当于公众号一样，你关注公众号就会受到消息，取消就收不到消息，一对多的关系。 三、装饰者模式 定义：包装一个对象，并提供新的行为 用途：就像装修房子一样，选择不同的厂商，不同的材料装饰房子。java io流就是使用的装饰模式 四、工厂方法/) 定义：由子类决定要创建的具体类是那一个 理解：]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 组合模式]]></title>
    <url>%2F2018%2F10%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89%EF%BC%8D%20%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[已经有一段时间没有写模式了，在把迭代器模式写了之后，本应该是写组合模式的，但是组合模式涉及到递归，感觉很麻烦，于是就跳跃了，没有及时写下来，之后看了代理模式，复合模式等。都没有记录下来。现在是时候好好理一下这些模式了，昨天复习了下之前的模式，特别感觉工厂方法和抽象工厂都有些模糊了。看来要努力了，加油！ 一、对组合模式的理解组合模式定义：允许你将对象组合成树形结构来表现“整体／部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象集合。 个人理解就是处理树形结构集合的一种模式就想树一样，是有根，有无数的树枝，无数的叶子，一成一层的，就像电脑文件夹一样 二、代码实现实现抽象类12345678// 抽象组合类public abstract class Component &#123; String name; public Component(String name) &#123; this.name = name; &#125; public abstract void operation(int index); // 操作&#125; 实现叶子类,继承抽象组合类 1234567891011121314151617// 叶子public class Leaf extends Component&#123; public Leaf(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; @Override public void operation(int index) &#123; String str = &quot;&quot;; for (int i=0; i&lt;index; i++) &#123; str = str+ &quot; &quot;; &#125; System.out.println(str + name); &#125;&#125; 实现树枝类，继承抽象组合类 123456789101112131415161718192021222324252627282930public class Composite extends Component&#123; private LinkedList&lt;Component&gt; childer; public Composite(String name) &#123; super(name); this.childer = new LinkedList&lt;&gt;(); &#125; @Override public void operation(int index) &#123; String str = &quot;&quot;; for (int i=0; i&lt;index; i++) &#123; str = str+ &quot; &quot;; &#125; LinkedList&lt;Component&gt; list = this.getChilder(); System.out.println(str + name); for (Component c : list) &#123; c.operation(index+1); &#125; &#125; public void add(Component com) &#123; this.childer.add(com); &#125; public void remove(Component com) &#123; this.childer.remove(com); &#125; public LinkedList&lt;Component&gt; getChilder()&#123; return this.childer; &#125; &#125; main方法实现 123456789101112131415161718192021222324public static void main(String[] args) &#123; Composite root = new Composite(&quot;root&quot;); Composite branch = new Composite(&quot;branch&quot;); Composite branch1 = new Composite(&quot;branch1&quot;); Composite branch2 = new Composite(&quot;branch2&quot;); Composite branch3 = new Composite(&quot;branch3&quot;); branch.add(new Leaf(&quot;leaf1&quot;)); branch.add(new Leaf(&quot;leaf2&quot;)); branch1.add(new Leaf(&quot;leaf3&quot;)); branch2.add(new Leaf(&quot;leaf4&quot;)); branch1.add(branch2); branch2.add(new Leaf(&quot;leaf5&quot;)); branch2.add(new Leaf(&quot;leaf6&quot;)); branch3.add(new Leaf(&quot;leaf7&quot;)); branch3.add(new Leaf(&quot;leaf8&quot;)); branch2.add(branch3); root.add(branch); root.add(branch1); root.operation(0); &#125; 运行结果 12345678910111213root branch leaf1 leaf2 branch1 leaf3 branch2 leaf4 leaf5 leaf6 branch3 leaf7 leaf8 三、UML类图 四、笔记oo原则 封装变化 多用组合，少用继承 针对接口编程，不针对实现编程 为交互对象之间的松耦合设计而努力 类应该对扩展开放，对修改关闭 依赖抽象，不依赖具体类 只和朋友交谈 别找我，我会找你 类应该只有一个改变的理由 组合模式：允许你将对象组成树形结构来表现“整体／部分”的层次结构，组合能让客户以一致的方式处理个别对象和对象组合。 组合也可以和迭代器一起使用]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 状态模式]]></title>
    <url>%2F2018%2F10%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89-%20%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前学习的是组合模式和迭代器模式，迭代器模式已经实现了，但是组合模式，涉及到递归，没怎么理解透彻，因此准备最后攻克难关 一、对于状态模式的理解状态就像初中学习的物理一样（水），水是液态的、加热之后就变成了蒸汽就是雾态、结冰了就是固态。我们就可以描述水的不同状态。例如经常在公共场所会遇到自动售货机，没有用户投币的时候就可以理解为一种状态，投币之后是一种投币状态、用户选择产品就是一种选择状态、售货机从货架推出产品就是一种出售状态、产品卖空了就是一种售罄状态。如果我们只写一个类用if else去实现这种功能，就会有很多重复的代码。后期添加新的功能也特别不方便，需要改动的源代码也特别多。但是用状态模式去管理这些状态的话，后期添加新的功能，就会是一件很轻松的事情。而且对于后期的维护，也会大有裨益。状态模式就是将所有不同的状态都封装成类，最后通过一个展示的类去调用这些状态类，当然所有的状态类都实现了一个状态接口，方便利用多态在展示的类中去调用。最后实现，通过同一种调用方式，可以改变不同的状态。在不同的状态下，同一个方法，可以实现不同的业务逻辑。状态模式的定义：允许对象在内部状态改变时改变它的行为，对象看起来像是修改了它的类 二、代码实现创建状态接口，并创建通用的投币、退币、选择产品、出货等方法 1234567// 状态接口public interface State &#123; public void insertMoney(); // 投币 public void exitMoney(); // 退币 public void selectProduct(); // 选择产品 public void dispense(); // 发放产品&#125; 创建自动售货机类 123456public class AutoSales &#123; State soldOutState; State noMoneyState; State hasMoneyState; State soldState;&#125; 创建售罄类实现状态接口 1234567891011121314151617181920212223242526272829303132// 售謦状态public class SoldOutState implements State&#123; AutoSales autoSales; public SoldOutState() &#123; super(); &#125; public SoldOutState(AutoSales as) &#123; this.autoSales = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;以售罄，请不要投币&quot;); this.autoSales.setState(this.autoSales.getSoldOutState()); // 将状态改为售罄 &#125; @Override public void exitMoney() &#123; System.out.println(&quot;以售罄，无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;以售罄，无法选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;以售罄，无法获得产品&quot;); &#125;&#125; 待投币状态实现状态接口 1234567891011121314151617181920212223242526272829303132// 没有投币的状态public class NoMoneyState implements State&#123; AutoSales as; public NoMoneyState() &#123; super(); &#125; public NoMoneyState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;投币了&quot;); this.as.setState(this.as.getHasMoneyState()); // 将状态改为以投币 &#125; @Override public void exitMoney() &#123; System.out.println(&quot;没有投币，无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;没有投币，无法选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;没有投币，无法出货&quot;); &#125; &#125; 已投币状态也实现状态接口 123456789101112131415161718192021222324252627282930313233// 已投币public class HasMoneyState implements State&#123; AutoSales as; public HasMoneyState() &#123; super(); &#125; public HasMoneyState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;又投币了&quot;); &#125; @Override public void exitMoney() &#123; System.out.println(&quot;开始退币了&quot;); this.as.setState(this.as.getNoMoneyState()); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;发放产品&quot;); this.as.setState(this.as.getSoldState()); &#125; &#125; 已售出状态实现状态接口 1234567891011121314151617181920212223242526272829303132333435// 售出状态public class SoldState implements State&#123; AutoSales as; public SoldState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;又投币了&quot;); &#125; @Override public void exitMoney() &#123; System.out.println(&quot;产品已售出,无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;出货&quot;); if (this.as.getCount() &gt;0 ) &#123; this.as.setState(as.getNoMoneyState()); // 将状态变为没投币之前 &#125; else &#123; System.out.println(&quot;产品卖完了&quot;); this.as.setState(as.getSoldOutState()); // 将状态变为售罄 &#125; &#125;&#125; 完善自动售货机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 自动售货机public class AutoSales &#123; State soldOutState; State noMoneyState; State hasMoneyState; State soldState; State state = soldState; int count = 0; public AutoSales(int num) &#123; this.count = num; soldOutState = new SoldOutState(this); noMoneyState = new NoMoneyState(this); hasMoneyState = new HasMoneyState(this); soldState = new SoldState(this); if (num&gt;0) &#123; state = noMoneyState; &#125; &#125; // 投币 public void insertMoney()&#123; state.insertMoney(); &#125;; // 退币 public void exitMoney()&#123; this.state.exitMoney(); &#125;; // 选择产品 public void selectProduct()&#123; this.state.selectProduct(); &#125;; // 发放产品 public void dispense()&#123; this.state.dispense(); &#125;; public void setState(State state) &#123; this.state = state; &#125; public State getSoldOutState() &#123; return soldOutState; &#125; public State getNoMoneyState() &#123; return noMoneyState; &#125; public State getHasMoneyState() &#123; return hasMoneyState; &#125; public State getSoldState() &#123; return soldState; &#125; public State getState() &#123; return state; &#125; public int getCount() &#123; return count; &#125; @Override public String toString() &#123; return &quot;AutoSales [售罄=&quot; + soldOutState.getClass() + &quot;, 待投币=&quot; + noMoneyState.getClass() + &quot;, 已投币=&quot; + hasMoneyState.getClass() + &quot;, 出售=&quot; + soldState.getClass() + &quot;, state状态=&quot; + state.getClass() + &quot;, count=&quot; + count + &quot;]&quot;; &#125;&#125; main方法运行 1234567891011121314151617181920public static void main(String args[]) &#123; // 给自动售货机装5个产品 AutoSales as = new AutoSales(5); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.insertMoney(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.selectProduct(); as.dispense(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.exitMoney(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.insertMoney(); as.selectProduct(); as.insertMoney(); as.selectProduct(); as.dispense(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); &#125; 运行结果 1234567891011121314--当前状态：class study.state.NoMoneyState投币了--当前状态：class study.state.HasMoneyState选择产品发放产品--当前状态：class study.state.SoldState产品已售出,无法退币--当前状态：class study.state.SoldState又投币了选择产品又投币了选择产品出货--当前状态：class study.state.NoMoneyState 三、UML类图 四、笔记oo原则 封装变化 多用组合、少用继承 针对接口编程，不针对实现编程 对修改关闭，对增加开放 你不要来找我，我来找你 为交互之间的松耦合设计而努力 依赖抽象，不依赖具体类 只和朋友交谈 类应该只有一个被改变的理由 状态模式定义： 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信朋友圈python爬虫]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88python%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[安装环境 virtualenv vir // 安装虚拟环境 pip install itchat // 安装微信插件 报错No matching distribution found for itchat之后通过https://www.jianshu.com/p/832245fc7276解决了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－单例模式]]></title>
    <url>%2F2018%2F09%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89-%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前学习是简单工厂模式、工厂方法模式、抽象工厂模式，复习一下 简单工厂模式简单工厂模式大概就是创建一个简单工厂类，由工厂类实例化对象。由参数决定实例化那个类 工厂方法模式创建一个抽象工厂类，里面包含一个抽象方法。由这个工厂去生产产品，具体的就是实现类实现工厂，并完成抽象方法的功能实现（如月饼抽象生产类，南方月饼类实现月饼抽象生产类，北方月饼实现月饼抽象生产类，等等）。调用不是由参数决定，是由创建者决定 抽象工厂模式创建抽象工厂类生产工厂，创建抽象产品类生产产品，并各自实现。形成产品族（一个大的家族）对于之前的理解模糊可以看这个：https://www.zhihu.com/question/20367734 一、 对单例模式的理解单例模式就像太阳一样，只有一个。在使用的时候，只能实例化一次。不能多次实例化。二、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 单例模式 太阳（synchronized，重量级）public class sun &#123; private static sun s = null; private sun() &#123;&#125; // 单例模式 这种方式多线程时会出现混乱的情况，不建议使用 public static sun getSun() &#123; if (s == null) &#123; s = new sun(); &#125; return s; &#125; // (同步方法)添加同步锁，在不考虑性能的时候可以使用该方法 public static synchronized sun getSunSyn() &#123; if (s == null) &#123; s = new sun(); &#125; return s; &#125;&#125;// 月亮（双重检查加锁）class moon &#123; // volatile 当moon初始化为实例时，能保证多个线程正确的处理moon变量 private volatile static moon m; private moon() &#123;&#125;; // 减少synchronized的使用 public static moon getMoon() &#123; if (m == null) &#123; synchronized (moon.class) &#123; if (m == null) &#123; m = new moon(); &#125; &#125; &#125; return m; &#125;&#125;// 地球（急切）class earth&#123; // 在静态初始化器中创建单件，这段代码保证了线程安全 private static earth e = new earth(); private earth()&#123;&#125;; // 在jvm 加载这个类的时候创建此唯一的单例模式。 public static earth getEarth() &#123; return e; &#125;&#125; 三、UML类图 四、笔记oo设计原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为对象之间的松耦合设计而努力 类应该对扩展开发、修改关闭 依赖抽象、不要依赖具体类单例模式定义：确保一个类只有一个实例，并提供全局访问点 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－命令模式]]></title>
    <url>%2F2018%2F09%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89-%20%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前学习的是单例模式。但里模式就是只有一个对象被实例化，如注册表等。单例模式有几种实现方式一是用同步锁创建一个私有的构造器，和一个同步的公开的方法。这种方式简便，但是性能不是很好，使用的是同步锁（重量级的）。二是创建一个静态产量直接new一个对象。也是有私有的构造器不让对象创建。通过公开的方法返回静态常量new的对象，保证对象只有一个。这种方法在jvm创建的时候就会产生对象，如果不使用该对象，则会产生浪费三是用volatile创建静态属性。用私有构造器不让对象创建，通过公开的get方法获取对象，获取的时候判断对象是否存在，如果不存在则用同步锁防止多线程出现错误。最后返回对象。这种是常用的方法。 一、对于命令模式的理解一个命令创建一个对象。每个命令都是一个操作。不用去关心对象是怎么做的，只需要发送命令即可。就像传菜员一样。 二、 代码实现创建一个命令接口12345// 命令接口public interface Command &#123; public void execute(); // 执行 public void undo(); // 撤销&#125; 在创建一个电视123456789// 电视public class TV &#123; public void on() &#123; System.out.println(&quot;开电视&quot;); &#125; public void off() &#123; System.out.println(&quot;关电视&quot;); &#125;&#125; 创建一个开电视命令 123456789101112131415161718// 开电视public class TVOnCommand implements Command&#123; TV tv; public TVOnCommand(TV tv) &#123; this.tv = tv; &#125; @Override public void execute() &#123; tv.on(); &#125; @Override public void undo() &#123; System.out.println(&quot;开电视撤销准备。。。&quot;); tv.off(); &#125;&#125; 创建一个关电视命令1234567891011121314151617public class TVOffCommand implements Command&#123; TV tv; public TVOffCommand(TV tv) &#123; this.tv = tv; &#125; @Override public void execute() &#123; tv.off(); &#125; @Override public void undo() &#123; System.out.println(&quot;关电视撤销准备。。。&quot;); tv.on(); &#125;&#125; 创建一个简单的远程控制器（遥控器） 1234567891011121314151617// 简单远程控制public class SimpleRemoteController &#123; Command command; Command undoCommand; public SimpleRemoteController()&#123;&#125;; // 利用有参构造器初始化命令 public void setCommand(Command command) &#123; this.command = command; &#125; public void start() &#123; command.execute(); this.undoCommand = this.command; &#125; public void undo() &#123; this.undoCommand.undo(); &#125;&#125; main方法实现123456789101112131415public static void main(String args[]) &#123; // 创建远程控制器 SimpleRemoteController simpleRemoteController = new SimpleRemoteController(); TV tv = new TV(); // 创建电视 TVOnCommand tvon = new TVOnCommand(tv); // 创建关电视命令 simpleRemoteController.setCommand(tvon); // 通过远程控制器设置关电视的命令 simpleRemoteController.start(); // 按开始按钮 simpleRemoteController.undo(); TVOffCommand tvoff = new TVOffCommand(tv); // 创建关电视命令 simpleRemoteController.setCommand(tvoff); // 通过远程控制器设置关电视的命令 simpleRemoteController.start(); // 按开始按钮 simpleRemoteController.undo();&#125; 运行结果123456开电视开电视撤销准备。。。关电视关电视关电视撤销准备。。。开电视 实现宏命令（实现一组命令）创建宏命令123456789101112131415161718192021// 宏命令public class MacroCommand implements Command&#123; Command[] commands; public MacroCommand(Command[] command)&#123; this.commands = command; &#125; @Override public void execute() &#123; for(Command c : this.commands )&#123; c.execute(); &#125; &#125; @Override public void undo() &#123; for(Command c : this.commands )&#123; c.undo(); &#125; &#125;&#125; 创建宏的远程控制 12345678910111213141516171819// 遥控器public class RemoteController &#123; Command[] onCommands; Command[] offCommands; public RemoteController () &#123; this.onCommands = new Command[2]; this.offCommands = new Command[2]; &#125; public void setCommand(int index, Command on,Command off) &#123; this.onCommands[index] = on; this.offCommands[index] = off; &#125; public void on(int index) &#123; this.onCommands[index].execute(); &#125; public void off(int index) &#123; this.offCommands[index].execute(); &#125;&#125; 创建一个电脑操作类12345678public class Computer &#123; public void on() &#123; System.out.println(&quot;开电脑&quot;); &#125; public void off() &#123; System.out.println(&quot;关电脑&quot;); &#125;&#125; 关电脑命令1234567891011121314151617public class ComputerOffCommand implements Command&#123; Computer computer; public ComputerOffCommand(Computer com) &#123; this.computer = com; &#125; @Override public void execute() &#123; this.computer.off(); &#125; @Override public void undo() &#123; System.out.println(&quot;关电脑撤销准备。。。&quot;); this.computer.on(); &#125;&#125; 开电脑命令1234567891011121314151617public class ComputerOnCommand implements Command&#123; Computer computer; public ComputerOnCommand(Computer computer) &#123; this.computer = computer; &#125; @Override public void execute() &#123; this.computer.on(); &#125; @Override public void undo() &#123; System.out.println(&quot;开电脑撤销准备。。。&quot;); this.computer.off(); &#125;&#125; main方法运行1234567891011121314Computer computer = new Computer();RemoteController remoteController = new RemoteController();ComputerOffCommand coffc = new ComputerOffCommand(computer);ComputerOnCommand conc = new ComputerOnCommand(computer);// 实现宏命令Command[] on = &#123;tvon, conc&#125;;Command[] off = &#123;tvoff,coffc&#125;;MacroCommand onmc = new MacroCommand(on);MacroCommand offmc = new MacroCommand(off);remoteController.setCommand(0, onmc, offmc);System.out.println(&quot;宏命令结束&quot;);remoteController.on(0);System.out.println(&quot;单独执行&quot;);remoteController.off(0); 运行结果123456宏命令结束开电视开电脑单独执行关电视关电脑 三、UML类图 四、笔记 封装变化 多用组合少用继承 针对接口编程，不针对实现编程 为交互对象之间的松耦合设计而努力 对扩展开放、对修改关闭 依赖抽象，不依赖具体类 命令模式定义： 将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其它对象。命令模式也可以支持撤销操作。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89%EF%BC%8D%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[index @font-face { font-family: octicons-anchor; src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff'); } body { background-color: white; } .markdown-body { min-width: 200px; max-width: 760px; margin: 0 auto; padding: 20px; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; color: #333; overflow: hidden; font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif; font-size: 16px; line-height: 1.6; word-wrap: break-word; } .markdown-body a { background: transparent;;word-wrap: break-word; word-break: break-all; } .markdown-body a:active, .markdown-body a:hover { outline: 0; } .markdown-body strong { font-weight: bold; } .markdown-body h1 { font-size: 2em; margin: 0.67em 0; } .markdown-body img { border: 0; } .markdown-body hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; } .markdown-body pre { overflow: auto; } .markdown-body code, .markdown-body kbd, .markdown-body pre { font-family: monospace, monospace; font-size: 1em; } .markdown-body input { color: inherit; font: inherit; margin: 0; } .markdown-body html input[disabled] { cursor: default; } .markdown-body input { line-height: normal; } .markdown-body input[type="checkbox"] { -moz-box-sizing: border-box; box-sizing: border-box; padding: 0; } .markdown-body table { border-collapse: collapse; border-spacing: 0; } .markdown-body td, .markdown-body th { padding: 0; } .markdown-body * { -moz-box-sizing: border-box; box-sizing: border-box; } .markdown-body input { font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; } .markdown-body a { color: #4183c4; text-decoration: none; } .markdown-body a:hover, .markdown-body a:focus, .markdown-body a:active { text-decoration: underline; } .markdown-body hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #ddd; } .markdown-body hr:before { display: table; content: ""; } .markdown-body hr:after { display: table; clear: both; content: ""; } .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { margin-top: 15px; margin-bottom: 15px; line-height: 1.1; } .markdown-body h1 { font-size: 30px; } .markdown-body h2 { font-size: 21px; } .markdown-body h3 { font-size: 16px; } .markdown-body h4 { font-size: 14px; } .markdown-body h5 { font-size: 12px; } .markdown-body h6 { font-size: 11px; } .markdown-body blockquote { margin: 0; } .markdown-body ul, .markdown-body ol { padding: 0; margin-top: 0; margin-bottom: 0; } .markdown-body ol ol, .markdown-body ul ol { list-style-type: lower-roman; } .markdown-body ul ul ol, .markdown-body ul ol ol, .markdown-body ol ul ol, .markdown-body ol ol ol { list-style-type: lower-alpha; } .markdown-body dd { margin-left: 0; } .markdown-body code { font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace; } .markdown-body pre { margin-top: 0; margin-bottom: 0; font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace; } .markdown-body kbd { background-color: #e7e7e7; background-image: -webkit-linear-gradient(#fefefe, #e7e7e7); background-image: linear-gradient(#fefefe, #e7e7e7); background-repeat: repeat-x; border-radius: 2px; border: 1px solid #cfcfcf; color: #000; padding: 3px 5px; line-height: 10px; font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace; display: inline-block; } .markdown-body>*:first-child { margin-top: 0 !important; } .markdown-body>*:last-child { margin-bottom: 0 !important; } .markdown-body .anchor { position: absolute; top: 0; bottom: 0; left: 0; display: block; padding-right: 6px; padding-left: 30px; margin-left: -30px; } .markdown-body .anchor:focus { outline: none; } .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6 { position: relative; margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; } .markdown-body h1 .octicon-link, .markdown-body h2 .octicon-link, .markdown-body h3 .octicon-link, .markdown-body h4 .octicon-link, .markdown-body h5 .octicon-link, .markdown-body h6 .octicon-link { display: none; color: #000; vertical-align: middle; } .markdown-body h1:hover .anchor, .markdown-body h2:hover .anchor, .markdown-body h3:hover .anchor, .markdown-body h4:hover .anchor, .markdown-body h5:hover .anchor, .markdown-body h6:hover .anchor { height: 1em; padding-left: 8px; margin-left: -30px; line-height: 1; text-decoration: none; } .markdown-body h1:hover .anchor .octicon-link, .markdown-body h2:hover .anchor .octicon-link, .markdown-body h3:hover .anchor .octicon-link, .markdown-body h4:hover .anchor .octicon-link, .markdown-body h5:hover .anchor .octicon-link, .markdown-body h6:hover .anchor .octicon-link { display: inline-block; } .markdown-body h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } .markdown-body h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } .markdown-body h3 { font-size: 1.5em; line-height: 1.43; } .markdown-body h4 { font-size: 1.25em; } .markdown-body h5 { font-size: 1em; } .markdown-body h6 { font-size: 1em; color: #777; } .markdown-body p, .markdown-body blockquote, .markdown-body ul, .markdown-body ol, .markdown-body dl, .markdown-body table, .markdown-body pre { margin-top: 0; margin-bottom: 16px; } .markdown-body hr { height: 4px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; } .markdown-body ul, .markdown-body ol { padding-left: 2em; } .markdown-body ul ul, .markdown-body ul ol, .markdown-body ol ol, .markdown-body ol ul { margin-top: 0; margin-bottom: 0; } .markdown-body li>p { margin-top: 16px; } .markdown-body dl { padding: 0; } .markdown-body dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; } .markdown-body dl dd { padding: 0 16px; margin-bottom: 16px; } .markdown-body blockquote { padding: 0 15px; color: #777; border-left: 4px solid #ddd; } .markdown-body blockquote>:first-child { margin-top: 0; } .markdown-body blockquote>:last-child { margin-bottom: 0; } .markdown-body table { display: block; width: 100%; overflow: auto; word-break: normal; word-break: keep-all; } .markdown-body table th { font-weight: bold; } .markdown-body table th, .markdown-body table td { padding: 6px 13px; border: 1px solid #ddd; } .markdown-body table tr { background-color: #fff; border-top: 1px solid #ccc; } .markdown-body table tr:nth-child(2n) { background-color: #f8f8f8; } .markdown-body img { max-width: 100%; -moz-box-sizing: border-box; box-sizing: border-box; } .markdown-body code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(0,0,0,0.04); border-radius: 3px; } .markdown-body code:before, .markdown-body code:after { letter-spacing: -0.2em; content: "\00a0"; } .markdown-body pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .markdown-body .highlight { margin-bottom: 16px; } .markdown-body .highlight pre, .markdown-body pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border-radius: 3px; } .markdown-body .highlight pre { margin-bottom: 0; word-break: normal; } .markdown-body pre { word-wrap: normal; } .markdown-body pre code { display: inline; max-width: initial; padding: 0; margin: 0; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } .markdown-body pre code:before, .markdown-body pre code:after { content: normal; } .markdown-body .highlight { background: #fff; } .markdown-body .highlight .mf, .markdown-body .highlight .mh, .markdown-body .highlight .mi, .markdown-body .highlight .mo, .markdown-body .highlight .il, .markdown-body .highlight .m { color: #945277; } .markdown-body .highlight .s, .markdown-body .highlight .sb, .markdown-body .highlight .sc, .markdown-body .highlight .sd, .markdown-body .highlight .s2, .markdown-body .highlight .se, .markdown-body .highlight .sh, .markdown-body .highlight .si, .markdown-body .highlight .sx, .markdown-body .highlight .s1 { color: #df5000; } .markdown-body .highlight .kc, .markdown-body .highlight .kd, .markdown-body .highlight .kn, .markdown-body .highlight .kp, .markdown-body .highlight .kr, .markdown-body .highlight .kt, .markdown-body .highlight .k, .markdown-body .highlight .o { font-weight: bold; } .markdown-body .highlight .kt { color: #458; } .markdown-body .highlight .c, .markdown-body .highlight .cm, .markdown-body .highlight .c1 { color: #998; font-style: italic; } .markdown-body .highlight .cp, .markdown-body .highlight .cs { color: #999; font-weight: bold; } .markdown-body .highlight .cs { font-style: italic; } .markdown-body .highlight .n { color: #333; } .markdown-body .highlight .na, .markdown-body .highlight .nv, .markdown-body .highlight .vc, .markdown-body .highlight .vg, .markdown-body .highlight .vi { color: #008080; } .markdown-body .highlight .nb { color: #0086B3; } .markdown-body .highlight .nc { color: #458; font-weight: bold; } .markdown-body .highlight .no { color: #094e99; } .markdown-body .highlight .ni { color: #800080; } .markdown-body .highlight .ne { color: #990000; font-weight: bold; } .markdown-body .highlight .nf { color: #945277; font-weight: bold; } .markdown-body .highlight .nn { color: #555; } .markdown-body .highlight .nt { color: #000080; } .markdown-body .highlight .err { color: #a61717; background-color: #e3d2d2; } .markdown-body .highlight .gd { color: #000; background-color: #fdd; } .markdown-body .highlight .gd .x { color: #000; background-color: #faa; } .markdown-body .highlight .ge { font-style: italic; } .markdown-body .highlight .gr { color: #aa0000; } .markdown-body .highlight .gh { color: #999; } .markdown-body .highlight .gi { color: #000; background-color: #dfd; } .markdown-body .highlight .gi .x { color: #000; background-color: #afa; } .markdown-body .highlight .go { color: #888; } .markdown-body .highlight .gp { color: #555; } .markdown-body .highlight .gs { font-weight: bold; } .markdown-body .highlight .gu { color: #800080; font-weight: bold; } .markdown-body .highlight .gt { color: #aa0000; } .markdown-body .highlight .ow { font-weight: bold; } .markdown-body .highlight .w { color: #bbb; } .markdown-body .highlight .sr { color: #017936; } .markdown-body .highlight .ss { color: #8b467f; } .markdown-body .highlight .bp { color: #999; } .markdown-body .highlight .gc { color: #999; background-color: #EAF2F5; } .markdown-body .octicon { font: normal normal 16px octicons-anchor; line-height: 1; display: inline-block; text-decoration: none; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .markdown-body .octicon-link:before { content: '\f05c'; } .markdown-body .task-list-item { list-style-type: none; } .markdown-body .task-list-item+.task-list-item { margin-top: 3px; } .markdown-body .task-list-item input { float: left; margin: 0.3em 0 0.25em -1.6em; vertical-align: middle; } /* github.com style (c) Vasily Polovnyov */ .hljs { display: block; overflow-x: auto; padding: 0.5em; color: #333; background: #f8f8f8; -webkit-text-size-adjust: none; } .hljs-comment, .diff .hljs-header { color: #998; font-style: italic; } .hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title, .hljs-subst, .hljs-request, .hljs-status { color: #333; font-weight: bold; } .hljs-number, .hljs-hexcolor, .ruby .hljs-constant { color: #008080; } .hljs-string, .hljs-tag .hljs-value, .hljs-doctag, .tex .hljs-formula { color: #d14; } .hljs-title, .hljs-id, .scss .hljs-preprocessor { color: #900; font-weight: bold; } .hljs-list .hljs-keyword, .hljs-subst { font-weight: normal; } .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command { color: #458; font-weight: bold; } .hljs-tag, .hljs-tag .hljs-title, .hljs-rule .hljs-property, .django .hljs-tag .hljs-keyword { color: #000080; font-weight: normal; } .hljs-attribute, .hljs-variable, .lisp .hljs-body, .hljs-name { color: #008080; } .hljs-regexp { color: #009926; } .hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword, .clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special, .hljs-prompt { color: #990073; } .hljs-built_in { color: #0086b3; } .hljs-preprocessor, .hljs-pragma, .hljs-pi, .hljs-doctype, .hljs-shebang, .hljs-cdata { color: #999; font-weight: bold; } .hljs-deletion { background: #fdd; } .hljs-addition { background: #dfd; } .diff .hljs-change { background: #0086b3; } .hljs-chunk { color: #aaa; } @media print{ .hljs{overflow: visible; word-wrap: break-word !important;} } &emsp;&emsp;最近在读head frist 的设计模式。之前就了解过这本书的，感觉还不错，于是就在淘宝上购买了一本。书有500多页挺厚的一本，内容都是很容易上手的，当成漫画看就可以了。本着学习的态度，我想认认真真的把设计模式好好学习一下。设计模式很多，一个一个的学，学完一个，我就在这里纪录一下自己的学习成果、自己对设计模式的理解、以及一些笔记、代码就是自己想一个显示生活中的例子模拟实现。 一、对策略模式的理解 &emsp;&emsp;关于策略模式，我看完书之后回忆的起来的大概就是建立一个抽象类，抽象除类的不改变的属性，如动物的名字、年龄等这些都是每个动物都有的，不会改变的。 二、代码实现 创建一个动物类 public abstract class animal { private String name; private int age; ｝ 然后多个类继承该抽象类，如小猫、小狗等。 public class Dog extends animal{} 之后就是动物有的会飞、会叫等。这些都是动物的行为。之后把动物的飞行、叫喊接口化。 public interface CallBehavior { // 叫喊行为 public void call(); } public interface FlyBehavior { // 飞行行为 public void fly(); } 会飞、会叫都可以是动物的行为。就可以将会飞、会叫的接口组合在动物类里面，当成动物的属性 public abstract class animal { private String name; private int age; FlyBehavior flyBehavior; // 让所有的动物都继承这个行为 CallBehavior callBehavior; // 添加方法，用于被继承的动物共用方法 public void performFly() { // 执行飞行 flyBehavior.fly(); } public void performCall() { // 执行叫喊 callBehavior.call(); } public void setFlyBehavior(FlyBehavior fly){ // 动态的设置飞行的实现类，可以在运行时改变动物的飞行方式 this.flyBehavior = fly; } public void setCallBehavior(CallBehavior call){ this.callBehavior = call; } ｝ 之后就用不同的实现类实现会飞、会叫的接口 // 叫喊接口实现 public class CallBig implements CallBehavior{ @Override public void call() { System.out.println(&quot;特别大声的叫&quot;); } } public class CallNoWay implements CallBehavior{ @Override public void call() { System.out.println(&quot;不会叫&quot;); } } // 飞行接口实现 public class FlyNoWay implements FlyBehavior{ @Override public void fly() { System.out.println(&quot;不会飞行&quot;); } } public class FlyWithWings implements FlyBehavior{ @Override public void fly() { System.out.println(&quot;我要飞的更高&quot;); } } 然后就可以给小狗类添加默认的构造器。 public class Dog extends animal{ public Dog() { // 小狗的构造器 callBehavior = new CallBig(); // 大声叫callBehavior 使用的是父类的变量 flyBehavior = new FlyNoWay(); } } 调用 public static void main(String args[]) { animal dw = new DogModle(); dw.performFly(); // 默认飞行 dw.performCall(); // 默认叫喊 dw.setFlyBehavior(new FlyWithWings()); //动态绑定飞行行为 dw.performFly(); // 更改之后的飞行方式 } 执行结果 不会飞行 特别大声的叫 我要飞的更高 这样就动态实现了数据的绑定，根据不同的策略，绑定不同的接口。动态的完成功能，后期添加其他动物，也不需要更改之前的代码。完全做到了，对新增开放、对修改闭合的开闭原则。 三、UML类图 画的不正规的uml图 四、笔记 #### 1、学到的三个原则 将会变动的代码进行封装 针对接口编程，不针对实现编程 多用组合、少用继承 2、策略模式定义 定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 github源码：https://github.com/gaoqisen/java-pattern]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式－模版方法模式]]></title>
    <url>%2F2018%2F09%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89-%20%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前学习的是适配器模式与外观模式。 对外观模式与适配器模式的理解适配器模式的意思就是适配，将三孔插座转换为二孔插座的转换头。通过适配器可以将两个不一样的接口（有共同点）适配在一起。外观模式就是统一接口，将很多方法，统一在一个类里面实现。让使用者不会感觉方法太多杂乱。就像一个开关控制所有电器，和每个电器单独使用的一样。如果使用一个开关控制所有，就会特别方便。但是之前的开关也存在，如果需要单独使用，也是可以的。 先看下定义 模版方法：在一个方法中定义一个算法的骨架，而将一些步骤延伸到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 一、 对模版方法的理解模版方法就是将重复的方法封装在一个类中，变动的方法就用抽象方法抽象出来。将方法模版化，其它子类使用的时候，公用的方法就不用再次实现类，只需要实现抽象方法。大大的降低类代码的重复。比较好玩的就是钩子方法，可以通过子类控制父类的通用方法，很方便。我用炒大白菜和炒生菜举了个例子。 二、 代码实现创建烹饪抽象类123456789101112131415161718192021222324252627282930public abstract class Cooking &#123; // 准备烹饪 public void prepareCooking() &#123; WashingVegetables(); addVegetables(); addSalt(); // 根据菜的样式判断是否加辣椒 if (isChiliHooks()) &#123; addChili(); &#125; &#125; // 洗菜 public void WashingVegetables() &#123; System.out.println(&quot;洗菜&quot;); &#125; // 加盐 public void addSalt()&#123; System.out.println(&quot;加盐&quot;); &#125; // 加辣椒 public void addChili() &#123; System.out.println(&quot;加辣椒&quot;); &#125; // 是否加辣椒钩子 public boolean isChiliHooks() &#123; return true; &#125; // 放菜进锅炒，根据不同的实现，炒不同的菜 abstract void addVegetables();&#125; 创建大白菜类，大白菜重构类模版方法的抽象方法，放入类大白菜123456789// 大白菜public class ChineseCabbage extends Cooking&#123; @Override void addVegetables() &#123; System.out.println(&quot;放入大白菜&quot;); &#125;&#125; 创建生菜类，也实现类抽象方法。最后重写类父类的钩子，实现类不加辣椒 123456789101112// 炒生菜public class lettuce extends Cooking&#123; @Override void addVegetables() &#123; System.out.println(&quot;放入生菜&quot;); &#125; // 不放辣椒 public boolean isChiliHooks() &#123; return false; &#125;&#125; main方法实现 1234567public static void main(String agrs[]) &#123; ChineseCabbage cc = new ChineseCabbage(); cc.prepareCooking(); System.out.println(&quot;+++++++++&quot;); lettuce lt = new lettuce(); lt.prepareCooking(); &#125; 运行结果 12345678洗菜放入大白菜加盐加辣椒+++++++++洗菜放入生菜加盐 三、UML类图 四、笔记 封装变化 多用组合、少用继承 面向接口编程、不面向实现编程 只和朋友交谈 对修改关闭、对扩展开放 为交互对象之间的松耦合设计而努力 别找我、我会找你（好莱坞原则） 依赖抽象、不要依赖具体类 巩固模版方法定义: 在一个方法中定义一个算法的骨架，而将一些步骤延伸到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－适配器与外观模式]]></title>
    <url>%2F2018%2F09%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89-%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前学习的是命令模式 对于命令模式的理解命令模式就是将操作封装为一个类（一个命令）。在通过一个控制器把命令封装进去，就像一个遥控器，最后通过不同的命令就可以实现不同的操作 一、 对适配器模式和观察者模式的理解适配器模式就是改变一个接口，实现不同的操作。就像插座转换头一样，将三孔插座转换为二孔插座。外观模式字面上就是好的形象的意识。将一些操作集合在一起，统一调用，简单又方便。就像家里面的插头到处都是。我们可以把所有的插头都插在一个大插板上面。每次使用的时候，就可以只用开、关大插板就可以。不用每次都插很多插头。 二、代码实现适配器模式三孔插座1234567891011// 三孔插座public interface SocketThree &#123; public void chargeThree();&#125;class SocketThreeImpl implements SocketThree&#123; @Override public void chargeThree() &#123; System.out.println(&quot;三孔插座&quot;); &#125;&#125; 两孔插座123456789101112// 两孔插座public interface SocketTwo &#123; public void chargeTwo();&#125;class SocketTwoImpl implements SocketTwo&#123; @Override public void chargeTwo() &#123; System.out.println(&quot;两孔插座&quot;); &#125; &#125; 插座适配器123456789101112// 插座适配器 将三孔插座转换为二孔插座， 看着像二孔，但是实际上还是三孔public class SocketAdapter implements SocketTwo&#123; SocketThree socketThree; public SocketAdapter(SocketThree socketThree) &#123; this.socketThree = socketThree; &#125; @Override public void chargeTwo() &#123; System.out.println(&quot;转换后的两孔插座&quot;); this.socketThree.chargeThree(); &#125;&#125; main方法运行 123456// 适配器模式 SocketThree st = new SocketThreeImpl(); st.chargeThree(); // 通过转换器将三孔插座转换为两孔插座 SocketTwo stwo = new SocketAdapter(st); stwo.chargeTwo(); 运行结果123三孔插座转换后的两孔插座三孔插座 外观模式新建电视、电灯、烤火炉类12345678910111213141516171819202122232425public class TV &#123; public void on() &#123; System.out.println(&quot;开电视&quot;); &#125; public void off() &#123; System.out.println(&quot;关电视&quot;); &#125;&#125;class Light&#123; public void on() &#123; System.out.println(&quot;开电灯&quot;); &#125; public void off() &#123; System.out.println(&quot;关电灯&quot;); &#125;&#125;class Stove&#123; public void on() &#123; System.out.println(&quot;开火炉&quot;); &#125; public void off() &#123; System.out.println(&quot;关火炉&quot;); &#125;&#125; 大插板（不让插头凌乱，外观好看）12345678910111213141516171819202122// 买了一个大插板，将电视、烤火炉、电灯的插头都插在这个大插板上面public class FacadeSocket &#123; TV tv; Light light; Stove stove; public FacadeSocket(TV tv,Light light,Stove stove) &#123; this.tv = tv; this.light = light; this.stove = stove; &#125; // 通过外观模式统一处理 public void on() &#123; this.tv.on(); this.light.on(); this.stove.on(); &#125; public void off() &#123; this.tv.off(); this.light.off(); this.stove.off(); &#125;&#125; main方法实现12345678910public static void main(String srgs[])&#123; // 外观模式 TV tv = new TV(); Light light = new Light(); Stove stove = new Stove(); // 创建大插板， 统一开关 FacadeSocket fs = new FacadeSocket(tv, light,stove); fs.on(); fs.off();&#125; 运行结果123456开电视开电灯开火炉关电视关电灯关火炉 三、UML类图 四、笔记oo设计原则 封装变化 依赖接口编程，不依赖实现编程 为交互对象之间的松耦合设计而努力 对修改关闭、对扩展开放 多用组合，少用继承 依赖抽象、不依赖具体类 只和朋友交谈 适配器模式定义： 将一个类的接口，转移成为可以期望的另一个接口。适配器让原本不兼容的两个类可以合作无间 外观模式定义： 提供类一个统一的接口，用来访问子系统中的一群接口。外观定义类一个高层接口，让子系统更容易使用。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－迭代器模式]]></title>
    <url>%2F2018%2F09%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89-%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[昨天学习的是模版方法模式复习一下 对于模版方法的理解：模版方法模式就是创建一个模版类，并创建一个抽象方法，和调用方法。该方法（一般是静态方法，不能修改的）调用复用的模版类方法（实现通用的业务逻辑）和抽象方法。子类继承模版类之后，重写抽象方法（不同的业务逻辑）。模版类中可以设置钩子方法，用于控制模版类的通用方法是否调用。这样做的好处就是可以子类可以调用很多通用的方法，减少大量的重复代码。抽象方法也可以实现子类独有的方法。钩子还可以控制通用方法。使方法调用更加的灵活。模版方法就是为类的方法创建特别灵活的模版。 一、对于迭代器的理解通过看书之后，我觉得迭代器就是一个可以遍历所有不同集合类型对象的的一种方式。如用ArrayList, new [], HashMap等集合存储对象数据。如果要遍历就需要写三个for循环才可以完成遍历。但是有迭代器之后，就可以用一个迭代器完成三种不同类型的集合的遍历。总结出来就是：迭代器可以遍历所有实现了迭代器接口的不同类型的集合 二、代码实现实现思路：创建一个宠物类，有动物的名字、年龄、简介等。动物生病了就会找医生。每个医生都有自己的笼子，张医生的笼子使用ArrayList制作的。李医生的笼子使用Animal[]制作的。两个医生都在同一个宠物店里面上班。医生太忙了，领导来医院视察的时候，需要服务员小花去给领导报告两位医生的宠物都叫什么名字，年龄多少、宠物具体的情况等。如果没有迭代器，小花就需要拿张医生的ArrayList笼子的钥匙去看，李医生的钥匙和张医生的钥匙又不一样，每次都要拿不同的钥匙看不同的笼子，特别麻烦。而且还要去每个医生的工作区域才可以。但是有了迭代器，小花就不用拿这个多钥匙了，只要一种钥匙，而且不用去两个工作区域查看，就感觉像迭代器将宠物汇总了。小花只要拿一种钥匙，不用知道医生使用什么笼子关宠物的，只需要在一个地方查看在记录好报告领导就可以了。下面看代码。 1、 自己创建一个迭代器实现创建一个动物类 1234567891011121314151617181920// 动物类public class Animal &#123; String name; int age; String description; public Animal(String name, int age, String des) &#123; this.name = name; this.age = age; this.description = des; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getDescription() &#123; return description; &#125;&#125; 创建张医生和李医生，用不同的笼子关动物 123456789101112131415161718192021222324252627282930313233343536373839404142// 张医生用ArrayList笼子关动物public class DoctorZhang &#123; ArrayList ans; public DoctorZhang() &#123; ans = new ArrayList(); addAnimal(&quot;小狗&quot;,8, &quot;黄色的小狗&quot;); addAnimal(&quot;小猫&quot;,4, &quot;黑色的小猫&quot;); addAnimal(&quot;小猪&quot;,4, &quot;白色的小猪&quot;); &#125; // 增加动物方法 public void addAnimal(String name, int age, String des)&#123; Animal an = new Animal(name, age, des); this.ans.add(an); &#125; public Iterator createIterator() &#123; return new DoctorZhangIterator(this.ans); &#125;&#125;// 李医生用［］笼子关动物class DoctorLi&#123; static final int MAX=5; int number = 0; Animal[] animal; public DoctorLi() &#123; animal =new Animal[MAX]; addAnimal(&quot;小乌龟&quot;,8, &quot;黄色的小乌龟&quot;); addAnimal(&quot;小猴&quot;,4, &quot;黑色的小猴&quot;); addAnimal(&quot;大猪&quot;,4, &quot;黄色的大猪&quot;); &#125; // 增加动物方法 public void addAnimal(String name, int age, String des)&#123; if (number&gt;=MAX)&#123; return; &#125; Animal an = new Animal(name, age, des); this.animal[number] = an; this.number++; &#125; public Iterator createIterator() &#123; return new DoctorLiIterator(this.animal); &#125;&#125; 创建一个迭代器，并用张医生李医生去实现迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 迭代器接口public interface Iterator &#123; boolean hasNext(); Object next();&#125;// 李医生迭代器实现迭代器接口class DoctorZhangIterator implements Iterator&#123; ArrayList ans; int index = 0; public DoctorZhangIterator(ArrayList ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.size() || ans.get(index) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans.get(index); index ++; return animal; &#125; &#125;//张医生迭代器实现迭代器接口class DoctorLiIterator implements Iterator&#123; Animal[] animal; int index = 0; public DoctorLiIterator(Animal[] animal) &#123; this.animal = animal; &#125; @Override public boolean hasNext() &#123; if (index &gt;= animal.length || animal[index] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal an = animal[index]; index ++; return an; &#125; &#125; 创建一个宠物店类 12345678910111213141516171819202122232425// 宠物店public class PetShop &#123; DoctorZhang zhang; DoctorLi li; public PetShop(DoctorZhang zhang,DoctorLi li) &#123; this.zhang = zhang; this.li = li; &#125; // 小花就用这个方法统计宠物 public void printAnimal() &#123; Iterator it = zhang.createIterator(); Iterator its = li.createIterator(); System.out.println(&quot;张医生的宠物&quot;); printAnimal(it); System.out.println(&quot;李医生的宠物&quot;); printAnimal(its); &#125; private void printAnimal(Iterator it) &#123; while(it.hasNext()) &#123; Animal an = (Animal)it.next(); System.out.println(&quot;名字为：&quot;+an.getName()+&quot; 年龄为：&quot;+an.getAge() + &quot; 介绍：&quot;+an.getDescription()); &#125; &#125;&#125; main方法实现－－ 领导来视察了，小花就去统计 123456public static void main(String args[]) &#123; DoctorZhang zhang =new DoctorZhang(); DoctorLi li = new DoctorLi(); PetShop ps =new PetShop(zhang, li); ps.printAnimal();&#125; 运行结果 12345678张医生的宠物名字为：小狗 年龄为：8 介绍：黄色的小狗名字为：小猫 年龄为：4 介绍：黑色的小猫名字为：小猪 年龄为：4 介绍：白色的小猪李医生的宠物名字为：小乌龟 年龄为：8 介绍：黄色的小乌龟名字为：小猴 年龄为：4 介绍：黑色的小猴名字为：大猪 年龄为：4 介绍：黄色的大猪 2、用上面的代码重构为java util 类里面的迭代器实现动物类不变动，改动两个医生的代码迭代器为。注意迭代器换为了import java.util.Iterator; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 张医生实现java util里面的迭代器public class DoctorZhangIteratorJavaUtil implements Iterator&#123; Animal[] ans; int index = 0; public DoctorZhangIteratorJavaUtil(Animal[] ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.length || ans[index] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans[index]; index ++; return animal; &#125; public void remove() &#123; if (index &lt;=0) &#123; throw new IllegalStateException(&quot;没有可以删除的了&quot;); &#125; if(ans[index-1] !=null) &#123; for(int i = index-1; i&lt;(ans.length -1); i++) &#123; ans[i] = ans[i+1]; &#125; ans[ans.length - 1] = null; &#125; &#125;&#125;class DoctorLiIteratorJavaUtil implements Iterator&#123; ArrayList ans; int index = 0; public DoctorLiIteratorJavaUtil(ArrayList ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.size() || ans.get(index) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans.get(index); index ++; return animal; &#125;&#125; 改动两个医生的代码为。注意迭代器换为了import java.util.Iterator; ｀// 张医生用ArrayList区分动物public class DoctorLiJavaUtil implements Doctor{ ArrayList ans; public DoctorLiJavaUtil() { ans = new ArrayList(); addAnimal(“小狗”,8, “黄色的小狗”); addAnimal(“小猫”,4, “黑色的小猫”); addAnimal(“小猪”,4, “白色的小猪”); } // 增加动物方法 public void addAnimal(String name, int age, String des){ Animal an = new Animal(name, age, des); this.ans.add(an); } public Iterator createIterator() { // 直接使用ArrayList的迭代器 return this.ans.iterator(); }}// 李医生用［］区分动物class DoctorZhangJavaUtil implements Doctor{ static final int MAX=5; int number = 0; Animal[] animal; public DoctorZhangJavaUtil() { animal =new Animal[MAX]; addAnimal(“小乌龟”,8, “黄色的小乌龟”); addAnimal(“小猴”,4, “黑色的小猴”); addAnimal(“大猪”,4, “黄色的大猪”); } // 增加动物方法 public void addAnimal(String name, int age, String des){ if (number&gt;=MAX){ return; } Animal an = new Animal(name, age, des); this.animal[number] = an; this.number++; } public Iterator createIterator() { return new DoctorZhangIteratorJavaUtil(this.animal); }}// 新增的医生接口interface Doctor { public Iterator createIterator();}1更改宠物店的代码 // 宠物店import java.util.Iterator;public class PetShopJavaUtil { Doctor zhang; Doctor li; public PetShopJavaUtil(Doctor zhang,Doctor li) { this.zhang = zhang; this.li = li; } public void printAnimal() { Iterator it = zhang.createIterator(); Iterator its = li.createIterator(); System.out.println(&quot;张医生的宠物&quot;); printAnimal(it); System.out.println(&quot;李医生的宠物&quot;); printAnimal(its); } private void printAnimal(Iterator it) { if (it == null) { return; } while(it.hasNext()) { Animal an = (Animal)it.next(); System.out.println(&quot;名字为：&quot;+an.getName()+&quot; 年龄为：&quot;+an.getAge() + &quot; 介绍：&quot;+an.getDescription()); } } } 1main方法运行 public static void main(String args[]) { // java.util 迭代器使用 System.out.println(&quot;++++++++++++++++java.util 迭代器 &quot;); DoctorZhangJavaUtil zhangJavaUtil =new DoctorZhangJavaUtil(); DoctorLiJavaUtil liJavaUtil = new DoctorLiJavaUtil(); PetShopJavaUtil psJavaUtil =new PetShopJavaUtil(zhangJavaUtil, liJavaUtil); psJavaUtil.printAnimal(); } 12运行结果 ++++++++++++++++java.util 迭代器张医生的宠物名字为：小乌龟 年龄为：8 介绍：黄色的小乌龟名字为：小猴 年龄为：4 介绍：黑色的小猴名字为：大猪 年龄为：4 介绍：黄色的大猪李医生的宠物名字为：小狗 年龄为：8 介绍：黄色的小狗名字为：小猫 年龄为：4 介绍：黑色的小猫名字为：小猪 年龄为：4 介绍：白色的小猪` 三、UML类图 四、笔记 封装变化 多用组合,少用继承 面向接口编程，不面向实现编程 为交互对象之间的松耦合设计而努力 对扩展开放，对修改关闭 只跟朋友交谈 依赖抽象不要依赖具体类 别找我，我会找你 类应该只有一个被改变的理由 迭代器模式定义： 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴其露内部的表示 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－工厂模式]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89-%20%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F(%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82)%2F</url>
    <content type="text"><![CDATA[之前学的是装饰者模式 装饰者模式的优点动态地为对象增加新的功能或者撤销功能（继承就不能做到这一点） 装饰者模式的缺点会产生过多的相似的对象！ 一、对工厂模式的理解简单工厂：通过工厂类生成不同的类。工厂类返回一个父类型的类，通过if或者switch判断用户给的数据，通过不同的数据返回不同的类。工厂方法：比较重要的就是抽象类里面的一个抽象方法，所有继承了抽象类的类都必须实现该方法，之后在调用的时候利用多态动态的调用实现类的方法。抽象的方法里面就可以用简单工厂模式实现不同的类 二、代码实现(简单工厂、工厂方法、抽象工厂)1、简单工厂 创建月饼类123456789101112131415161718192021public class MoonCake &#123; public String name; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125;&#125;// 糖陷月饼class sugar extends MoonCake&#123; public sugar()&#123; System.out.println(&quot;糖陷&quot;); &#125;&#125;// 肉陷月饼class meat extends MoonCake &#123; public meat() &#123; System.out.println(&quot;肉馅&quot;); &#125;&#125; 创建简单月饼工厂1234567891011public class SimpleFactory &#123; public MoonCake createProduct(String type) &#123; MoonCake product = null; if (type.equals(&quot;meat&quot;))&#123; product = new meat(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; product = new sugar(); &#125; return product; &#125;&#125; 创建月饼工厂12345678910public class MoonCakeFactory &#123; SimpleFactory factory; public MoonCakeFactory(SimpleFactory factory) &#123; this.factory = factory; &#125; public MoonCake orderMoonCake(String type) &#123; MoonCake product = factory.createProduct(type); return product; &#125;&#125; main方法实现1234567public class run &#123; public static void main(String args[]) &#123; // 简单工厂模式 生产月饼 SimpleFactory simpleFactory = new SimpleFactory(); new MoonCakeFactory(simpleFactory).orderMoonCake(&quot;meat&quot;); &#125;&#125; 运行结果1肉馅 2、工厂方法月饼店抽象类1234567891011// 月饼店public abstract class MoonCakeStore &#123; public MoonCake orderMoonCake(String type) &#123; MoonCake mc; mc = createMoonCake(type); mc.kenad(); return mc; &#125; // 抽象的工厂方法 public abstract MoonCake createMoonCake(String type);&#125; 北方月饼店和南方月饼店123456789101112131415161718192021222324252627// 北方月饼店public class NorthMoonCakeStore extends MoonCakeStore&#123; @Override public MoonCake createMoonCake(String type) &#123; if (type.equals(&quot;meat&quot;)) &#123; return new NorthSytleMeatMoonCake(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new NorthSytleSugarMoonCake(); &#125; return null; &#125;&#125;// 南方月饼店public class SouthMoonCakeStroe extends MoonCakeStore&#123; @Override public MoonCake createMoonCake(String type) &#123; if (type.equals(&quot;meat&quot;)) &#123; return new SouthSytleMeatMoonCake(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new SouthSytleSugarMoonCake(); &#125; return null; &#125;&#125; 月饼父类123456789public class MoonCake &#123; public String name; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125;&#125; 北方月饼和南方月饼12345678910class SouthSytleMeatMoonCake extends MoonCake&#123; public SouthSytleMeatMoonCake() &#123; name =&quot;南方风格的肉馅月饼&quot;; &#125;&#125;class SouthSytleSugarMoonCake extends MoonCake&#123; public SouthSytleSugarMoonCake() &#123; name = &quot;南方风格的糖陷月饼&quot;; &#125;&#125; main方法实现12345678910111213public class run &#123; public static void main(String args[]) &#123; // 工厂方法模式 生产月饼 MoonCakeStore mcs = new SouthMoonCakeStroe(); MoonCakeStore smcs = new NorthMoonCakeStore(); MoonCake mc = mcs.orderMoonCake(&quot;meat&quot;); System.out.println(mc.getName()); MoonCake mc1 = smcs.orderMoonCake(&quot;meat&quot;); System.out.println(mc1.getName()); &#125;&#125; 运行结果1234揉面粉南方风格的肉馅月饼揉面粉北方风格的肉馅月饼 3.抽象工厂 创建一个抽象月饼类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 面粉基类class flour &#123; &#125;// 芝麻基类class sesame&#123; &#125;// 重构之前的抽象月饼类public abstract class MoonCake1 &#123; String name; flour flour; sesame sesame; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125; // 准备 abstract void prepare();&#125;//糖陷月饼class sugar1 extends MoonCake1&#123; MaterailFactory materailFactory; public sugar1()&#123; System.out.println(&quot;糖陷&quot;); &#125; public sugar1(MaterailFactory materailFactory) &#123; name = &quot;糖陷月饼&quot;; this.materailFactory = materailFactory; &#125; @Override void prepare() &#123; System.out.println(&quot;准备制作月饼了&quot;); flour = this.materailFactory.createFlour(); sesame = this.materailFactory.createSesame(); &#125;&#125;//肉陷月饼class meat1 extends MoonCake1 &#123; MaterailFactory materailFactory; public meat1() &#123; System.out.println(&quot;肉馅&quot;); &#125; public meat1(MaterailFactory materail) &#123; this.materailFactory = materail; &#125; @Override void prepare() &#123; flour = this.materailFactory.createFlour(); sesame = this.materailFactory.createSesame(); &#125;&#125; 抽象月饼店123456789101112// 月饼店抽象类 public abstract class MoonCakeStore1 &#123; public MoonCake1 orderMoonCake(String type) &#123; MoonCake1 mc; mc = createMoonCake(type); mc.kenad(); mc.prepare(); return mc; &#125; // 抽象的工厂方法 public abstract MoonCake1 createMoonCake(String type);&#125; 材料接口12345// 材料工厂接口public interface MaterailFactory &#123; public flour createFlour(); public sesame createSesame();&#125; 南方材料工厂实现材料接口12345678910111213141516171819202122232425// 南方材料工厂public class SouthMaterailFactory implements MaterailFactory&#123; @Override public flour createFlour() &#123; return new SouthFlour(); &#125; @Override public sesame createSesame() &#123; return new SouthSesame(); &#125;&#125;// 南方面粉class SouthFlour extends flour&#123; public SouthFlour() &#123; System.out.println(&quot;南方的独特制作的面粉&quot;); &#125;&#125;// 南方芝麻class SouthSesame extends sesame&#123; public SouthSesame() &#123; System.out.println(&quot;南方的独特制作的芝麻&quot;); &#125;&#125; 南方月饼店继承抽象月饼店1234567891011121314// 南方月饼店public class SouthMoonCakeStroe1 extends MoonCakeStore1&#123; @Override public MoonCake1 createMoonCake(String type) &#123; MaterailFactory mf = new SouthMaterailFactory(); if (type.equals(&quot;meat&quot;)) &#123; return new sugar1(mf); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new meat1(mf); &#125; return null; &#125;&#125; 运行代码12345678910public class run &#123; public static void main(String args[])&#123; MoonCakeStore1 mcs1 = new SouthMoonCakeStroe1(); MoonCake1 mc12 = mcs1.orderMoonCake(&quot;meat&quot;); System.out.println(mc12.getName()); MoonCake1 mc11 = mcs1.orderMoonCake(&quot;meat&quot;); System.out.println(mc11.getName()); &#125;&#125; 运行结果12345揉面粉准备制作月饼了南方的独特制作的面粉南方的独特制作的芝麻糖陷月饼 三、UML类图 四、笔记面向对象原则 多用组合，少用继承 针对接口编程、不针对实现编程 为交互之间的松耦合设计而努力 类应该对扩展开发、修改关闭《开闭原则》 依赖抽象、不要依赖具体类《依赖倒置原则》 工厂方法模式定义 定义了一个创建对象的接口，但由于之类子类要决定要实例化哪一个。工厂方法让类的实例推迟到子类 抽象工厂模式定义 提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 注：抽象工厂模式的代码比较复杂，只是做材料的UML类图 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－装饰者模式]]></title>
    <url>%2F2018%2F09%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89%EF%BC%8D%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前学习的是观察模式，复习观察者模式 观察者模式一般在那些地方使用：比如我们有两个对象，一个对象依赖于另一个对象的变化而变化，此时我们可以将这两个对象抽象出来，做成接口，利用观察者模式来进行解耦，又或者，当一个对象发生变化的时候，需要通知别的对象来做出改变，但又不知道这样的对象有多少个，此时利用观察者模式非常合适。 使用观察者模式的好处：第一、观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。 第二、观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知， 观察者模式有下面的缺点：第一、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。第二、如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。第三、如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。第四、虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。 一、对装饰者模式的理解可以想象为给房子装修，有英式风格的房子、中式风格的房子，英式风格有英式风格的桌子、椅子，中式风格有中式风格的桌子椅子、等等。但是我们在装修房子的时候会自己去找材料，椅子有不同的风格、不同的厂家等。最后我们用这些不同的材料来装饰自己的房子。我们可以建立一个房子的抽象类，用材料去实现房子的抽象类。中式风格的房子、英式风格的房子都去实现房子的抽象类。之后用桌子、椅子具体的实现去继承材料抽象类。这样就可以用多态（父类的引用指向自类的对象），具体的看下面的代码 二、代码实现创建房子抽象类12345678// 房子抽象类public abstract class House &#123; String description = &quot;毛坯房&quot;; // 房子的描述 public String getDescription() &#123; return this.description; &#125; public abstract double cost(); // 房子的成本成本&#125; 创建材料抽象类、继承房子类1234// 装修材料public abstract class Material extends House&#123; public abstract String getDescription(); // 重写获取房子描述的方法&#125; 中式风格的房子类、中式风格椅子类、中式风格桌子类12345678910111213141516171819202122232425262728293031323334353637// 中式风格的房子public class ChineseStyle extends House&#123; public ChineseStyle() &#123; description = &quot;中式风格的房子&quot;; &#125; @Override public double cost() &#123; return 888; &#125;&#125;// 中式风格的椅子class ChineseChair extends Material&#123; House house; public ChineseChair(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;＊＊＊中式风格的椅子&quot;; &#125; public double cost () &#123; return 20 + house.cost(); &#125;&#125;// 中式风格的桌子class ChineseDesk extends Material&#123; House house; public ChineseDesk(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;***中式风格的桌子&quot;; &#125; public double cost () &#123; return 50 + house.cost(); &#125;&#125; 英式风格的房子、英式风格的桌子、英式风格的椅子1234567891011121314151617181920212223242526272829303132333435// 英式风格public class EnglandStyle extends House&#123; public EnglandStyle() &#123; description = &quot;英式风格的房子&quot;; &#125; @Override public double cost() &#123; return 666; &#125;&#125;class EnglandChair extends Material&#123; House house; public EnglandChair(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;＊＊＊英式风格的椅子&quot;; &#125; public double cost () &#123; return 20 + house.cost(); &#125;&#125;class EnglandDesk extends Material&#123; House house; public EnglandDesk(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;***英式风格的桌子&quot;; &#125; public double cost () &#123; return 50 + house.cost(); &#125;&#125; 代码运行 123456789101112131415161718public static void main(String args[]) &#123; House house = new ChineseStyle(); System.out.println(house.getDescription() + &quot;***&quot; +house.cost()); // 英式风格的房子用 一张中式风格的桌子，和两把椅子，一把中式风格的，一把英式风格的椅子 House house1 = new EnglandStyle(); // 英式风格的房子 house1 = new ChineseDesk(house1); house1 = new ChineseChair(house1); house1 = new EnglandChair(house1); System.out.println(house1.getDescription() + &quot;***&quot; +house1.cost()); // 中式风格的房子用 一张中式风格的桌子，和两把椅子，一把中式风格的，一把英式风格的椅子 House house2 = new ChineseStyle(); // 中式风格的房子 house2 = new ChineseDesk(house2); house2 = new ChineseChair(house2); house2 = new EnglandChair(house2); System.out.println(house2.getDescription() + &quot;***&quot; +house2.cost()); // 后面就可以按照自己的喜欢装修自己的房子了 // 其它的家具也可以更加灵活的添加了 &#125; 运行结果 123中式风格的房子***888.0英式风格的房子***中式风格的桌子＊＊＊中式风格的椅子＊＊＊英式风格的椅子***756.0中式风格的房子***中式风格的桌子＊＊＊中式风格的椅子＊＊＊英式风格的椅子***978.0 三、UML类图 四、笔记面向对象原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为交互对象之间的松耦合设计而努力 对扩展开发、对修改关闭 装饰者模式的定义 动态的将责任附加到对象上。想要扩展功能，装饰折提供有别于继承的另一种选择 java 的 io流就是用装饰者模式实现的 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux+elasticsearch+logstash 自动同步mysql实现搜索引擎]]></title>
    <url>%2F2018%2F09%2F22%2FLinux%20%E9%83%A8%E7%BD%B2elasticsearch%20%2B%20logstash%20%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5mysql%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[一、安装elasticsearch作用：将数据放到elasticsearch进行搜索 1、配置elasticsearch的yum源1234567891011vim /etc/yum.repos.d/elasticsearch.repo // 配置yum源// 在elasticsearch.repo（如果没有就新建） 中加入一下内容6.x版本以上，将6改为2即可变更为2.x版本[elasticsearch-6.x]name=Elasticsearch repository for 6.x packagesbaseurl=https://artifacts.elastic.co/packages/6.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md 2、yum安装1yum -y install elasticsearch 3、启动1service elasticsearch start // 启动命令 Starting elasticsearch (via systemctl): [ 确定 ] // 出现这个表示启动成功 二、安装logstash用于将mysql里面的数据同步到elasticsearch 123wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.1.zip // 下载到目录解压文件cd logstash-6.4.1 // 进入logstash文件夹vim mysql.conf // 新建mysql.conf文件 在mysql.conf文件中配置如下信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647input &#123; stdin &#123; &#125; jdbc &#123; # mysql数据库连接 jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost/basesdataName?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC&quot; # mysqly用户名和密码 jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;password&quot; # 驱动配置(可以自己下载mysql-connector-java-6.0.5.jar，填写路径即可) jdbc_driver_library =&gt; &quot;./lib/mysql-connector-java-6.0.5.jar&quot; # 驱动类名 jdbc_driver_class =&gt; &quot;com.mysql.cj.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; # 执行指定的sql文件 statement_filepath =&gt; &quot;./data.sql&quot; # 设置监听 各字段含义 分 时 天 月 年 ，默认全部为*代表含义：每分钟都更新 schedule =&gt; &quot;* * * * *&quot; # 索引类型 type =&gt; &quot;product&quot; &#125; &#125; filter &#123; json &#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125; &#125; output &#123; elasticsearch &#123; #es服务器 hosts =&gt; [&quot;localhost:9200&quot;] #ES索引名称 index =&gt; &quot;sl_product&quot; #自增ID document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125; ｝ 新建data.sql 1234vim data.sql // 新建写入如下内容SELECT * FROM tableName // 查询语句 启动logstash 1bin/logstash -f mysql.conf // 在logstash-6.4.1目录启动，如果其它目录，需要更改路径 三、测试是否安装成功1curl &apos;http://127.0.0.1:9200/_search?pretty&apos; // 出现数据库里面的数据表示成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&#123; &quot;took&quot;: 153, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 15, &quot;successful&quot;: 15, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 6, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;426&quot;, &quot;summary&quot;: null, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.179Z&quot;, &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;@version&quot;: &quot;1&quot;, &quot;id&quot;: 2, &quot;category_id&quot;: null, &quot;sub_image&quot;: null, &quot;status&quot;: 1, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.437Z&quot;, &#125; &#125;, &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;123&quot;, &quot;summary&quot;: &quot;1&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;sub_image&quot;: &quot;test&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.178Z&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;123&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.436Z&quot;, &quot;type&quot;: &quot;product&quot;, &quot;tag_price&quot;: null &#125; &#125;, &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;2018-09-22 12:04:14&quot;, &quot;summary&quot;: &quot;&lt;p&gt;123&lt;/p&gt;&lt;audio controls=\&quot;controls\&quot; style=\&quot;display: none;\&quot;&gt;&lt;/audio&gt;&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;status&quot;: 1, &quot;retail_price&quot;: 12, &quot;sub_image&quot;: &quot;test asdf&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.180Z&quot;, &quot;tag_price&quot;: &quot;123&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;version&quot;: 1, &quot;retail_price&quot;: 12, &quot;add_time&quot;: &quot;2018-09-22 12:04:14&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.442Z&quot; &#125; &#125; ] &#125;&#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7安装git服务器]]></title>
    <url>%2F2018%2F09%2F20%2Fcentos7%20%E5%AE%89%E8%A3%85git%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[linux安装git，并配置仓库1.安装git,查看版本号yum install -y git git --version 2.创建git用户useradd git //创建用户 password git //更改密码 3.初始化git仓库，并改变仓库权限cd /home/git mkdir -p test.git //创建仓库 git init --bare test.git //初始化 chown -R git:git test.git //改变权限 4.克隆仓库到本地git clone git@119.10.15.56:/home/git/test.git 本地git与远程git交互1.本地初始化git，并上传git init //初始化 git add test.txt //增加文件到暂存区 git commit -m &apos;注释&apos; //提交文件到本地仓库 git remote rm origin //删除之前的remote git remote add origin git@119.106.185.58:/home/test.git //添加远程起源 git push origin master //通过origin原点添加master分支到远程git仓库 2.更新git pull origin master //取回origin主机的master分支，与本地当前分支合并 3.常用上传git add -A //将所有的新文件添加到暂存区 git add test.txt //增加文件到暂存区 git commit -m &apos;注释&apos; //提交文件到本地仓库 git commit -a -m &apos;注释&apos; //将所有的文件提交到本地仓库 git push origin master //通过origin原点添加master分支到远程git仓库 4.常用git命令 git status //查看git状态 git remote -v //查看所有原点 git branch //看看分支 git chechout aaa //切换分支aaa git branck aaa //创建aaa分支 git chechout -b aaa //本地创建 aaa分支，同时切换到aaa分支。只有提交的时候才会在服务端上创建一个分支 git pull origin master //更新指定分支 git branch -vv // 查看分支跟踪的远程分支 git merge master // 合并主分支 git stash // 暂存 git push origin master --force //强制上传，将本地代码覆盖掉远程代码 git钩子自动执行更新 ###1.在初始化git仓库里面找到hooks文件夹，并在里面创建钩子文件 vim post-receive //用vim创建文件 chmod 755 post-receive // 更改执行权限 ###2.编辑自动执行脚本 #!/bin/sh PATH=/home/fileDir/ //你需要部署的项目路径。注意文件夹的权限问题 cd $PATH unset $(git rev-parse --local-env-vars) //git的hooks里面默认有一些环境变量,导致无论在哪个语句之后执行git命令都会有默认环境路径,直接unset掉默认的环境变量就好 /usr/bin/git pull //更新项目 sudo /home/sh/git_hook.sh //切换到root用户身份执行自己的脚本 注意：该命令需要在/etc/sudoers 大概91行左右的root ... 下面添加：git ALL=(ALL) NOPASSWD:/home/sh/git_hook.sh（添加是需要改变文件的写权限，否则无法添加） ###3.服务器克隆本地git仓库代码 git clone /home/test.git 注意不要通过git clone git@127.0.0.1/home/test.git导出，会出现git pull需要输入密码导致无法自动化部署。爬了很久的坑 暂时需要使用到的命令就这些。以后遇到了在增加]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux+nginx+tomcat的java项目打包war部署]]></title>
    <url>%2F2018%2F09%2F18%2Flinux%2Bnginx%2Btomcat%E7%9A%84java%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85war%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[环境：linux centos 7 系统、jdk8+tomcat8+nginx-1.12.1+mysql-5.7.16(jdk,tomcat,mysql是通过阿里云的java环境一键部署的，非阿里云的服务器可以自己搭建环境) 1.将java代码进行war打包 eclipse打包 选择路径，点击finish即可 2.将war包移动到tomcat的webapps目录下面通过ftp或者scp可以直接将本地的代码放到linux服务器上面scp命令：scp 文件名 root@地址:/root （scp test.war root@107.1.0.1:/root） 3.启动tomcat会出现地址被占用 可以用命令：netstat -ltunp 。查看所有的端口号使用情况 如果有（tomcat默认使用8080、8009、8005）端口运行；直接用命令：kill -9 端口号 重启4.安装nginx-1.12.1 安装的sh脚本如下 #!/bin/sh yum install pcre-devel -y yum install openssl-devel -y yum install zlib-devel -y wget http://nginx.org/download/nginx-1.12.1.tar.gz tar -zvxf nginx-1.12.1.tar.gz cd nginx-1.12.1 ./configure make make install cd /usr/local/nginx/sbin/ ./nginx -t /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 详情：https://www.jianshu.com/p/73efd33b9da4 配置nginx.conf文件 server_name 自己的域名 location ^~ /自己的项目 { proxy_pass http://localhost:8080; } 5.重启nginx服务器如果使用的上面的脚本安装的可以使用一下方式停止nginx，和启动nginx 停止nginx: /usr/local/nginx/sbin/nginx -s stop 启动nginx: /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf6.开放nginx默认的80端口阿里云服务器可以直接在配置安全组里面配置 之后就可以通过域名访问啦]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－观察者模式]]></title>
    <url>%2F2018%2F09%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89%EF%BC%8D%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前学习的是策略模式，复习一下之前的策略模式 ###策略模式一般在哪方面使用“策略”百科中指[计策]。一般是指：1. 可以实现目标的方案集合；2. 根据形势发展而制定的行动方针和斗争方法；3. 有斗争艺术，能注意方式方法。就是用不同的策略解决不同的问题。如出门的方式有自驾、火车、飞机等。选择不同的出行方式就是不同的策略程序中就是对各个算法的封装。让客服端非常方便的可以调用。我理解为就是在一个类中属性有相同的地方。带式行为方法不同，为了以后添加类特别方便，就可以考虑使用策略模式。 ###使用策略模式有什么好处 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。 策略模式提供了可以替换继承关系的办法。 使用策略模式可以避免使用多重条件转移语句。 ##一、对观察者模式的理解： 观察者模式可以理解为很多人去观察一个事物。我打个微信公众好的比喻，就像微信的公众号一样，可以经常给用户推送信息（一周可以给每个用户推送4篇文章）。用户可以取消关注，取消之后，公众号就无法给该用户发送消息了。当用户关注该公众号之后，就可以每月接收文章了。观察者模式可以很好的实现这种功能。话不多说，代码实现功能 ##二、代码实现观察者模式在java中有两种实现，一种是自己实现，还有一种就是java自带的jdk中已经写好了的，我两种都实现 1、自己用代码实现观察者模式创建公众号接口，用于其他公众号实现 public interface OfficialAccounts { public void follow(User user); // 关注公众号 public void unfollow(User user); // 取消关注 public void sendMessageAll(); // 给所有的用户发送消息 } 创建一个新闻的公众号用于实现公众号接口，新增其它公众号，直接实现OfficialAccounts就好了 // 新闻公众号 public class NewsOfficialAccounts implements OfficialAccounts{ private ArrayList users; private String content; public NewsOfficialAccounts () { users = new ArrayList(); } @Override public void follow(User user) { // 关注该公众号 users.add(user); } @Override public void unfollow(User user) { // 取消关注 int i = users.indexOf(user); if(i&gt;=0) { users.remove(i); } } @Override public void sendMessageAll() { // 给所有用户发送文章 for(int i = 0; i&lt;users.size();i++) { User user = (User) users.get(i); user.acceptMessage(content); } } public void setContent(String content){// 设置消息自动给所有用户发送文章 this.content = content; sendMessageAll(); } } 创建用户类接口，用于接受公众号文章 public interface User { public void acceptMessage(String content); // 接收消息 } 创建用户实现用户接口。创建其它用户也只需要实现User接口 // 用户jason public class UserJason implements User{ private String name = &quot;jason&quot;; private String message; private OfficialAccounts os; @Override public void acceptMessage(String content) { System.out.println(name+&quot;接收到了&quot;+content); this.message = content; } public UserJason(OfficialAccounts os) { // 构造器作为关注公众号用 this.os = os; os.follow(this); } public void unfollow(){ // 取消关注 os.unfollow(this); } } // 用户tom public class UserTom implements User{ private String name = &quot;tom&quot;; private String message; private OfficialAccounts os; @Override public void acceptMessage(String content) { System.out.println(name+&quot;接收到了&quot;+content); this.message = content; } public UserTom(OfficialAccounts os) { // 构造器作为关注公众号用 this.os = os; os.follow(this); } } main方法运行 public static void main(String args[]) { // 创建一个新闻的公众号 NewsOfficialAccounts noa = new NewsOfficialAccounts(); // 创建用户 UserTom tom = new UserTom(noa); UserJason jason = new UserJason(noa); // 公众号发送消息 noa.setContent(&quot;新闻消息1&quot;); noa.setContent(&quot;新闻消息2&quot;); jason.unfollow(); // 取消关注，jason无法接收消息3 noa.setContent(&quot;新闻消息3&quot;); } 运行结果：实现类发现消息之后只要所有关注了新闻公众号的用户可以接受消息，没有关注的就没有接收到 jason接收到了新闻消息1 tom接收到了新闻消息2 jason接收到了新闻消息2 tom接收到了新闻消息3 ####2、用java jdk 自带的Observable、Observer实现创建公众号 public class BankOffcialAccounts extends Observable{ // 实现java自带的可观察者接口 private String content; // 接受的消息 public BankOffcialAccounts(){}; // 构造器 public void changed() { // 消息变化方法 setChanged(); notifyObservers(); // 通知所有观察者 } public void sendMessage(String content) { // 发送消息 this.content = content; changed(); } public String getContent() { return content; } public void setContent(String content) { // 写入公众号内容 this.content = content; } } 创建一个用java自带的观察者用户（同上面的UserJason、UserTom） public class UserJDK implements Observer{ // 实现java自带的观察者 Observable observable; private String name = &quot;jdk&quot;; private String content; @Override public void update(Observable o, Object arg) { if (o instanceof BankOffcialAccounts) { BankOffcialAccounts boa = (BankOffcialAccounts)o; this.content = boa.getContent(); System.out.println(name+&quot;接收到了&quot;+content); } } public UserJDK(Observable o) { this.observable = o; observable.addObserver(this); } } 和之前自己写的观察者模式一起运行 public static void main(String args[]) { // 创建一个新闻的公众号 NewsOfficialAccounts noa = new NewsOfficialAccounts(); // 创建用户 UserTom tom = new UserTom(noa); UserJason jason = new UserJason(noa); BankOffcialAccounts bank = new BankOffcialAccounts(); UserJDK jdk = new UserJDK(bank); // 发送消息 noa.setContent(&quot;新闻消息1&quot;); noa.setContent(&quot;新闻消息2&quot;); jason.unfollow(); // 取消关注，jason无法接收消息3 noa.setContent(&quot;新闻消息3&quot;); bank.sendMessage(&quot;发送消息4&quot;); } 运行结果 tom接收到了新闻消息1 jason接收到了新闻消息1 tom接收到了新闻消息2 jason接收到了新闻消息2 tom接收到了新闻消息3 jdk接收到了发送消息4 需要注意的是Observable是一个类，必须要写一个类基础他。限制类Observable的复用潜力 三、UML类图 Observable、Observer 是java jdk自带的 四、笔记1、面向对象原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为交互对象之间的松耦合而努力 2、观察模式定义在对象之间定义一对多的依赖、这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次数据库迁移的失败经历]]></title>
    <url>%2F2018%2F09%2F10%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E7%9A%84%E7%BB%8F%E5%8E%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%8F%98%E5%8A%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[s表数据结构 表一表二表三 目标:将表一的数据迁移到表二、表三里面，一分为二。表二里面放产品主体，表三里面放多规格 ##原因： 由于之前设计表的经验不足，没有考虑到产品多规格的情况，写到快完成的时候，才想到用两张表实现产品的多规格（引以为戒，以后设计表的时候，要多方面考虑）。之前用一张表的时候是用checked字段区分产品是否为多规格的，如果是单规格和多规格的主体，就存1。否则就存多规格主体的ID。最终导致现在上传了2915个产品（包括多规格）。管理很混乱，数据比较多，不可能手工重新传了的。只能做数据迁移。 实现思路有两种办法：####一、通过实体类迁移数据。 1.创建originCommodity(表一),commodity（表二），commodityDetail（表三）实体类2.通过dao获取所有的originCommodity数据（获取所有的数据）。用for循环将originCommodity里面的数据分割为两张表commodity、commodity。并通过dao的inster批量创建commodity、commodityDetail数据（需要写sql批量插入数据） ####二、手动navicat软件＋少量sql 将表一里面的数据导入本地的数据库，通过navicat软件手动将不同的字段更改为表二里面的字段，不需要的字段直接删除。之后将数据直接导入到表二，完成迁移。（这是最笨的方法进行迁移。但是迁移的时候需要注意的是ID，表一的是uuid生成的ID，表二是自增ID）。 1.将表一分成两个表，commodity、commodityDetail。 commodity里面全部放checked=1的数据（主体）。commodityDetail里面存checked!=1的数据（多规格）。（创建两个表，复制表一里面的全部数据，将commodity里面的checked!=1的删除，将commodityDetail表里面的checked=1的数据删除，完成创建）2.增加一个在commodity里面增加一个origin_id(原来的uuid),用来存放之前的ID。将commodity的ID更改为origin_id。id为自增ID3.更改commodityDetail表里面的checked字段，需要将commodityDetail里面的checked等于commodity表里面的origin_id的数据变为commodity的自增ID。 ###用方法二处理数据遇到的问题： 由于想要尽快的处理这个问题，我选择了方法二，用最笨的方法处理数据。一路都很顺利的处理完成了。结束之后，我就将原来的commodity删除了。因为要将表里面的数据的ID更改为自增ID，而且开始的时候是新增了自增ID的字段的，之后将原来的uuid字段更改为了origin_id。这样方便其他表关联这张表的时候，可以通过origin_id获取更改之后的ID。但是有一张表我遗漏了，没有将表里面的ID更改，就将这个origin_id删除了。导致现在有一张表无法获取ID。因此，这种方法是一个很笨切不能从用的笨办法，如果用第一种方法，就不会出现这种问题了。还好这次更改的只是测试数据，下次重新用第一种方法试一次 ##数据库需要用到的命令 ###一、 将sql数据签出并放到本地： mysqldump -hlocalhost -uroot –databases 数据库名 | gzip &gt; /root/DatabaseName_$(date +%Y%m%d_%H%M%S).sql.gz scp root@ip地址:/root/sql文件名 ./Desktop // 将文件复制到本地 边纪录，边成长end]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－策略模式]]></title>
    <url>%2F2018%2F09%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88java%EF%BC%89%EF%BC%8D%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近在读head frist 的设计模式。之前就了解过这本书的，感觉还不错，于是就在淘宝上购买了一本。书有500多页挺厚的一本，内容都是很容易上手的，当成漫画看就可以了。本着学习的态度，我想认认真真的把设计模式好好学习一下。设计模式很多，一个一个的学，学完一个，我就在这里纪录一下自己的学习成果、自己对设计模式的理解、以及一些笔记、代码就是自己想一个显示生活中的例子模拟实现。 一、对策略模式的理解&emsp;&emsp;关于策略模式，我看完书之后回忆的起来的大概就是建立一个抽象类，抽象除类的不改变的属性，如动物的名字、年龄等这些都是每个动物都有的，不会改变的。 二、代码实现创建一个动物类1234 public abstract class animal &#123; private String name; private int age;｝ 然后多个类继承该抽象类，如小猫、小狗等。 public class Dog extends animal{} 之后就是动物有的会飞、会叫等。这些都是动物的行为。之后把动物的飞行、叫喊接口化。 public interface CallBehavior { // 叫喊行为 public void call(); } public interface FlyBehavior { // 飞行行为 public void fly(); } 会飞、会叫都可以是动物的行为。就可以将会飞、会叫的接口组合在动物类里面，当成动物的属性 public abstract class animal { private String name; private int age; FlyBehavior flyBehavior; // 让所有的动物都继承这个行为 CallBehavior callBehavior; // 添加方法，用于被继承的动物共用方法 public void performFly() { // 执行飞行 flyBehavior.fly(); } public void performCall() { // 执行叫喊 callBehavior.call(); } public void setFlyBehavior(FlyBehavior fly){ // 动态的设置飞行的实现类，可以在运行时改变动物的飞行方式 this.flyBehavior = fly; } public void setCallBehavior(CallBehavior call){ this.callBehavior = call; } ｝ 之后就用不同的实现类实现会飞、会叫的接口 // 叫喊接口实现 public class CallBig implements CallBehavior{ @Override public void call() { System.out.println(&quot;特别大声的叫&quot;); } } public class CallNoWay implements CallBehavior{ @Override public void call() { System.out.println(&quot;不会叫&quot;); } } // 飞行接口实现 public class FlyNoWay implements FlyBehavior{ @Override public void fly() { System.out.println(&quot;不会飞行&quot;); } } public class FlyWithWings implements FlyBehavior{ @Override public void fly() { System.out.println(&quot;我要飞的更高&quot;); } } 然后就可以给小狗类添加默认的构造器。 public class Dog extends animal{ public Dog() { // 小狗的构造器 callBehavior = new CallBig(); // 大声叫callBehavior 使用的是父类的变量 flyBehavior = new FlyNoWay(); } } 调用 public static void main(String args[]) { animal dw = new DogModle(); dw.performFly(); // 默认飞行 dw.performCall(); // 默认叫喊 dw.setFlyBehavior(new FlyWithWings()); //动态绑定飞行行为 dw.performFly(); // 更改之后的飞行方式 } 执行结果 不会飞行 特别大声的叫 我要飞的更高 这样就动态实现了数据的绑定，根据不同的策略，绑定不同的接口。动态的完成功能，后期添加其他动物，也不需要更改之前的代码。完全做到了，对新增开放、对修改闭合的开闭原则。 三、UML类图画的不正规的uml图 四、笔记1、学到的三个原则 将会变动的代码进行封装 针对接口编程，不针对实现编程 多用组合、少用继承 ####2、策略模式定义 定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用自定义注解进行切面，@Autowired装配的service一直报错空指针]]></title>
    <url>%2F2018%2F08%2F30%2F%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E5%88%87%E9%9D%A2%EF%BC%8C%40Autowired%E8%A3%85%E9%85%8D%E7%9A%84service%E4%B8%80%E7%9B%B4%E6%8A%A5%E9%94%99%E7%A9%BA%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[切面的方法是public就可以了]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Autowired</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现redis缓存功能]]></title>
    <url>%2F2018%2F08%2F30%2Fjava%E5%AE%9E%E7%8E%B0redis%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[一、安装redis1.mac安装，如果有安装brew 可以直接快捷安装：brew install redis 2.linux下载安装wget http://download.redis.io/releases/redis-2.8.17.tar.gz tar xzf redis-2.8.17.tar.gz cd redis-2.8.17 make 二、redis常用命令redis-cli // 进入命令行 /usr/local/bin/redis-server /usr/local/etc/redis.conf // 启动 找到你的redis-server、redis-server路径 quit // 退出 keys * // 查询所有的key set a 123 //创建字符串key（a）, value(123) get a // 查看字符串key为a的value del a //删除字符串key为a的数据 hmset key name &quot;a&quot; description &quot;123&quot; // hashmap的创建 hgetall a //hashmap通过key获取 lpush a 123 // list创建 lrange a 0 10 //list 获取 sadd a 123 // 集合set创建 smembers a // 集合set 获取 zadd a 123 // 有序集合set创建 zrange a 1 10 smembers // 集合set 获取 注：初期使用的命令，后期遇到之后在进行添加 三、spring boot集成redis1.项目基于spring boot创建的，eclipse 集成spring boot 后，可以选择redis，之后自动生成如下代码（pom.xml）:&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.配置redis，在application.propertise 的文件里面添加如下：spring.redis.database=0 spring.redis.host=localhost spring.redis.port=6379 // 端口号 spring.redis.password=redispass // 密码 spring.redis.pool.max-active=8 spring.redis.pool.max-wait=-1 spring.redis.pool.max-idle=8 spring.redis.pool.min-idle=0 spring.redis.timeout=5000 // 链接超时时间，可以设置大一些 3.创建一个service接口（redisService）：@Service public class RedisService { @Autowired private StringRedisTemplate redisTemplate; /** * 一周有多少秒 */ private static final long WEEK_SECONDS = 7 * 24 * 60 * 60; /** * 将 key，value 存放到redis数据库中，默认设置过期时间为一周 * @param key * @param value */ public void set(String key, Object value) { redisTemplate.opsForValue().set(key, JsonUtil.convertObj2String(value), WEEK_SECONDS, TimeUnit.SECONDS); } /** * 将 key，value 存放到redis数据库中，设置过期时间单位是秒 * * @param key * @param value * @param expireTime */ public void set(String key, Object value, long expireTime) { redisTemplate.opsForValue().set(key, JsonUtil.convertObj2String(value), expireTime, TimeUnit.SECONDS); } /** * 判断 key 是否在 redis 数据库中 * * @param key * @return */ public boolean exists(final String key) { return redisTemplate.hasKey(key); } /** * 获取与 key 对应的对象 * @param key * @param clazz 目标对象类型 * @param &lt;T&gt; * @return */ public &lt;T&gt; T get(String key, Class&lt;T&gt; clazz) { String s = get(key); if (s == null) { return null; } return JsonUtil.convertString2Obj(s, clazz); } /** * 获取 key 对应的字符串 * @param key * @return */ public String get(String key) { return redisTemplate.opsForValue().get(key); } /** * 删除 key 对应的 value * @param key */ public void delete(String key) { redisTemplate.delete(key); } } 4.在PifajiaOfficialApplicationTests里面进行测试@Test public void redisService(){ String str = &quot;test&quot;; String retStr = this.redisService.get(&quot;test&quot;); if(retStr == null) { this.redisService.set(&quot;test&quot;, str); retStr = str; } System.out.println(&quot;:::&quot;+retStr); } end]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
