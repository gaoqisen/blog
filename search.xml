<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven学习记录]]></title>
    <url>%2F20190919.html</url>
    <content type="text"><![CDATA[mvn命令行新建spingboot项目 命令行创建 12345mvn archetype:generate -DinteractiveMode=false -DgroupId=com.gqs -DartifactId=springboot -Dversion=1.0.0-SNAPSHOT-DgroupId //包名-DartifactId //项目名-DarchetypeArtifactId //类型maven-archetype-quickstart,创建一个Java Project,maven-archetype-webapp,创建一个Web Project-DinteractiveMode //是否使用交互模式,如果为false,非交互式的命令后直接创建,否则会有控制台提示输入操作 idea导入项目 常用目录结构 1234567891011121314151617181920212223│── src│ └── main│ ├── java│ │ └── com│ │ └── gqs│ │ └── dir│ │ ├── config // 配置│ │ ├── constant // 常量│ │ ├── controller // 控制层│ │ ├── exception // 异常处理│ │ ├── mapper // 数据层│ │ ├── pojo // 实体类│ │ ├── service // 服务层│ │ └── utils // 工具类│ ├── resources│ │ ├── application.yml│ │ ├── image│ │ ├── lib // 第三方jar│ │ ├── mapper // mapper.xml文件│ │ ├── static // 静态文件│ │ └── templates // html文件│ └── test│── pom.xml pom.xml配置 12345678910111213141516171819202122232425262728293031323334 // 对于SpingBoot测试Junit至少是4.1-4.2以上的版本,所以把版本号删除默认的就行, 可以直接替换以下配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.abc.test&lt;/groupId&gt; &lt;artifactId&gt;test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;test&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; main配置 12345678// 添加@SpringBootApplication注释和pringApplication.run(App.class); @SpringBootApplication public class App &#123; public static void main( String[] args )&#123; SpringApplication.run(App.class, args); System.out.println( &quot;Hello World!&quot; ); &#125; &#125; 创建controller/Test.java 123456789 // 必须要写在App启动类一个包下才能够扫描到@RestController // @RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。@RequestMapping(&quot;/app&quot;)public class Test &#123; @GetMapping(&quot;start&quot;) public String test() &#123; return &quot;ok&quot;; &#125;&#125; 在main文件夹下面创建配置文件的目录resources/application.yml 123// 更改端口号server: port: 8889 启动服务成功后访问链接http://localhost:8889/app/start， 返回OK表示成功 脚手架创建的项目也可以自己手动创建目录 maven常用命令1234567891011121314151617181920212223242526272829mvn -v 显示版本 mvn help:describe -Dplugin=help 使用 help 插件的 describe 目标来输出 Maven Help 插件的信息。 mvn help:describe -Dplugin=help -Dfull 使用Help 插件输出完整的带有参数的目标列 mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull 获取单个目标的信息,设置 mojo 参数和 plugin 参数。此命令列出了Compiler 插件的compile 目标的所有信息 mvn help:describe -Dplugin=exec -Dfull 列出所有 Maven Exec 插件可用的目标 mvn help:effective-pom 看这个“有效的 (effective)”POM，它暴露了 Maven的默认设置 mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 -DartifactId=simple -DpackageName=org.sonatype.mavenbook 创建Maven的普通java项目，在命令行使用Maven Archetype 插件 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序 mvn dependency:resolve 打印出已解决依赖的列表 mvn dependency:sources 下载源码mvn dependency:tree 打印整个依赖树 mvn install -X 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行 mvn install -Dmaven.test.skip=true 给任何目标添加maven.test.skip 属性就能跳过测试 mvn install assembly:assembly 构建装配Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件 mvn jetty:run 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 mvn compile 编译你的项目 mvn test-compile 编译测试代码mvn test 运行测试mvn package 打包，根据pom.xml打成war或jarmvn -Dtest package 打包但不测试mvn clean 清除产生的项目mvn idea:idea 生成idea项目mvn eclipse:eclipse 生成eclipse项目mvn clean install 删除再编译 mvn hibernate3:hbm2ddl 使用 Hibernate3 插件构造数据库]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK学习]]></title>
    <url>%2F20190825.html</url>
    <content type="text"><![CDATA[Elasticsearch简介ElasticSearch是一个基于Lucene构建的开源，分布式，RESTful搜索引擎。 设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方维护的docker镜像https://www.docker.elastic.co/ 安装（lastic 需要 Java 8 环境）123456789101112131415161718mac: brew install elasticsearch // 安装 elasticsearch --version // 查看版本号 elasticsearch // 启动后默认端口9200linux: wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.3.1.zip unzip elasticsearch-7.3.1.zip cd elasticsearch-7.3.1/ ./bin/elasticsearch // 启动docker: docker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.1 // 拉取镜像 docker tag docker.elastic.co/elasticsearch/elasticsearch:7.3.1 elasticsearch docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch // 运行容器 docker exec -it es /bin/bash // 进入容器 vi elasticsearch.yml // 添加如下配置解决跨域问题 http.cors.enabled: true http.cors.allow-origin: &quot;*&quot; docker restart es // 重启 配置文件https://blog.csdn.net/yjclsx/article/details/81319454 Kibana简介Kibana 是一款开源的数据分析和可视化平台，它是Elastic Stack 成员之一，设计用于和Elasticsearch 协作。 … 它很简单，基于浏览器的界面便于您快速创建和分享动态数据仪表板来追踪Elasticsearch 的实时数据变化。 搭建Kibana 非常简单。 安装12345678910111213mac: brew install kibana // 安装 kibana // 启动后默认端口5601linux: wget https://artifacts.elastic.co/downloads/beats/kibana/kibana-7.3.1-linux-x86_64.tar.gz tar -zxvf kibana-7.3.1-linux-x86_64.tar.gz ./kibana // 进入kibana的bin目录进行启动 nohup ./kibana &amp; // 后台启动docker: docker pull docker.elastic.co/kibana/kibana:7.3.1 docker tag docker.elastic.co/kibana/kibana:7.3.1 kibana docker run --name kibana -p 5601:5601 -d kibana docker run -d -p 5601:5601 --link elasticsearch -e ELASTICSEARCH_URL=http://elasticsearch:9200 kibana // 使用link参数，会在kibana容器hosts文件中加入elasticsearch ip地址，这样我们就直接通过定义的name来访问es服务了 配置文件https://www.elastic.co/guide/cn/kibana/current/settings.html Logstash简介它一个有jruby语言编写的运行在java虚拟机上的具有收集分析转发数据流功能的工具 安装123456789101112mac: brew install logstash logstash --versionlinux: wget https://artifacts.elastic.co/downloads/logstash/logstash-7.3.1.tar.gz tar -zxvf logstash-7.3.1.tar.gz bin/logstash -e &apos;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;&apos;docker: docker pull docker.elastic.co/logstash/logstash:7.3.1 docker tag docker.elastic.co/logstash/logstash:7.3.1 logstash docker run -d --name logstash 10.45.53.221:5000/logstash docker run --rm -it --name logstash --link elasticsearch -d -v ~/elk/yaml/logstash.conf:/usr/share/logstash/pipeline/logstash.conf logstash // 启动logstash并关联elasticsearch 配置文件12345678910111213141516171819202122232425262728logstash.confinput &#123; beats &#123; host =&gt; &quot;localhost&quot; port =&gt; &quot;5043&quot; &#125;&#125;filter &#123; if [fields][doc_type] == &apos;order&apos; &#123; grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;TIMESTAMP_ISO8601:timestamp&#125; %&#123;LOGLEVEL:level&#125; %&#123;JAVALOGMESSAGE:msg&#125;&quot; &#125; &#125; &#125; if [fields][doc_type] == &apos;customer&apos; &#123; # 这里写两个一样的grok，实际上可能出现多种不同的日志格式，这里做个提示而已,当然如果是相同的格式，这里可以不写的 grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;TIMESTAMP_ISO8601:timestamp&#125; %&#123;LOGLEVEL:level&#125; %&#123;JAVALOGMESSAGE:msg&#125;&quot; &#125; &#125; &#125;&#125;output &#123; stdout &#123; codec =&gt; rubydebug &#125; elasticsearch &#123; hosts =&gt; [ &quot;localhost:9200&quot; ] index =&gt; &quot;%&#123;[fields][doc_type]&#125;-%&#123;+YYYY.MM.dd&#125;&quot; &#125;&#125; filebeat简介Filebeat是一个轻量级日志传输Agent，可以将指定日志转发到Logstash、Elasticsearch、Kafka、Redis等中。Filebeat占用资源少，而且安装配置也比较简单，支持目前各类主流OS及Docker平台。 安装1234567891011mac: brew install filebeatlinux: wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.3.1-linux-x86_64.tar.gz tar -zxvf filebeat-7.3.1-linux-x86_64.tar.gz nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp; // 后台启动将所有标准输出及标准错误输出到/dev/null空设备，即没有任何输出docker: docker pull docker.elastic.co/beats/filebeat:7.3.1 docker tag docker.elastic.co/beats/filebeat:7.3.1 filebeat docker run -d --name logstash 10.45.53.221:5000/filebeat docker run --name filebeat -d --link logstash -v ~/elk/yaml/filebeat.yml:/usr/share/filebeat/filebeat.yml -v ~/elk/logs/:/home/logs/ filebeat // 启动filebeat并关联logstash 配置文件1234567891011121314151617181920filebeat.ymlfilebeat.prospectors:- paths: - /home/user/elk/logs/order/*.log multiline: pattern: ^\d&#123;4&#125; negate: true match: after fields: doc_type: order- paths: - /home/user/elk/logs/customer/*.log multiline: pattern: ^\d&#123;4&#125; negate: true match: after fields: doc_type: customeroutput.logstash: # 输出地址 hosts: [&quot;logstash:5043&quot;]]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl命令学习]]></title>
    <url>%2F20190816.html</url>
    <content type="text"><![CDATA[作用在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 常用参数12345678910111213141516-A/--user-agent &lt;string&gt; 设置用户代理发送给服务器-b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置-c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中-C/--continue-at &lt;offset&gt; 断点续转-D/--dump-header &lt;file&gt; 把header信息写入到该文件中-e/--referer 来源网址-f/--fail 连接失败时不显示http错误-o/--output 把输出写到该文件中-O/--remote-name 把输出写到该文件中，保留远程文件的文件名-r/--range &lt;range&gt; 检索来自HTTP/1.1或FTP服务器字节范围-s/--silent 静音模式。不输出任何东西-T/--upload-file &lt;file&gt; 上传文件-u/--user &lt;user[:password]&gt; 设置服务器的用户和密码-w/--write-out [format] 什么输出完成后-x/--proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理-#/--progress-bar 进度条显示当前的传送状态 例子基本get、post请求123curl www.baidu.com // get请求curl -d &quot;name=123&amp;age=20&quot; www.google.com // post请求curl --data &quot;name=123&amp;age=20&quot; www.google.com // post请求 代理请求12curl --proxy 192.168.0.1:8080 www.google.com // 代理get请求，192.168.0.1:8080为代理IPcurl --data &quot;name=123&amp;age=20&quot; --proxy 192.168.0.1:8080 www.google.com // 代理post请求，192.168.0.1:8080为代理IP 带cookie请求1234curl -c cookies www.google.com // get请求取得cookie,保存到cookiescurl -b cookies -c cookies -d &apos;name=123&amp;age=20&apos; &apos;www.google.com&apos; // 带cookie的post请求curl -c cookies --proxy 192.168.0.1:8080 www.google.com // get代理请求取得cookie,保存到cookiescurl -b cookies -c cookies --proxy 192.168.0.1:8080 -d &apos;name=123&amp;age=20&apos; &apos;www.google.com&apos; // 带cookie的代理post请求 其他参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192-a/--append 上传文件时，附加到目标文件--anyauth 可以使用“任何”身份验证方法--basic 使用HTTP基本验证-B/--use-ascii 使用ASCII文本传输-d/--data &lt;data&gt; HTTP POST方式传送数据--data-ascii &lt;data&gt; 以ascii的方式post数据--data-binary &lt;data&gt; 以二进制的方式post数据--negotiate 使用HTTP身份验证--digest 使用数字身份验证--disable-eprt 禁止使用EPRT或LPRT--disable-epsv 禁止使用EPSV--egd-file &lt;file&gt; 为随机数据(SSL)设置EGD socket路径--tcp-nodelay 使用TCP_NODELAY选项-E/--cert &lt;cert[:passwd]&gt; 客户端证书文件和密码 (SSL)--cert-type &lt;type&gt; 证书文件类型 (DER/PEM/ENG) (SSL)--key &lt;key&gt; 私钥文件名 (SSL)--key-type &lt;type&gt; 私钥文件类型 (DER/PEM/ENG) (SSL)--pass &lt;pass&gt; 私钥密码 (SSL)--engine &lt;eng&gt; 加密引擎使用 (SSL). &quot;--engine list&quot; for list--cacert &lt;file&gt; CA证书 (SSL)--capath &lt;directory&gt; CA目 (made using c_rehash) to verify peer against (SSL)--ciphers &lt;list&gt; SSL密码--compressed 要求返回是压缩的形势 (using deflate or gzip)--connect-timeout &lt;seconds&gt; 设置最大请求时间--create-dirs 建立本地目录的目录层次结构--crlf 上传是把LF转变成CRLF--ftp-create-dirs 如果远程目录不存在，创建远程目录--ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用--ftp-pasv 使用 PASV/EPSV 代替端口--ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址--ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输--ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输-F/--form &lt;name=content&gt; 模拟http表单提交数据-form-string &lt;name=string&gt; 模拟http表单提交数据-g/--globoff 禁用网址序列和范围使用&#123;&#125;和[]-G/--get 以get的方式来发送数据-h/--help 帮助-H/--header &lt;line&gt; 自定义头信息传递给服务器--ignore-content-length 忽略的HTTP头信息的长度-i/--include 输出时包括protocol头信息-I/--head 只显示文档信息-j/--junk-session-cookies 读取文件时忽略session cookie--interface &lt;interface&gt; 使用指定网络接口/地址--krb4 &lt;level&gt; 使用指定安全级别的krb4-k/--insecure 允许不使用证书到SSL站点-K/--config 指定的配置文件读取-l/--list-only 列出ftp目录下的文件名称--limit-rate &lt;rate&gt; 设置传输速度--local-port&lt;NUM&gt; 强制使用本地端口号-m/--max-time &lt;seconds&gt; 设置最大传输时间--max-redirs &lt;num&gt; 设置最大读取的目录数--max-filesize &lt;bytes&gt; 设置最大下载的文件总量-M/--manual 显示全手动-n/--netrc 从netrc文件中读取用户名和密码--netrc-optional 使用 .netrc 或者 URL来覆盖-n--ntlm 使用 HTTP NTLM 身份验证-N/--no-buffer 禁用缓冲输出-p/--proxytunnel 使用HTTP代理--proxy-anyauth 选择任一代理身份验证方法--proxy-basic 在代理上使用基本身份验证--proxy-digest 在代理上使用数字身份验证--proxy-ntlm 在代理上使用ntlm身份验证-P/--ftp-port &lt;address&gt; 使用端口地址，而不是使用PASV-Q/--quote &lt;cmd&gt; 文件传输前，发送命令到服务器--range-file 读取（SSL）的随机文件-R/--remote-time 在本地生成文件时，保留远程文件时间--retry &lt;num&gt; 传输出现问题时，重试的次数--retry-delay &lt;seconds&gt; 传输出现问题时，设置重试间隔时间--retry-max-time &lt;seconds&gt; 传输出现问题时，设置最大重试时间-S/--show-error 显示错误--socks4 &lt;host[:port]&gt; 用socks4代理给定主机和端口--socks5 &lt;host[:port]&gt; 用socks5代理给定主机和端口-t/--telnet-option &lt;OPT=val&gt; Telnet选项设置--trace &lt;file&gt; 对指定文件进行debug--trace-ascii &lt;file&gt; Like --跟踪但没有hex输出--trace-time 跟踪/详细输出时，添加时间戳--url &lt;URL&gt; Spet URL to work with-U/--proxy-user &lt;user[:password]&gt; 设置代理用户名和密码-V/--version 显示版本信息-X/--request &lt;command&gt; 指定什么命令-y/--speed-time 放弃限速所要的时间。默认为30-Y/--speed-limit 停止传输速度的限制，速度时间&apos;秒-z/--time-cond 传送时间设置-0/--http1.0 使用HTTP 1.0-1/--tlsv1 使用TLSv1（SSL）-2/--sslv2 使用SSLv2的（SSL）-3/--sslv3 使用的SSLv3（SSL）--3p-quote like -Q for the source URL for 3rd party transfer--3p-url 使用url，进行第三方传送--3p-user 使用用户名和密码，进行第三方传送-4/--ipv4 使用IP4-6/--ipv6 使用IP6]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习记录]]></title>
    <url>%2F20190810.html</url>
    <content type="text"><![CDATA[目标：了解Vue, 了解常用的Vue的一些工具，用vue cli搭建一个测试用例，在浏览器上面运行起来。 一点小知识Vue学习之前需要了解: Node.js：运行在服务端的 JavaScript，是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 npm、cnpm : npm是nodejs的包管理器，cnpm是淘宝 NPM 镜像，用来加速。 webpack: 基于node的一个现代 JavaScript 应用程序的静态模块打包器 ECMAScript 6: ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 html、css、JavaScript的基础 vue官网: 官方文档 看云Vue文档: 二手文档 VSCode：速度较快，对超大文件读写速度飞快(打开10M代码不到1s)，插件数量相对少，有一些增强功能比如调试器， 终端，原生支持语言语法高亮较少(C# JS TypeScript是第一位)，内置JS/TS调试器…可以基于不同项目(文件夹)设置偏好，写C#和JS/TS专用 Element-UI: 饿了么提供的UI框架。iView：一个团队 1234// 在main.js中全局引入element import ElementUI from &apos;element-ui&apos; import &apos;element-ui/lib/theme-chalk/index.css&apos; Vue.use(ElementUI) 维护靠个人的vux: 基于webpack+vue-loader+vux可以快速开发移动端页面，配合vux-loader方便你在WeUI的基础上定制需要的样式。滴滴的cube-ui vuepress: Vue 开发主题的极简静态网站生成器，另一个部分是为书写技术文档而优化的默认主题。它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 渐进式JavaScript框架vue官网的第一句话就是渐进式JavaScript框架，我的理解就是循序渐进可以自底向上逐层应用开发的框架，可以单独一个页面用来做表单，也可以整个项目用来做框架，可以一步一步引入vue，模块化需要那个就引入那个。 Vue时间轴 2013: 在Google工作的尤雨溪，受到Angular的启发，从中提取自己所喜欢的部分，开发出了一款轻量框架，最初命名为Seed。 2013.12：这粒种子发芽了，更名为Vue，版本号是0.6.0。 2014.01.24：Vue正式对外发布，版本号是0.8.0。 2014.02.25：vue版本0.9.0发布（代号Animatrix动画版的骇客帝国），此后重要的版本都会有自己的代号。 2015.06.13：vue版本0.12.0发布（代号Dragon Ball龙珠），这一年Vue大爆发，Laravel 社区（一款流行的 PHP 框架的社区）首次使用 Vue，Vue在JS社区也打响了知名度。 2015.08.18：vue里程碑-新世纪福音战士发布。vue-router（2015-08-18）、vuex（2015-11-28）、vue-cli（2015-12-27）相继发布，标志着 Vue从一个视图层库发展为一个渐进式框架。 2016.9.3：尤雨溪正式宣布加盟阿里巴巴Weex团队，尤雨溪称他将以技术顾问的身份加入 Weex 团队来做 Vue 和 Weex 的 JavaScript runtime 整合，目标是让大家能用 Vue 的语法跨三端 2016.9.30: vue版本2.0.0 （Ghost in the Shell 攻壳机动队）发布，这是第二个重要的里程碑，它吸收了React的Virtual Dom方案，还支持服务端渲染。 2018.9.30： 发布了 Vue 3.0 的开发路线，会保持与 2.x 的兼容并表示将从头开始重写 3.0 2019.2.4：vue版本2.6.0 （Macross超时空要塞）发布了。新增了Scoped slots(作用域插槽)的新语法、 动态参数指令、响应对象等新特性。 了解Vue百科定义Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，方便与第三方库或既有项目整合。 同类的技术AngularJS: 诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC（Model–view–controller）、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 React: 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 AngularJS、React、Vue.js并称前端3大框架。 同类技术优缺点 优点 缺点 Vue.js 轻量级,学习成本低 生态不太成熟 angularJS 有优秀的组件系统 学习曲线是非常陡峭 React 丰富的生态系统 学习曲线陡峭 vue对比链接：https://cn.vuejs.org/v2/guide/comparison.html#AngularJS-Angular-1 vue vs React :合严格的 Flux 架构，适合超大规模多人协作的复杂项目。理论上 Vue 配合类似架构也可以胜任这样的用例，但缺少类似 Flux 这样的官方架构。小快灵的项目上，Vue 和 React 的选择更多是开发风格的偏好。对于需要对 DOM 进行很多自定义操作的项目，Vue 的灵活性优于 React。 vue vs Angular：Angular的学习曲线是非常陡峭的——作为一个框架，它的 API 面积比起 Vue 要大得多，你也因此需要理解更多的概念才能开始有效率地工作。当然，Angular 本身的复杂度是因为它的设计目标就是只针对大型的复杂应用；但不可否认的是，这也使得它对于经验不甚丰富的开发者相当的不友好。 Vue组成方式(MVVM模式以及两个核心点) MVVM模式 Model(数据层)-View(视图层)-ViewModel(视图和数据的链接层)，ViewModel层连接Model和View。View层和Model层并没有直接联系，而是通过ViewModel层进行交互。ViewModel层通过双向数据绑定将View层和Model层连接了起来，使得View层和Model层的同步工作完全是自动的。因此开发者只需关注业务逻辑，无需手动操作DOM，复杂的数据状态维护交给MVVM统一来管理 数据驱动 所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。 组件化 所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。 代码结构 Vue的生命周期图(当遇到页面初始化的时候需要处理一下逻辑的时候，在什么时候触发函数) 。详细的生命周期解释：https://segmentfault.com/a/1190000011381906 技术揭秘https://ustbhuangyi.github.io/vue-analysis/data-driven/ 实战安装方式 在官网下载Node.js 123456789101112node -v // 查看node版本npm -v // 查看npm版本npm install cnpm -g // 全局安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org // 指定地址安装cnpmcnpm install vue // 安装最新稳定版本的vuevue --version // 查看vue版本cnpm install --global vue-cli // cnpm 全局安装vue脚手架，npm install -g @vue/cli // npm 全局安装vue脚手架vue init webpack my-project // 创建一个基于 webpack 模板的新项目cd my-project // 到达项目根目录cnpm install // 安装依赖cnpm run dev // 启动项目，或者npm run dev vue脚手架安装时的选项 1234567891011❯ vue build 构建方式,两个选择（上下箭头选择，回车即为选定） Runtime + Compiler:recommended for most users (译：运行+编译：被推荐给大多数用户) Runtime-only:about 6KB lighter min+gzip,but templates (or any Vue-specific HTML) are ONLY allowed in .vue files-render functions are required elsewhere(译：只运行大约6KB比较轻量的压缩文件，但只允许模板（或任何VUE特定HTML）。VUE文件需要在其他地方呈现函数。(意思大概是选择该构建方式对文件大小有要求, 这里推荐使用1选项，适合大多数用户的) Standard (https://github.com/standard/standard) js的标准风格 Airbnb (https://github.com/airbnb/javascript) JavaScript最合理的方法，这个github地址说是JavaScript最合理的方法 none (configure it yourself) 自己配置 Setup unit tests? 是否安装单元测试 Setup e2e tests with Nightwatch(Y/n)?是否安装E2E测试框架NightWatch（E2E，也就是End To End，就是所谓的“用户真实场景”。） yes,use npm(使用npm) yes,use yarn(使用yarn) no,I will handle that myself(自己操作) 如果报以下的错误，就安装缺少依赖(cnpm install)，全部安装完成之后就可以通过链接访问了。 访问http://localhost:8080出现vue标识表示安装成功 vue路由 123456789101112 routes: [ &#123; // 路由路径，浏览器网址输入栏的路径 path: &apos;/&apos;, // 通过name属性，为一个页面中不同的router-view渲染不同的组件,如：将上面代码的Hello渲染在 name为Hello的router-view中，将text渲染在name为text的router-view中。不设置name的将为默认的渲染组件。&lt;router-view name=&quot;test&quot;&gt;12345645645&lt;/router-view&gt; name: &apos;HelloWorld&apos;, // 导入的组件import HelloWorld from &apos;@/components/HelloWorld&apos; component: HelloWorld &#125;,]// 页面跳转方式&lt;router-link to=&quot;/test&quot;&gt;测试1&lt;/router-link&gt; 配置文件 package.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &#123; &quot;name&quot;: &quot;ffdd-fast-vue&quot;, // 项目名称 &quot;version&quot;: &quot;1.2.2&quot;, // 版本 &quot;description&quot;: &quot;...&quot;, // 描述 &quot;author&quot;: &quot;&quot;, // 作者 &quot;private&quot;: true, // 是否私有 &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, // npm run dev 执行的语句 &quot;start&quot;: &quot;npm run dev&quot;, // 项目启动 &quot;unit&quot;: &quot;jest --config test/unit/jest.conf.js --coverage&quot;, // 单元测试 &quot;e2e&quot;: &quot;node test/e2e/runner.js&quot;, // 前端到后端整个过程的测试 &quot;test&quot;: &quot;npm run unit &amp;&amp; npm run e2e&quot;, // 测试 &quot;lint&quot;: &quot;eslint --ext .js,.vue src test/unit/specs test/e2e/specs&quot;, // 修改代码样式, 运行之后就不报ESLint的错误 &quot;build&quot;: &quot;gulp&quot; // 构建 &#125;, &quot;dependencies&quot;: &#123; // 生产环境所有的第三方依赖 &quot;axios&quot;: &quot;0.17.1&quot;, // 代替ajax &quot;babel-plugin-component&quot;: &quot;0.10.1&quot;, // 按需加载插件 &quot;babel-polyfill&quot;: &quot;6.26.0&quot;, // 按需加载进行性能优化插件 &quot;element-ui&quot;: &quot;2.8.2&quot;, // 饿了么提供UI框架 &quot;gulp&quot;: &quot;3.9.1&quot;, // 自动化构建工具 &quot;gulp-concat&quot;: &quot;2.6.1&quot;, // 文件合并插件 &quot;gulp-load-plugins&quot;: &quot;1.5.0&quot;, // 自动加载插件 &quot;gulp-replace&quot;: &quot;0.6.1&quot;, // 文件替换插件 &quot;gulp-shell&quot;: &quot;0.6.5&quot;, // 命令行插件 &quot;lodash&quot;: &quot;4.17.5&quot;, // JavaScript 实用工具库。 &quot;node-sass&quot;: &quot;4.9.0&quot;, // sass编译成css &quot;npm&quot;: &quot;^6.9.0&quot;, &quot;sass-loader&quot;: &quot;6.0.6&quot;, // 是webpack的一个loader, &quot;svg-sprite-loader&quot;: &quot;3.7.3&quot;, // 实现自己的Icon组件 &quot;vue&quot;: &quot;2.5.2&quot;, &quot;vue-cookie&quot;: &quot;1.1.4&quot;, // cookie插件 &quot;vue-router&quot;: &quot;3.0.1&quot;, // vue 路由 &quot;vuex&quot;: &quot;3.0.1&quot; // vue状态管理 &#125;, &quot;devDependencies&quot;: &#123; // 开发环境所有的第三方依赖 &quot;autoprefixer&quot;: &quot;7.1.2&quot;, // 自动补全css前缀 &quot;babel-core&quot;: &quot;6.22.1&quot;, // 把 js 代码分析成 ast ,方便各个插件分析语法进行相应的处理 &quot;babel-eslint&quot;: &quot;7.1.1&quot;, // 语法检查 &quot;babel-jest&quot;: &quot;21.0.2&quot;, // 单元测试 ... &#125;, &quot;engines&quot;: &#123; // 引擎 &quot;node&quot;: &quot;&gt;= 8.11.1&quot;, &quot;npm&quot;: &quot;&gt;= 5.6.0&quot; &#125;, &quot;browserslist&quot;: [ // 浏览器列表 &quot;&gt; 1%&quot;, // 全球超过1%人使用的浏览器 &quot;last 2 versions&quot;, // 所有浏览器兼容到最后两个版本根据CanIUse.com追踪的版本 &quot;not ie &lt;= 8&quot; // 方向排除部分版本 ]&#125; config/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&apos;use strict&apos; // 模版版本号: 1.3.1 // see http://vuejs-templates.github.io/webpack for documentation. const path = require(&apos;path&apos;) module.exports = &#123; dev: &#123; // npm run dev 执行参数 // 路径 assetsSubDirectory: &apos;static&apos;, // 静态文件路径 assetsPublicPath: &apos;/&apos;, // 代理列表 proxyTable : &#123; &apos;/proxyApi&apos;: &#123; target: &apos;http://localhost:8887/&apos;, // 代理地址 changeOrigin: true, // 变化源 pathRewrite: &#123; // 路径重写 &apos;^/proxyApi&apos;: &apos;/&apos; &#125; &#125; &#125;, // 各种开发服务器设置 host: &apos;localhost&apos;, // 可以被process.env.HOST覆盖 port: 8080, // 可以被process.env.PORT覆盖，如果端口正在使用，将换一个端口 autoOpenBrowser: false, // 自动打开浏览器 errorOverlay: true, // 异常覆盖 notifyOnErrors: true, // 异常通知 poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions- // 如果为true，则在捆绑期间将对您的代码进行处理，linting错误和警告将显示在控制台中 useEslint: true, // 如果为true, 错误和警告也将显示在错误覆盖中 showEslintErrorsInOverlay: false, /** * Source Maps */ // 开发环境工具 devtool: &apos;cheap-module-eval-source-map&apos;, // 缓存破坏 // https://vue-loader.vuejs.org/en/options.html#cachebusting cacheBusting: true, cssSourceMap: true &#125;, build: &#123; // npm run build 执行参数 // index.html文件路径指定 index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 构建后路径指定、资源文件夹名、公开路径 assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, /** * 生产环境的Source Maps */ productionSourceMap: true, // https://webpack.js.org/configuration/devtool/#production devtool: &apos;#source-map&apos;, //默认情况下Gzip关闭许多流行的静态主机，例如Surge或Netlify已经为您准备了所有静态资源。 //在设置为“true”之前，请确保：npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], //运行带有额外参数的build命令 //在构建完成后查看捆绑分析器报告：`npm run build --report` bundleAnalyzerReport: process.env.npm_config_report &#125; &#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++学习]]></title>
    <url>%2F20190721.html</url>
    <content type="text"><![CDATA[函数和对象程序基本构成1234// first.cpp // 注释行#include &lt;iostream&gt; // 标准输入输出的预处理命令（将头文件iostream加入到程序中），以＃开头的都是预处理命令using namespace std; // 使用所有标识符的命名空间int main()&#123;&#125; // 是开始执行程序的入口，不管main方法在程序的那个位置，总是先执行，一个程序中，只能有一个主程序。 指针、引用、常量123456int *p = new int(10); // 动态分配了一个int类型的变量，并将它赋值给了指针pdelelte p; // 通过new分配的动态内存空间，必须通过delete运算符释放。int&amp; r = a; // 引用，就是创建一个别名，对引用的操作就是对代表的数据对象的操作。不能引用null，引用是必须立即初始化。const int * p; // *p是常量，不能进行左值操作int * const p = &amp;a; // p本身是常量，不能改变p的指向，内容可以改变const int * const p = &amp;a; // 指针p和p都不能作为左值。]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶学习]]></title>
    <url>%2F20190630.html</url>
    <content type="text"><![CDATA[网上找到的高效学习方法 GitHub链接 https://github.com/judasn/hexo-blog/blob/master/2016/02/My-Learning-Way.md MD模版 1234567891011121314151617181920# &lt;center&gt;技术名&lt;/center&gt;&gt; 官方文档## 技术来源### 解决什么问题### 以前的处理方式## 含义### 百科定义### 同类的技术### 同类技术优缺点### 组成方式## 实战### 安装方式### 配置文件 性能优化 微服务架构 高并发分布式技术 微服务架构 自动化工具 来源：https://www.jianshu.com/p/d1d5c7a7c80d?utm_campaign=haruki&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin 进阶学习]]></content>
      <categories>
        <category>进阶学习</category>
      </categories>
      <tags>
        <tag>studys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颓废的时候]]></title>
    <url>%2F20190623.html</url>
    <content type="text"><![CDATA[无所事事的度过了这么久的时间，过去的这么长的时间里。我总是在纠结、自卑、懊悔中度过的，一点也不阳光，一直特别的丧。可是回想了一下以前的自己，感觉自己一直都是这个状态，一直开心不起来。刷手机的时候总是会看到有人说不要活在过去，我们是活在现在的，现在一切美好的时光都值得自己去好好享受。可是我总是享受不来，命运如此吗？还是我没有放过我自己。 尽管我在怎么逃避，在怎么不想去面对，可终究是分手了的。从她说分手的那一刻，而不失我坚持到最后坚持不下去了才说“算了吧！我认输”的那一刻。 我是一个喜欢逃避的人，不想面对所有的事情，以为所有的事只要笑一笑就会过去的，可是这件事情我总是笑不起来，不知道中间那个环节出现了问题。 我是一个不善言辞的人，可能自己吃了卑微果实吧！还在随时给自己放技能。 每天都是口水话，同样的话，就像妈妈的唠叨一样，还没开口就知道下一句话说的是什么。一个不会变花样的人。 谈恋爱一直都是两个人的事情，一方不想继续了，另一方在纠缠下去只会让美好的事情变得不那么美好。可是道理谁都懂，我总是做不到。 生活总是要继续下去的。不知道自己什么时候才能做到坦然的面对生活。 人生总是坎坷的，得过且过。 不知道自己的爱好是什么，害怕空闲的时候，无所事事的时候，心里就是空荡荡的，不知道干什么特别的迷茫无助，不知道未来在哪里，不知道意义何在，不知道这种状态还要持续多久。这种感觉糟糕透了。 特别喜欢快速打字发出的键盘声音，弹指一挥间。 每天漫无目的地忙碌着，也不知道自己要干什么，总觉得少了点什么。没有很强的动力来源。 活在过去的人，没有未来。 不知道自己的未来在那里，已经这么久了，还是没有走出去。这几天经常迷茫，不知道自己在想些什么，经常失眠，感觉自己的人生到了一个末路的情景。生活总是这样的吗？不知道该怎么办？ 在这段感情中，我学到了什么呢？ 1、关心都是相互的，我关心你，你关心我，我对你好，你也对我好。2、很多事是勉强不了的，不管你有多舍不得。3、沮丧是没有任何意义的，只会徒增烦恼。 过去这么久了，我的脑海里面还是不能忘怀，不知道在想些什么。最近的工作压力也比较大，睡眠质量也不是很好，总会在深夜醒来，已经好久没有舒坦的睡大觉了。整个人也是特别的焦虑。希望自己能安静下来。 今年大半年已经过去了，感觉自己没有学到更多的东西，要好好的学习新东西了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx.conf标签含义]]></title>
    <url>%2F201905311.html</url>
    <content type="text"><![CDATA[nginx.conf 配置详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#nginx进程数worker_processes 8;# 0001表示启用第一个CPU内核，0010表示启用第二个CPU内核，依此类推；worker_processes最多开启8个，8个以上性能提升不会再提升了，而且稳定性变得更低，所以8个进程够用了。worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit) 与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 655350;#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emergerror_log /home/log/nginx/nginx_error.log crit; #单个进程最大连接数events &#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #单个worker进程允许客户端最大连接数，这个数值一般根据服务器性能和内存来制定，实际最大值就是worker进程数乘以work_connections实际我们填入一个65535，足够了，这些都算并发值 worker_connections 40960; #告诉nginx收到一个新连接通知后接受尽可能多的连接，默认是on，设置为on后，多个worker按串行方式来处理连接，也就是一个连接只有一个worker被唤醒，其他的处于休眠状态，设置为off后，多个worker按并行方式来处理连接，也就是一个连接会唤醒所有的worker，直到连接分配完毕，没有取得连接的继续休眠。当你的服务器连接数不多时，开启这个参数会让负载有一定的降低，但是当服务器的吞吐量很大时，为了效率，可以关闭这个参数。 multi_accept on; #最大连接数，默认为512 #worker_connections 1024;&#125;#http服务器配置http &#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型，默认为text/plain default_type application/octet-stream; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 sendfile on; #长连接超时时间，单位是秒 keepalive_timeout 65; #防止网络阻塞 tcp_nopush on; #防止网络阻塞 tcp_nodelay on; #隐藏版本号 server_tokens off; #设定服务器名称（即server_name指令所设置）哈希表的框大小，值越大能设置的server_name可以越多。参数哈希框大小总是等于哈希表的大小，即处理器高速缓存区（32）的倍数，这将加速处理器中key的搜索速度，减少内存的存取数。 server_names_hash_bucket_size 128; server_names_hash_max_size 512; #客户端请求头部的缓冲区大小 client_header_buffer_size 2k; #设置客户端请求的Header头缓冲区大小，默认为4K。客户端请求行不能超过设置的第一个数，请求的Header头信息不能大于设置的第二个数，否则会报&quot;Request URI too large&quot;(414)或“Bad request”(400)错误。如果客户端的Cookie信息较大，则需增加缓冲区大小 large_client_header_buffers 4 4k; #设置nginx允许接收的客户端请求内容的最大值，及客户端请求Header头信息中设置的Content-Lenth大最大值。如果超出该指令设置的最大值，nginx将返回“Request Entity Too Large”的错误信息(HTTP的413错误码) client_max_body_size 500m; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后***缓存。 open_file_cache max=655350 inactive=20s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 open_file_cache_min_uses 1; #这个是指多长时间检查一次缓存的有效信息。 open_file_cache_valid 30s; #设置nginx读取客户端请求Header头信息的超时时间，如果超过该指令设置的时间，nginx将返回&quot;Requet time out&quot;错误信息（HTTP的408错误码） client_header_timeout 15s; #设定nginx读取客户端请求内容的超时时间，如果超过该指令设置的时间，nginx将返回&quot;Request time out&quot;错误信息(HTTP状态码408) client_body_timeout 15s; #设置发送给客户端的应答超时时间。指两次tcp握手，还没有转为established状态的时间。如果这个时间，客户端没有响应，Nginx则关闭连接 send_timeout 60s; #开启gzip压缩功能，对用户请求的页面进行压缩处理，以达到节省网络带宽，提高网站速度的作用。 gzip on; #允许压缩的页面最小字节数。建议值为大于1024字节，小于1K的压缩可能无效果 gzip_min_length 1k; #设置系统获取几个单位的缓存用于存储gzip压缩结果数据流。此设置为：按照原始数据大小以16K为单位的4倍大小申请内存空间。如果不设置的话，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩的结果。 gzip_buffers 4 16k; #识别http协议的版本,只有1.1版本的压缩，因为可能早期的浏览器或http客户端可能不支持gzip压缩 gzip_http_version 1.0; #设置压缩比，值为1-9，压缩比最大，处理速度会越慢 gzip_comp_level 2; #指定需要被压缩的文件媒体类型 gzip_types text/plain text/javascript application/x-javascript application/json application/javascript text/css application/xml; #gzip_vary的作用是在http响应中增加一行“Vary: Accept-Encoding”，目的是改变反向代理服务器的缓存策略，反向代理服务器会根据后端服务器是否带Vary头采用不同的缓存策略。 gzip_vary on; #log日志配置 log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #用来设置日志格式 access_log /home/log/nginx/access.log access; #虚拟主机的配置 server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name test; #rewrite ^ https://$http_host$request_uri? permanent; # proxy_redirect功能比较强大,其作用是对发送给客户端的URL进行修改 proxy_redirect off; # 问产生405 503的时候给用户的返回状态是200,设置一个@405，在里边做对应的处理 error_page 405 503 =200 @405; location @405&#123; root /opt/htdocs; &#125; location / &#123; #禁止某个ip或者一个ip段访问.如果指定unix:,那将禁止socket的访问.注意：unix在1.5.1中新加入的功能，如果你的版本比这个低，请不要使用这个方法。 deny 127.0.0.1; deny 127.0.0.2; # 客户端主动断掉连接之后，Nginx 会等待后端处理完(或者超时)，然后 记录 「后端的返回信息」 到日志。所以，如果后端 返回 200， 就记录 200 ；如果后端放回 5XX ，那么就记录 5XX 。 proxy_ignore_client_abort on; # 代理转发 proxy_pass http://inspur; # 定项目的根目录，适用与server和location。可以指定多个，如果locaiton没有指定，会往其外层的server或http中寻找继承。 root html; # 在前后端分离的基础上，通过Nginx配置，指定网站初始页 index index.html index.htm; # 允许重新定义或添加字段传递给代理服务器的请求头 proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 客服端最大上传文件大小 client_max_body_size 100m; &#125; &#125; #upstream负载均衡配置，配置路由到tomcat的服务地址以及权重 upstream test&#123; #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题 ip_hash; # weight设置权重，多个服务器ip进行负载均衡分发 server 192.168.0.1:80 weight=5; server 192.168.0.2:80 weight=10; &#125;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx nginx.conf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat-service.xml标签含义]]></title>
    <url>%2F20190531.html</url>
    <content type="text"><![CDATA[service.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 属性说明port:指定一个端口，这个端口负责监听关闭Tomcat的请求shutdown:向以上端口发送的关闭服务器的命令字符串--&gt;&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; &lt;!-- Listener监听器 --&gt; &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt; &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt; &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt; &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt; &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt; &lt;!-- 全局资源 --&gt; &lt;GlobalNamingResources&gt; &lt;!-- 可编辑的用户数据库，也可供其使用 UserDatabaseRealm 用于对用户进行身份验证 --&gt; &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot; type=&quot;org.apache.catalina.UserDatabase&quot; description=&quot;User database that can be updated and saved&quot; factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot; pathname=&quot;conf/tomcat-users.xml&quot; /&gt; &lt;/GlobalNamingResources&gt; &lt;!-- Tomcat服务，name=Catalina，用于 绑定 连接器与 Engine --&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;!-- Connector 元素: 由 Connector 接口定义.&lt;Connector&gt; 元素代表与客户程序实际交互的组件,它负责接收客户请求,以及向客户返回响应结果. 属性说明: port:服务器连接器的端口号,该连接器将在指定端口侦听来自客户端的请求。 enableLookups:如果为 true，则可以通过调用 request.getRemoteHost() 进行 DNS 查询来得到远程客户端的实际主机名；若为 false 则不进行DNS查询，而是返回其ip地址。 redirectPort:服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号。 acceptCount:当所有可以使用的处理请求的线程都被用光时,可以放到处理队列中的请求数,超过这个数的请求将不予处理，而返回Connection refused错误。 connectionTimeout:等待超时的时间数（以毫秒为单位）。 maxThreads:设定在监听端口的线程的最大数目,这个值也决定了服务器可以同时响应客户请求的最大数目.默认值为200。 protocol:必须设定为AJP/1.3协议。 address:如果服务器有两个以上IP地址,该属性可以设定端口监听的IP地址,默认情况下,端口会监听服务器上所有IP地址。 minProcessors:服务器启动时创建的处理请求的线程数，每个请求由一个线程负责。 maxProcessors:最多可以创建的处理请求的线程数。 minSpareThreads:最小备用线程 。 maxSpareThreads:最大备用线程。 debug:日志等级。 disableUploadTimeout:禁用上传超时,主要用于大数据上传时。 --&gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;!-- 负责和其他 HTTP 服务器建立连接。在把 Tomcat 与其他 HTTP 服务器集成时就需要用到这个连接器。 --&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; &lt;!-- 每个Service元素只能有一个Engine元素.元素处理在同一个&lt;Service&gt;中所有&lt;Connector&gt;元素接收到的客户请求 属性说明: name:对应$CATALINA_HOME/config/Catalina 中的 Catalina ; defaultHost: 对应Host元素中的name属性,也就是和$CATALINA_HOME/config/Catalina/localhost中的localhost，缺省的处理请求的虚拟主机名，它至少与其中的一个Host元素的name属性值是一样的 debug:日志等级 --&gt; &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt; &lt;!-- Realm：领域 UserDatabaseRealm将UserDatabase的数据注入到引擎中，便于引擎访问UserDatabase --&gt; &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt; &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot; resourceName=&quot;UserDatabase&quot;/&gt; &lt;/Realm&gt; &lt;!-- 由 Host 接口定义.一个 Engine 元素可以包含多个&lt;Host&gt;元素. 每个&lt;Host&gt;的元素定义了一个虚拟主机.它包含了一个或多个Web应用. 属性说明： name:在此例中一直被强调为$CATALINA_HOME/config/Catalina/localhost中的localhost虚拟主机名 debug:是日志的调试等级 appBase:默认的应用路径,也就是把应用放在一个目录下,并在autoDeploy为true的情况下,可自动部署应用此路径相对于$CATALINA_HOME/ (web applications的基本目录) unpackWARs:设置为true,在Web应用为*.war是,解压此WAR文件. 如果为true,则tomcat会自动将WAR文件解压;否则不解压,直接从WAR文件中运行应用程序. autoDeploy:默认为true,表示如果有新的WEB应用放入appBase 并且Tomcat在运行的情况下,自动载入应用 --&gt; &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;!-- 属性说明： path:访问的URI,如:http://localhost/是我的应用的根目录,访问此应用将用:http://localhost/demm进行操作,此元素必须， 表示此web application的URL的前缀，用来匹配一个Context。请求的URL形式为http://localhost:8080/path/* docBase:WEB应用的目录,此目录必须符合Java WEB应用的规范，web application的文件存放路径或者是WAR文件存放路径。 debug:日志等级 reloadable:是否在程序有改动时重新载入,设置成true会影响性能,但可自动载入修改后的文件， 如果为true，则Tomcat将支持热部署，会自动检测web application的/WEB-INF/lib和/WEB-INF/classes目录的变化， 自动装载新的JSP和Servlet，我们可以在不重起Tomcat的情况下改变web application --&gt; &lt;Context path=&quot;/demm&quot; docBase=&quot;E:\\projects\\demm\\WebRoot&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;&gt;&lt;/Context&gt; &lt;!-- Valve：阀门也可以理解为一个过滤器，放在了host里面则服务于整个host，放在Context内则只服务于那一个Context 作用：打印请求日志，IP过滤，限流等 具体配置要基于具体的Valve 接口的子类。以下即为一个访问日志的Valve. --&gt; &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt;]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat service.xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker命令]]></title>
    <url>%2F20190528.html</url>
    <content type="text"><![CDATA[docker客服端命令123456789101112131415161718192021222324252627282930313233343536373839404142434445attach：依附到一个正在运行的容器中；build：从一个 Dockerfile 创建一个镜像；commit：从一个容器的修改中创建一个新的镜像；cp：在容器和本地宿主系统之间复制文件中；create：创建一个新容器，但并不运行它；diff：检查一个容器内文件系统的修改，包括修改和增加；events：从服务端获取实时的事件；exec：在运行的容器内执行命令；export：导出容器内容为一个 tar 包；history：显示一个镜像的历史信息；images：列出存在的镜像；import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；info：显示一些相关的系统信息；inspect：显示一个容器的具体配置信息；kill：关闭一个运行中的容器 &amp;#40;包括进程和所有相关资源&amp;#41;；load：从一个 tar 包中加载一个镜像；login：注册或登录到一个 Docker 的仓库服务器；logout：从 Docker 的仓库服务器登出；logs：获取容器的 log 信息；network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；pause：暂停一个容器中的所有进程；port：查找一个 nat 到一个私有网口的公共口；ps：列出主机上的容器；pull：从一个Docker的仓库服务器下拉一个镜像或仓库；push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；rename：重命名一个容器；restart：重启一个运行中的容器；rm：删除给定的若干个容器；rmi：删除给定的若干个镜像；run：创建一个新容器，并在其中运行给定命令；save：保存一个镜像为 tar 包文件；search：在 Docker index 中搜索一个镜像；service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；start：启动一个容器；stats：输出（一个或多个）容器的资源使用统计信息；stop：终止一个运行中的容器；swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；tag：为一个镜像打标签；top：查看一个容器中的正在运行的进程信息；unpause：将一个容器内所有的进程从暂停状态中恢复；update：更新指定的若干容器的配置信息；version：输出 Docker 的版本信息；volume：管理 Docker volume，包括查看、创建、删除等；wait：阻塞直到一个容器终止，然后输出它的退出符。 客服端命令选项123456789--config=&quot;&quot;：指定客户端配置文件，默认为 `/.docker`；-D=true|false：是否使用 debug 模式。默认不开启；-H, --host=[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://[host[:port]]），默认为 unix:///var/run/docker.sock；-l, --log-level=&quot;debug|info|warn|error|fatal&quot;：指定日志输出级别；--tls=true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；--tlscacert= /.docker/ca.pem：TLS CA 签名的可信证书文件路径；--tlscert= /.docker/cert.pem：TLS 可信证书文件路径；--tlscert= /.docker/key.pem：TLS 密钥文件路径；--tlsverify=true|false：启用 TLS 校验，默认为否。 dockerd 命令选项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950--api-cors-header=&quot;&quot;：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；--authorization-plugin=&quot;&quot;：载入认证的插件；-b=&quot;&quot;：将容器挂载到一个已存在的网桥上。指定为 &apos;none&apos; 时则禁用容器的网络，与 --bip 选项互斥；--bip=&quot;&quot;：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；--cgroup-parent=&quot;&quot;：指定 cgroup 的父组，默认 fs cgroup 驱动为 `/docker`，systemd cgroup 驱动为 `system.slice`；--cluster-store=&quot;&quot;：构成集群（如 Swarm）时，集群键值数据库服务地址；--cluster-advertise=&quot;&quot;：构成集群时，自身的被访问地址，可以为 `host:port` 或 `interface:port`；--cluster-store-opt=&quot;&quot;：构成集群时，键值数据库的配置选项；--config-file=&quot;/etc/docker/daemon.json&quot;：daemon 配置文件路径；--containerd=&quot;&quot;：containerd 文件的路径；-D, --debug=true|false：是否使用 Debug 模式。缺省为 false；--default-gateway=&quot;&quot;：容器的 IPv4 网关地址，必须在网桥的子网段内；--default-gateway-v6=&quot;&quot;：容器的 IPv6 网关地址；--default-ulimit=[]：默认的 ulimit 值；--disable-legacy-registry=true|false：是否允许访问旧版本的镜像仓库服务器；--dns=&quot;&quot;：指定容器使用的 DNS 服务器地址；--dns-opt=&quot;&quot;：DNS 选项；--dns-search=[]：DNS 搜索域；--exec-opt=[]：运行时的执行选项；--exec-root=&quot;&quot;：容器执行状态文件的根路径，默认为 `/var/run/docker`；--fixed-cidr=&quot;&quot;：限定分配 IPv4 地址范围；--fixed-cidr-v6=&quot;&quot;：限定分配 IPv6 地址范围；-G, --group=&quot;&quot;：分配给 unix 套接字的组，默认为 `docker`；-g, --graph=&quot;&quot;：Docker 运行时的根路径，默认为 `/var/lib/docker`；-H, --host=[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://[host[:port]]），默认为 unix:///var/run/docker.sock；--icc=true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。--insecure-registry=[]：允许访问给定的非安全仓库服务；--ip=&quot;&quot;：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；--ip-forward=true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；--ip-masq=true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；--iptables=true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；--ipv6=true|false：是否启用 IPv6 支持，默认关闭；-l, --log-level=&quot;debug|info|warn|error|fatal&quot;：指定日志输出级别；--label=&quot;[]&quot;：添加指定的键值对标注；--log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;：指定日志后端驱动，默认为 json-file；--log-opt=[]：日志后端的选项；--mtu=VALUE：指定容器网络的 mtu；-p=&quot;&quot;：指定 daemon 的 PID 文件路径。缺省为 `/var/run/docker.pid`；--raw-logs：输出原始，未加色彩的日志信息；--registry-mirror=&lt;scheme&gt;://&lt;host&gt;：指定 `docker pull` 时使用的注册服务器镜像地址；-s, --storage-driver=&quot;&quot;：指定使用给定的存储后端；--selinux-enabled=true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；--storage-opt=[]：驱动后端选项；--tls=true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；--tlscacert= /.docker/ca.pem：TLS CA 签名的可信证书文件路径；--tlscert= /.docker/cert.pem：TLS 可信证书文件路径；--tlscert= /.docker/key.pem：TLS 密钥文件路径；--tlsverify=true|false：启用 TLS 校验，默认为否；--userland-proxy=true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；--userns-remap=default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。 Dockerfile命令1docker build -t java:image . // 构建脚本 脚本12345678910111213FROM // 镜像来源COPY hom* /mydir/ // 复制hom开头的文件到mydir文件夹下面ADD file.gz /mydir // 增强复制功能，自动解压缩CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] // 分为shell命令和执行命令，容器启动命令，启动nginxENTRYPOINT // 入口点ENV // 设置环境变量ARG // 构建参数,设置的构建环境的环境变量VOLUME // 挂载匿名卷，用于数据持久化EXPOSE // 暴露端口WORKDIR // 指定工作目录USER // 指定当前用户HEALTHCHECK // 健康检查ONBUILD // 以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行 docker-compose命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152build //构建（重新构建）项目中的服务容器 --force-rm //删除构建过程中的临时容器 --no-cache //构建镜像过程中不使用 cache（这将加长构建过程）。 --pull //始终尝试通过 pull 来获取更新版本的镜像。config //验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因down //停止 up 命令所启动的容器，并移除网络exec //进入指定的容器help // 帮助images // 列出 Compose 文件中包含的镜像kill //格式为 docker-compose kill [options] [SERVICE...]。通过发送 SIGKILL 信号来强制停止服务容器。支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。logs // 查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色pause // 暂停一个服务容器。port // 打印某个容器端口所映射的公共端口。 --protocol=proto //指定端口协议，tcp（默认值）或者 udp。 --index=index //如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。ps //列出项目中目前的所有容器 -q 只打印容器的 ID 信息pull //拉取服务依赖的镜像 --ignore-pull-failures //忽略拉取镜像过程中的错误。push // 推送服务依赖的镜像到 Docker 镜像仓库restart // 重启项目中的服务 -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒） rm // 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。 -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。 -v 删除容器所挂载的数据卷。 run // 在指定服务上执行一个命令。docker-compose run ubuntu ping docker.com， 将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令 -d 后台运行容器。 --name NAME //为容器指定一个名字。 --entrypoint CMD //覆盖默认的容器启动指令。 -e KEY=VAL //设置环境变量值，可多次使用选项来设置多个环境变量。 -u, --user=&quot;&quot; //指定运行容器的用户名或者 uid。 --no-deps //不自动启动关联的服务容器。 --rm //运行命令后自动删除容器，d 模式下将忽略。 -p, --publish=[] //映射容器端口到本地主机。 --service-ports //配置服务端口并映射到本地主机。 -T //不分配伪 tty，意味着依赖 tty 的指令将无法运行。scale //设置指定服务运行的容器个数 docker-compose scale web=3 db=2 将启动 3 个容器运行 web 服务，2 个容器运行 db 服务 -t, --timeout TIMEOUT // 停止容器时候的超时（默认为 10 秒）start // 启动已经存在的服务容器up // 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。 -d //在后台运行服务容器。 --no-color //不使用颜色来区分不同的服务的控制台输出。 --no-deps //不启动服务所链接的容器。 --force-recreate //强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate //如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build //不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT //停止容器时候的超时（默认为 10 秒）。version // 打印版本信息。 stop // 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器unpause // 恢复处于暂停状态中的服务。top // 查看各个服务容器内运行的进程。 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100build // 指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像 context: dir //指定 Dockerfile 所在文件夹的路径 dockerfile: name // 指定 Dockerfile 文件名 arg: // 指令指定构建镜像时的变量 buildno: 1 // 变量buildno为1 cache_from：//指定构建镜像的缓存cap_add: // 指定容器的内核能力（capacity）分配 - ALL // 让容器拥有所有能力可以指定为cap_drop: // 去掉能力 - NET_ADMIN // 去掉NET_ADMIN command: echo &quot;hello world&quot; //覆盖容器启动后默认执行的命令 configs // 仅用于 Swarm modecgroup_parent // 指定父 cgroup 组，意味着将继承该组的资源限制.创建了一个 cgroup 组名称为 cgroups_1container_name: docker-web-container // 指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。deploy // 仅用于 Swarm modedevices: // 指定设备映射关系。 - &quot;/dev/ttyUSB1:/dev/ttyUSB0&quot; // 例子depends_on: // 解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web - db // 先启动 redis - redis // 在启动 db，最后启动webdns: // 自定义 DNS 服务器。可以是一个值，也可以是一个列表 - 8.8.8.8 - 8.8.8.8 dns_search: // 配置 DNS 搜索域。可以是一个值，也可以是一个列表。 - domain1.example.com - domain2.example.comtmpfs: //挂载一个 tmpfs 文件系统到容器 - /run env_file: // 从文件中获取环境变量，可以为单独的文件路径或列表。如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。 - ./common.envenvironment: // 设置环境变量。可以使用数组或字典两种格式。 RACK_ENV: development // 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据 SESSION_SECRET: expose: // 暴露端口，但不映射到宿主机，只被连接的服务访问。 - &quot;3000&quot;external_links: // 不建议使用该指令.链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器 extra_hosts: //类似 Docker 中的 --add-host 参数，指定额外的 host 名称映射信息 - &quot;googledns:8.8.8.8&quot; // 在/etc/hosts增加googledns:8.8.8.8文本healthcheck: // 通过命令检查容器是否健康运行。 test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] interval: 1m30s timeout: 10s retries: 3image: ubuntu // 指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像labels: // 为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。 com.startupteam.description: &quot;webapp for a startup team&quot; com.startupteam.department: &quot;devops department&quot; com.startupteam.release: &quot;rc3 for v1.0&quot;logging: // 配置日志选项 driver: syslog // 目前支持三种日志驱动类型&quot;json-file&quot;, &quot;syslog&quot;, &quot;none&quot; options: syslog-address: &quot;tcp://192.168.0.42:123&quot; max-size: &quot;200k&quot; max-file: &quot;10&quot; network_mode: &quot;bridge&quot; // 设置网络模式。使用和 docker run 的 --network 参数一样的值network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name/id]&quot; ports: // 暴露端口信息。使用宿主端口：容器端口 &amp;#40;HOST:CONTAINER&amp;#41; 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 - &quot;3000&quot; // 当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。 - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; secrets: // 存储敏感数据，例如 mysql 服务密码 my_secret: file: ./my_secret.txt my_other_secret: external: truesecurity_opt: // 指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。 - label:user:USER - label:role:ROLE stop_signal: SIGUSR1 // 设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。sysctls: //配置容器内核参数 net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0ulimits: // 指定容器的 ulimits 限制值。 nproc: 65535 //指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。 nofile: soft: 20000 hard: 40000 volumes: // 数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro entrypoint: /code/entrypoint.sh // 指定服务容器启动后执行的入口文件user: nginx // 指定容器中运行应用的用户名。working_dir: /code // 指定容器中工作目录。domainname: your_website.com // 指定容器中搜索域名hostname: test // 指定容器中主机名mac_address: 08-00-27-00-0C-0A // 指定容器中mac 地址privileged: true // 允许容器中运行一些特权命令。restart: always // 指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。read_only: true // 以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。stdin_open: true // 打开标准输入，可以接受外部输入。tty: true // 模拟一个伪终端。$&amp;#123;MONGO_VERSION&amp;#125; // Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 MONGO_VERSION=3.6]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Dockerfile docker-compose docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-cloud-zipkin]]></title>
    <url>%2F201905254.html</url>
    <content type="text"><![CDATA[zipkin项目服务端 pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;demo-spring-cloud&lt;/groupId&gt; &lt;artifactId&gt;demo-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../cloud-dependences/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;demo-spring-cloud-zipkin&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo-spring-cloud-zipkin&lt;/name&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;version&gt;2.12.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;version&gt;2.12.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.demo.spring.zipkin.ZipKinApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 需要在dependences的properties里面添加&lt;zipkin.version&gt;2.10.1&lt;/zipkin.version&gt;用于管理版本 application.yml 1234567891011121314151617spring: application: name: hello-spring-cloud-zipkinserver: port: 9411eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/management: metrics: web: server: auto-time-requests: false 访问http://localhost:9411即可。 客服端增加pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; 增加application.yml123spring: zipkin: base-url: http://localhost:9411 admin项目 链路追踪ui管理页面]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-cloud-eurekra]]></title>
    <url>%2F201905253.html</url>
    <content type="text"><![CDATA[创建项目 创建存放项目的文件夹，src/main/java、 src/main/rescoures、pom.xml等 注解 12@SpringBootApplication@EnableEurekaServer pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;demo-spring-cloud&lt;/groupId&gt; &lt;artifactId&gt;demo-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../cloud-dependences/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;demo-spring-cloud-eureka&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo-spring-cloud-eureka&lt;/name&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--jar运行时指定的入口类--&gt; &lt;mainClass&gt;com.demo.spring.eurekra.EurekraApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-cloud-config]]></title>
    <url>%2F201905252.html</url>
    <content type="text"><![CDATA[配置中心服务端创建项目 创建存放项目的文件夹，src/main/java、 src/main/rescoures、pom.xml等 main方法添加注解 123@SpringBootApplication@EnableConfigServer@EnableEurekaClient 如果启动时报错： Could not find or load main class 。则需要mvn compile一下就好了。 启动成功后访问：http://localhost:8888/ 出现spring页面。 123456// 访问方式http://ip:port/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]http://ip:port/&#123;application&#125;-&#123;profile&#125;.ymlhttp://ip:port/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.ymlhttp://ip:port/&#123;application&#125;-&#123;profile&#125;.propertieshttp://ip:port/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; // 对应dependences项目的groupId &lt;groupId&gt;com.demo.config&lt;/groupId&gt; // 对应dependences项目的artifactId &lt;artifactId&gt;demo-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../cloud-dependences/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;demo-spring-cloud-config&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo-spring-cloud-config&lt;/name&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.funtl.hello.spring.cloud.config.ConfigApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置中心客户端pom.xml12345&lt;!--从配置中心读取配置--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; application.yml1234567spring: cloud: config: uri: http://localhost:8888 name: cloud-zipkin label: master profile: dev]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-cloud-dependences]]></title>
    <url>%2F201905251.html</url>
    <content type="text"><![CDATA[项目搭建 直接创建一个目录，maven直接增加项目管理。等待下载依赖即可 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--继承了Spring Boot的Paren， 表示是一个 Spring Boot 工程 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;cloud-dependences&lt;/groupId&gt; &lt;artifactId&gt;demo-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!--仅仅是作为依赖，没有代码实现--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;demo-spring-cloud-dependencies&lt;/name&gt; &lt;url&gt;https://gaoqisen.github.io&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;properties&gt; &lt;!-- Environment Settings --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!--在 properties 配置中预定义了版本号为 Finchley.RC1 ，表示我们的 Spring Cloud 使用的是 F 版 --&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Compiler 插件, 设定 JDK 版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 打包 jar 文件时，配置 manifest 文件，加入 lib 包的 jar 依赖 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- Add directory entries --&gt; &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt; &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- resource --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- install --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- clean --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- ant --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- dependency --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- Java Document Generate --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- YUI Compressor (CSS/JS压缩) --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;yuicompressor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compress&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;jswarn&gt;false&lt;/jswarn&gt; &lt;nosuffix&gt;true&lt;/nosuffix&gt; &lt;linebreakpos&gt;30000&lt;/linebreakpos&gt; &lt;force&gt;true&lt;/force&gt; &lt;includes&gt; &lt;include&gt;**/*.js&lt;/include&gt; &lt;include&gt;**/*.css&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.min.js&lt;/exclude&gt; &lt;exclude&gt;**/*.min.css&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 资源文件配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;!--配置项目下载依赖时的常用第三方库--&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos-s&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用命令]]></title>
    <url>%2F20190525.html</url>
    <content type="text"><![CDATA[常用1234lsof -i:8886 // 查看端口号opne . // 打开终端下的目录touch aaa // 在当前目录下创建一个aaa名字的文件diskutil list // 查看磁盘分区表 git1234// 清除git信息sudo git config --system --unset credential.helper// 重新生成git的id_rsa.pub, 之后一直enter，设置密码即可ssh-keygen -t rsa -b 4096 -C &apos;yourmail@qq.com&apos; iterm21234567891011121314151617181920212223command + t //新建标签command + w //关闭标签command + 数字 / command + 左右方向键 //切换标签command + enter //切换全屏command + f //查找command + d //垂直分屏command + shift + d //水平分屏command + ; //查看历史命令command + shift + h //查看剪贴板历史ctrl + u //清除当前行ctrl + l / command + r //清屏ctrl + a //到行首ctrl + e //到行尾ctrl + f/b //前进后退 (相当于左右方向键)ctrl + p //上一条命令ctrl + r //搜索命令历史ctrl + d //删除当前光标的字符ctrl + h //删除光标之前的字符ctrl + w //删除光标之前的单词ctrl + k //删除到文本末尾ctrl + t //交换光标处文本Command + / //查看当前终端中光标的位置command+f + tab // 选中即复制 tree12345678910111213141516171819202122-a 显示所有文件和目录。-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。-C 在文件和目录清单加上色彩，便于区分各种类型。-d 显示目录名称而非内容。-D 列出文件或目录的更改时间。-f 在每个文件或目录之前，显示完整的相对路径名称。-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;,&quot;/&quot;,&quot;=&quot;,&quot;@&quot;,&quot;|&quot;号。-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。-i 不以阶梯状列出文件或目录名称。-I 不显示符合范本样式的文件或目录名称。-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。-n 不在文件和目录清单加上色彩。-N 直接列出文件和目录名称，包括控制字符。-p 列出权限标示。-P 只显示符合范本样式的文件或目录名称。-q 用&quot;?&quot;号取代控制字符，列出文件和目录名称。-s 列出文件或目录大小。-t 用文件和目录的更改时间排序。-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。tree -L 1 // 显示一层目录结构]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[私有仓库创建]]></title>
    <url>%2F20190516.html</url>
    <content type="text"><![CDATA[Gitlab私有代码存储仓库创建123456789101112131415161718192021version: &apos;3&apos;services: web: image: &apos;twang2218/gitlab-ce-zh:10.5&apos; restart: always hostname: &apos;192.168.75.145&apos; environment: TZ: &apos;Asia/Shanghai&apos; GITLAB_OMNIBUS_CONFIG: | external_url &apos;http://192.168.75.145:8080&apos; gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 2222 unicorn[&apos;port&apos;] = 8888 nginx[&apos;listen_port&apos;] = 8080 ports: - &apos;8080:8080&apos; - &apos;8443:443&apos; - &apos;2222:22&apos; volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/gitlab/logs:/var/log/gitlab 访问1http://ip:8080 Maven私有仓库创建12345678910version: &apos;3.1&apos;services: nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 8081:8081 volumes: - /usr/local/docker/nexus/data:/nexus-data 访问1http://ip:port/ 用户名：admin 密码：admin123 Docker私有镜像仓库创建1234567891011121314151617181920212223version: &apos;3.1&apos;services: registry: image: registry restart: always container_name: registry ports: - 5000:5000 volumes: - /usr/local/docker/registry/data:/var/lib/registry# Registry WebUI 工具 version: &apos;3.1&apos;services: frontend: image: konradkleine/docker-registry-frontend:v2 ports: - 8080:80 volumes: - ./certs/frontend.crt:/etc/apache2/server.crt:ro - ./certs/frontend.key:/etc/apache2/server.key:ro environment: - ENV_DOCKER_REGISTRY_HOST=192.168.75.133 - ENV_DOCKER_REGISTRY_PORT=5000 访问12345678910// 访问http://ip:5000/v2/，http://ip:5000// 在/etc/docker/daemon.json中新增&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ], &quot;insecure-registries&quot;: [ &quot;ip:5000&quot; ]&#125; 访问 重启12sudo systemctl daemon-reloadsudo systemctl restart docker]]></content>
      <categories>
        <category>utils docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F20190427.html</url>
    <content type="text"><![CDATA[12345678910111213du -h // 查看当前文件夹的占用大小df -h // 查看当前文件下所有的文件的大小free -h // 查看磁盘使用情况 swap(交换空间：防止服务器出现内存溢出时无法操作系统。云服务器没有交换空间)netstat -al // 显示网络状态信息ps -A // 显示所有的进程ps -ef|grep tomcat // 查看tomcat的端口passwd // 重置密码reboot // 重启（root用户才有权限）sudo // 临时获取root权限tar -czvf file.tar.gz . // 压缩当前文件夹tar -xzvf file.tar.gz // 解压缩文件apt-get // ubuntu软件包管理 在/etc/apt/source.list可以更改数据源 apt-get update让数据源生效lsb_release -a // 查看系统版本 常用工具1htop 查看内存工具 系统信息123456789101112131415161718192021arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS yum install gcc gcc-c++ 安装gcc和g++（centos下） 关机 (系统的关机、重启以及登出 )12345678shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 文件和目录123456789101112131415161718192021222324252627282930313233cd /home 进入 &apos;/ home&apos; 目录&apos; cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. find . -maxdepth 1 -name *.jpg -print -exec convert &quot;&#123;&#125;&quot; -resize 80x60 &quot;thumbs/&#123;&#125;&quot; \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索12345678910find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 find /home/user1 -name \*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name \*.rpm -exec chmod 755 &apos;&#123;&#125;&apos; \; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限 find / -xdev -name \*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备 locate \*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统123456789101112mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 &apos;/ mnt/hda2&apos; 已经存在 umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 &apos;/ mnt/hda2&apos; 退出 fuser -km /mnt/hda2 当设备繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间123456df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 &apos;dir1&apos; 已经使用的磁盘空间&apos; du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a --qf &apos;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&apos; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f=&apos;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&apos; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组12345678910111213groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( &apos;-r&apos; 排除主目录) usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的用户 grpck 检查 &apos;/etc/passwd&apos; 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限12345678910111213141516 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消 ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性123456789- 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消 chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩/解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 打包和压缩文件1234567891011121314151617181920212223压缩当前的文件夹 zip -r ./xahot.zip ./* -r表示递归bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 gzip file1 压缩一个叫做 &apos;file1&apos;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -xvf archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 rpm12345678910111213141516171819202122232425262728RPM 包 - （Fedora, Redhat及类似系统） rpm -ivh package.rpm 安装一个rpm包 rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name --whatprovides 显示一个rpm包所占的体积 rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l rpm -q package_name --changelog 显示一个rpm包的修改历史 rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 rpm --checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件 rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM123456789101112YUM 软件包升级器 - （Fedora, RedHat及类似系统） yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 dpkg12345678910DEB 包 (Debian, Ubuntu 以及类似系统) dpkg -i package.deb 安装/更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 apt-get12345678910APT 软件工具 (Debian, Ubuntu 以及类似系统) apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容1234567cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 &apos;more&apos; 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理12345678910111213141516171819202122232425262728293031cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 sed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行 echo &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容 sed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行 sed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行 sed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符 sed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 sed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容 sed -n &apos;5p;5q&apos; example.txt 查看第5行 sed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行 echo a b c | awk &apos;&#123;print $1&#125;&apos; 查看一行第一栏 echo a b c | awk &apos;&#123;print $1,$3&#125;&apos; 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换1234dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 文件系统分析123456789badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统123456mkfs /dev/hda1 在hda1分区创建一个文件系统 mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统123mkswap /dev/hda3 创建一个swap文件系统 swapon /dev/hda3 启用一个新的swap文件系统 swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份1234567891011121314151617dump -0aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的完整备份 dump -1aj -f /tmp/home0.bak /home 制作一个 &apos;/home&apos; 目录的交互式备份 restore -if /tmp/home0.bak 还原一个交互式备份 rsync -rogpav --delete /home /tmp 同步两边的目录 rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &apos;dd of=hda.gz&apos; 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 tar -Puf backup.tar /home/user 执行一次对 &apos;/home/user&apos; 目录的交互式备份操作 ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr &apos;cd /home/share/ &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个目录内容 ( tar c /home ) | ssh -C user@ip_addr &apos;cd /home/backup-home &amp;&amp; tar x -p&apos; 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find /home/user1 -name &apos;*.txt&apos; | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 &apos;.txt&apos; 结尾的文件到另一个目录 find /var/log -name &apos;*.log&apos; | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 &apos;.log&apos; 结尾的文件并做成一个bzip包 dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘123456789101112 cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord --scanbus 扫描总线以识别scsi通道 dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络123456789101112131415161718192021222324252627- （以太网和WIFI无线） ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 &apos;eth0&apos; 网络设备 ifdown eth0 禁用一个 &apos;eth0&apos; 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 &apos;eth0&apos; 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 &apos;eth0&apos; route -n show routing table route add -net 0/0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network &apos;192.168.0.0/16&apos; route del 0/0 gw IP_gateway remove static route echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of &apos;eth0&apos; ethtool eth0 show statistics of network card &apos;eth0&apos; netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database Microsoft Windows networks (SAMBA)12345nbtscan ip_addr netbios name resolution nmblookup -A ip_addr netbios name resolution smbclient -L ip_addr/hostname show remote shares of a windows host smbget -Rr smb://ip_addr/share like wget can download files from a host windows via smb mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share 命令详细解释ls1234567891011121314151617181920212223242526 ls (list 显示当前目录下文件和目录 ls -l 详细显示 ll ) ls [-aAdfFhilRS] 目录名称 ls [--color=&#123;none,auto,always&#125;] 目录名称 ls [--full-time] 目录名称 参数： -a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ -A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ -d ：仅列出目录本身，而不是列出目录内的档案数据 -f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) -F ：根据档案、目录等信息，给予附加数据结构，例如： *：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； -h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； -i ：列出 inode 位置，而非列出档案属性； -l ：长数据串行出，包含档案的属性等等数据； -n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) -r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； -R ：连同子目录内容一起列出来； -S ：以档案容量大小排序！ -t ：依时间排序 --color=never ：不要依据档案特性给予颜色显示； --color=always ：显示颜色 --color=auto ：让系统自行依据设定来判断是否给予颜色 --full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 --time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) 而非内容变更时间 (modification time) cat/tac1234567891011121314151617181920212223cat 由第一行开始显示档案内容 cat [-AEnTv] 参数： -A ：相当于 -vET 的整合参数，可列出一些特殊字符～ -E ：将结尾的断行字符 $ 显示出来； -n ：打印出行号； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！nl 显示的时候，顺道输出行号！ nl [-bnw] 档案 参数： -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号； -b t ：如果有空行，空的那一行不要列出行号； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在屏幕的最左方显示； -n rn ：行号在自己字段的最右方显示，且不加 0 ； -n rz ：行号在自己字段的最右方显示，且加 0 ； -w ：行号字段的占用的位数。 more/head12345678910111213141516171819202122more 一页一页的显示档案内容 空格键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字符串 ：代表在这个显示的内容当中，向下搜寻『字符串』； :f ：立刻显示出文件名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该档案内容。 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！空格键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字符串 ：向下搜寻『字符串』的功能； ?字符串 ：向上搜寻『字符串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； head 只看头几行 head [-n number] 档案 参数： -n ：后面接数字，代表显示几行的意思 tail12345678910111213tail 只看尾巴几行 tail -200f logfile2 ( 显示日志最后 200 行 )od 以二进制的方式读取档案内容！ od [-t TYPE] 档案 参数： -t ：后面可以接各种『类型 (TYPE)』的输出，例如： a ：利用预设的字符来输出； c ：使用 ASCII 字符来输出 d[size] ：利用十进制(decimal)来输出数据，每个整数占用 size bytes ； f[size] ：利用浮点数值(floating)来输出数据，每个数占用 size bytes ； o[size] ：利用八进位(octal)来输出数据，每个整数占用 size bytes ； x[size] ：利用十六进制(hexadecimal)来输出数据，每个整数占用 size bytes ； chmod/chown/chgrp1234567chmod ( chmod +R filename增加文件读写执行权限,+R 可读,+W 可写,+X 可执行 ( chmod 777 filename 增加文件读写执行权限的另一种方式, 7=&gt; 对应8进制的 111 可读可写可执行) chown ( chown -R haowen .将当前目录下所有文件和目录权限赋给 haowen ,-R 包括子目录)chgrp -R mysql . (把当前文件夹变更到mysql群组,mysql是已经有的群组)变更文件或目录的所属群组。 find12find ./ -name index.jsp 查找当前目录下名称为index.jsp的文件find ( find ./ -name file1 -print ,从当前目录向下查找名为 file1 的文件) mkdir12345678910mkdir ( mkdir dir1 ,新建目录 dir1 ) mkdir [-mp] 目录名称 参数： -m ：设定档案的权限喔！直接设定，不需要看预设权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录递归建立起来！ rmdir [-p] 目录名称 参数： -p ：连同上层『空的』目录也一起删除 pwd12pwd Print Working Directory ( pwd ,显示当前路径 ) pwd -P 显示出确实的路径,而非使用连接(link)路径 cd12cd ( cd /usr/local/ 进入目录 /usr/local/ , cd ../ 返回到上一级目录 ./ 当前目录 ../父目录 - 代表前一个工作目录 ~代表[目前使用者身份]所在的家目录 ~account代表account这个使用者的家目录)针对 cd 的使用方法，如果仅输入 cd 时，代表的就是『 cd ~ 』 mv12345678910 mv ( mv file1 /home/haowen/ ,将文件移动到目录 /home/haowen/下 ,相当于 window 剪切 ) ( mv file1 filenew1 ,将文件名改为 filenew1 ) mv [-fiu] source destination mv [options] source1 source2 source3 .... directory 参数： -f ：force 强制的意思，强制直接移动而不询问； -i ：若目标档案 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标档案已经存在，且 source 比较新，才会更新 (update) cp12345678910111213141516 cp ( cp file1 /home/haowen/ ,将文件复制copy到目录 /home/haowen/下 cp -r dir1 /home/haowen/ cp file1 ./file2 复制文件并改名) cp [-adfilprsu] 来源档(source) 目的檔(destination) cp [options] source1 source2 source3 .... directory 参数： -a ：相当于 -pdr 的意思； -d ：若来源文件为连结文件的属性(link file)，则复制连结文件属性而非档案本身； -f ：为强制 (force) 的意思，若有重复或其它疑问时，不会询问使用者，而强制复制； -i ：若目的檔(destination)已经存在时，在覆盖时会先询问是否真的动作！ -l ：进行硬式连结 (hard link) 的连结档建立，而非复制档案本身； -p ：连同档案的属性一起复制过去，而非使用预设属性； -r ：递归持续复制，用于目录的复制行为； -s ：复制成为符号连结文件 (symbolic link)，亦即『快捷方式』档案； -u ：若 destination 比 source 旧才更新 destination ！ rm12345678 rm ( rm file1 ,rm -r dir1,rm -rf dir2 删除文件或目录, f不提示输入y rm [-fir] 档案或目录 参数： -f ：就是 force 的意思，强制移除； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了 touch12345678910touch 建立一个空的档案,将某个档案日期修订为目前 (mtime 与 atime) touch [-acdmt] 档案 参数： -a ：仅修订 access time； -c ：仅修改时间，而不建立档案；-d ：后面可以接日期，也可以使用 --date=&quot;日期或时间&quot; -m ：仅修改 mtime ； -t ：后面可以接时间，格式为[YYMMDDhhmm] file12 file 如果你想要知道某个档案的基本数据，例如是属于 ASCII 或者是 data 档案，或者是 binary ， 且其中有没有使用到动态函式库 (share library) 等等的信息，就可以利用 file 这个指令来检阅喔！ which123456which (寻找『执行档』) 这个指令是根据『PATH』这个环境变量所规范的路径，去搜寻『执行档』的档名 which [-a] command 参数： -a ：将所有可以找到的指令均列出，而不止第一个被找到的指令名称 whereis1234567891011121314151617181920whereis (从数据库寻找特定档案) whereis [-bmsu] 档案或目录名 参数： -b :只找 binary 的档案 -m :只找在说明文件 manual 路径下的档案 -s :只找 source 来源档案 -u :没有说明档的档案！ 功能说明：计算字数。语 法：wc [-clw][--help][--version][文件名]补充说明：利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定任何文件名称，或是所给予的文件名为&quot;-&quot;，则wc指令会从标准输入设备读取数据。假设不给予其参数，wc指令会一并显示列数、字数和Byte数参 数：-c 只显示Byte数，亦即字符数；-l 只显示列数；-w 只显示字数；-m 同样显示字符数--help 在线帮助；--version 显示此软件的版本信息。 locate12locate 从数据库列出某个档案的完整档名 grep123grep ( grep &quot;mobile=13712345678&quot; logfile1 ,在logfile1中 搜索查找内容 &quot;mobile=13712345678&quot; ) ping／ifconfig12ping ( ping 61.129.78.9 ,ping www.163.com ,测试网络连接是否正常 )ifconfig ( ifconfig ,查看本机 IP地址，子网掩码等 ) ps／kill1234ps ( ps aux 查看系统中已经启动的进程, ps aux | grep programe1 , 查看程序1是否正在运行kill ( kill -9 2325 ,杀死进程号为 2325的进程, killall programe1 ,杀死programe1进程 ) init／reboot1234reboot ( 重启系统 )init 0 ( 关机 ,仅 root 用户有权操作 )init 6 ( 重启系统 ,仅 root 用户有权操作 ) gzip／gunzip／tar123456gzip ( gzip file1 ,压缩文件 file1 )gunzip ( gunzip file1.gz 解压缩文件 file1.gz )tar -zcvf ( tar -zcvf dir1.tar.gz ./dir1 ,将当前目录下 dir1目录所有内容 压缩打包,包名dir1.tar.gz )tar -zxvf ( tar -zxvf dir1.tar.gz ,解开压缩包 ) echo／vi123456789101112131415 echo &quot;hello!&quot; &gt;&gt; file1 ( 将 &quot;hello&quot; 添加到文件 file1后面, 当 file1 不存在就创建 file1 vi file2 ( vi 编即器新建文件 file2) ...输入内容 welcome.. ( 按 i 进入 insert 状态 即插入模式 ,按 Esc 退出插入模式 在非插入模式下按 dd 删除光标当前行,按 x 删除当前字, 按 j,n,l移动光标 ) :wq ( 保存退出 ) :q! (不保存退出) 增加环境变量 echo $PATH PATH=&quot;$PATH&quot;:/root env／set12env 显示系统的一些环境变量 set 显示系统的所有变量 chmod12345678910111213141516171819chmod:Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，1. 将档案 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt 或 chmod 444 file1.txt2. 将文件 file2 设为属主可读写执行,Group,other ,只能读 chmod 744 file2 ( 7=&gt; &quot;111&quot; ,4=&gt;&quot;100&quot; 二进制 ) 3. 将文件 file3 设为属主可读写执行,Group,other ,无权限操作不能读写执行) chmod 700 file3 ( 7=&gt; &quot;111&quot; ,0=&gt;&quot;000&quot; ) 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1 若要rwx属性则4+2+1=7； 若要rw-属性则4+2=6； 若要r-x属性则4+1=5 tar12345678910tar:tar 调用gzip gzip是GNU组织开发的一个压缩程序，.gz结尾的文件就是gzip压缩的结果。 与gzip相对的解压程序是gunzip。tar中使用-z这个参数来调用gzip。 # tar -czf all.tar.gz *.jpg 这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个 gzip压缩过的包，包名为all.tar.gz # tar -xzf all.tar.gz 这条命令是将上面产生的包解开。 date／cal／bc123456 date 显示日期的指令： cal 显示日历的指令： bc 简单好用的计算器： info／who／finger／man12345678info 在线求助 : who 要看目前有谁在在线: finger 显示关于系统用户的信息man 命令:查看该命令的基础用法 netstat／ntsysv／shutdown12345netstat -a 看网络的联机状态: ntsysv 设置服务随系统启动时同时启动 shutdown ,shutdown -h now 惯用的关机指令： dmesg／df／du／free／top／hostname123456789dmesg : 例如 dmesg | more 显示系统的诊断信息,操作系统版本号,物理内及其它信息df : 例如 df -h 显示硬盘空间du : 查看目录中各级子目录使用的硬盘空间free: 查看系统内存,虚拟内存(交换空间)的大小占用情况top: 动态实时查看系统内存,CPU,进程hostname 查看主机名:hostname 新主机名 修改主机名(临时的,重启就没了): type12345678910111213141516type 查询某个指令是来自于外部指令(指的是其它非 bash 套件所提供的指令) 或是内建在 bash 当中的指令 type [-tpa] name 参数： ：不加任何参数时，则 type 会显示出那个 name 是外部指令还是 bash 内建的指令！ -t ：当加入 -t 参数时，type 会将 name 以底下这些字眼显示出他的意义： file ：表示为外部指令； alias ：表示该指令为命令别名所设定的名称； builtin ：表示该指令为 bash 内建的指令功能； -p ：如果后面接的 name 为指令时，会显示完整文件名(外部指令)或显示为内建指令； -a ：会将由 PATH 变量定义的路径中，将所有含有 name 的指令都列出来，包含 alias myname=pqb 变量的设定PATH=&quot;$PATH&quot;:/home/dmtsai/bin 变量的累加echo $myname 变量的查看unset myname 变量的取消 Shutdown123456789101112131415关闭系统使用Shutdown命令，确保用户和系统的资料完整。只有root用户才能使用这个命令。一般的用户是不允许执行这个命令的。我们先看看showdown语法：shutdown [options] when [message]options: -r 表示重启，-h表示系统服务停滞(halt)后，立刻关机，-f表示快速重启when： 为shutdown指定时间。hh:mm：绝对时间，hh指小时，mm指分钟；如08:30，+m:m分钟后执行，now=+0，也就是立刻执行message：表示系统的广播信息，一般提示各个用户系统关机或重启，要求用户保存资料后退出。我们来看看几个例子：shutdown -h now 立刻关机shutdown -h 21:30 今天21：30关机shutdown -h +10 十分钟后关机shutdown -r now 立刻重启shutdown -r +10 ‘the system will reboot’ 10分钟后重启，管理员提示用户系统要重启了，便于用户保存工作中的资料。只有root用户才能使用这个命令。 fdisk／mount／eject12345678910111213141516171819fdisk -l命令使用“vfat”文件系统类型表示所有的fat文件系统类型，包括fat16和fat32，ntfs还是使用ntfs表示。u盘的挂载方法mount -t vfat /dev/sdb1 /mnt/mount -t ntfs /dev/sdb1 /mnt/umount命令用于卸载已经挂载的文件系统，基本格式如：umount dir device对于光盘文件系统的卸载可以使用，以下两条命令中的任意一条umount /dev/cdromumount /media/cdromu盘的卸载umount /dev/sdb1eject命令eject 弹出光盘命令eject -t 光盘驱动器自动回收 ln1234567891011121314151617181920指令名称:ln 使用权限:所有使用者 使用方式:ln [options] source dist,其中 option 的格式为: [-bdfinsvF] [-S backup-suffix] [-V &#123;numbered,existing,simple&#125;] [--help] [--version] [--] 说明:Linux/Unix 档案系统中,有所谓的连结(link),我们可以将其视为档案的别名,而连结又可分为两种:硬连结(hard link)与软连结(symbolic link),硬连结的意思是一个档案可以有多个名称,而软连结的方式则是产生一个特殊的档案,该档案的内容是指向另一个档案的位置。硬连结是存在同一个档案系统中,而软连结却可以跨越不同的档案系统。 ln source dist 是产生一个连结(dist)到 source,至于使用硬连结或软链结则由参数决定。 不论是硬连结或软链结都不会将原本的档案复制一份,只会占用非常少量的磁碟空间。 -f:链结时先将与 dist 同档名的档案删除-d:允许系统管理者硬链结自己的目录-i:在删除与 dist 同档名的档案时先进行询问-n:在进行软连结时,将 dist 视为一般的档案-s:进行软链结(symbolic link)-v:在连结之前显示其档名-b:将在链结时会被覆写或删除的档案进行备份-S SUFFIX:将备份的档案都加上 SUFFIX 的字尾-V METHOD:指定备份的方式--help:显示辅助说明--version:显示版本 范例: 将档案 yy 产生一个 symbolic link:zz ln -s yy zz 将档案 yy 产生一个 hard link:zz ln yy xx at123456789101112131415161718192021222324 使用权限:所有使用者 使用方式:at -V [-q queue] [-f file] [-mldbv] TIME 说明:at 可以让使用者指定在 TIME 这个特定时刻执行某个程式或指令,TIME 的格式是 HH:MM其中的 HH 为小时,MM 为分钟,甚至你也可以指定 am, pm, midnight, noon, teatime(就是下午 4 点锺)等口语词。 如果想要指定超过一天内的时间,则可以用 MMDDYY 或者 MM/DD/YY 的格式,其中 MM 是分钟,DD 是第几日,YY 是指年份。另外,使用者甚至也可以使用像是 now + 时间间隔来弹性指定时间,其中的时间间隔可以是 minutes, hours, days, weeks 另外,使用者也可指定 today 或 tomorrow 来表示今天或明天。当指定了时间并按下 enter 之后,at 会进入交谈模式并要求输入指令或程式,当你输入完后按下 ctrl+D 即可完成所有动作,至于执行的结果将会寄回你的帐号中。 把计: -V:印出版本编号 -q:使用指定的伫列(Queue)来储存,at 的资料是存放在所谓的 queue 中,使用者可以同时使用多个 queue,而 queue 的编号为 a, b, c... z 以及 A, B, ... Z 共 52 个 -m:即使程式/指令执行完成后没有输出结果, 也要寄封信给使用者 -f file:读入预先写好的命令档。使用者不一定要使用交谈模式来输入,可以先将所有的指定先写入档案后再一次读入 -l:列出所有的指定 (使用者也可以直接使用 atq 而不用 at -l) -d:删除指定 (使用者也可以直接使用 atrm 而不用 at -d) -v:列出所有已经完成但尚未删除的指定 例子: 三天后的下午 5 点锺执行 /bin/ls: at 5pm + 3 days /bin/ls 三个星期后的下午 5 点锺执行 /bin/ls: at 5pm + 2 weeks /bin/ls 明天的 17:20 执行 /bin/date: at 17:20 tomorrow /bin/date 1999 年的最后一天的最后一分钟印出 the end of world ! at 23:59 12/31/1999 echo the end of world ! cal12345678910111213141516171819202122 使用权限：所有使用者 使用方式：cal [-mjy] [month [year]] 说明： 显示日历。若只有一个参数,则代表年份(1-9999),显示该年的年历。年份必须全部写出：``cal 89\ 将不会是显示 1989 年的年历。使用两个参数,则表示月份及年份。若没有参数则显示这个月的月历。 1752 年 9 月第 3 日起改用西洋新历,因这时大部份的国家都采用新历,有 10 天被去除,所以该月份的月历有些不同。在此之前为西洋旧历。 匡兜: -m:以星期一为每周的第一天方式显示。 -j:以凯撒历显示,即以一月一日起的天数显示。 -y:显示今年年历。 范例： cal:显示本月的月历。 [root@mylinux /root]# date Tue Aug 15 08:00:18 CST 2000 [root@mylinux /root]# cal ... cal 2001:显示公元 2001 年年历。 [root@mylinux /root]# cal 2001 ...cal 5 2001:显示公元 2001 年 5 月月历。 [root@mylinux /root]# cal 5 2001 crontab1234567891011121314151617181920212223242526272829303132333435 使用权限:所有使用者 使用方式: crontab [ -u user ] filecrontab [ -u user ] &#123; -l | -r | -e &#125; 说明: crontab 是用来让使用者在固定时间或固定间隔执行程式之用,换句话说,也就是类似使用者的时程表。-u user 是指设定指定 user 的时程表,这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话,就是表示设定自己的时程表。 参数: -e:执行文字编辑器来设定时程表,内定的文字编辑器是 VI,如果你想用别的文字编辑器,则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe) -r:删除目前的时程表 -l:列出目前的时程表 时程表的格式如下: f1 f2 f3 f4 f5 program 其中 f1 是表示分钟,f2 表示小时,f3 表示一个月份中的第几日,f4 表示月份,f5 表示一个星期中的第几天。program 表示要执行的程式。 当 f1 为 * 时表示每分钟都要执行 program,f2 为 * 时表示每小时都要执行程式,其余类推 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行,f2 为 a-b 时表示从第 a 到第 b 小时都要执行,其余类推 当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次,f2 为 */n 表示每 n 小时个时间间隔执行一次,其余类推 当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行,f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行,其余类推 使用者也可以将所有的设定先存放在档案 file 中,用 crontab file 的方式来设定时程表。 例子: 每月每天每小时的第 0 分钟执行一次 /bin/ls: 0 7 * * * /bin/ls 在 12 月内, 每天的早上 6 点到 12 点中,每隔 20 分钟执行一次 /usr/bin/backup: 0 6-12/3 * 12 * /usr/bin/backup 周一到周五每天下午 5:00 寄一封信给 alex@domain.name: 0 17 * * 1-5 mail -s &quot;hi&quot; alex@domain.name &lt; /tmp/maildata 每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....执行 echo &quot;haha&quot; 20 0-23/2 * * * echo &quot;haha&quot; 注意: 当程式在你所指定的时间执行后,系统会寄一封信给你,显示该程式执行的内容,若是你不希望收到这样的信,请在每一行空一格之后加上 &gt; /dev/null 2&gt;&amp;1 即可。 sleep12345678910111213141516171819 使用权限:所有使用者 使用方式:sleep [--help] [--version] number[smhd] 说明:sleep 可以用来将目前动作延迟一段时间 参数说明: --help:显示辅助讯息 --version:显示版本编号 number:时间长度,后面可接 s,m,h 或 d 其中 s 为秒,m 为 分钟,h 为小时,d 为日数 例子: 显示目前时间后延迟 1 分钟,之后再次显示时间: date;sleep 1m;date 名称： finger 使用权限： 所有使用者 使用方式： finger [options] user[@address] 说明：finger 可以让使用者查询一些其他使用者的资料。范例：下列指令可以查询本机管理员的资料： finger root last1234567891011 使用权限：所有使用者 使用方式：shell&gt;&gt; last [options] 说明：显示系统开机以来获是从每月初登入者的讯息 把计: -R 省略 hostname 的栏位 -num 展示前 num 个 username 展示 username 的登入讯息 tty 限制登入讯息包含终端机代号 范例： shell&gt;&gt; last -R -2 write1234567891011121314151617 使用权限:所有使用者 使用方式: write user [ttyname] 说明:传讯息给其他使用者 把计: user:预备传讯息的使用者帐号 ttyname:如果使用者同时有两个以上的 tty 连线,可以自行选择合适的 tty 传讯息 例子.1: 传讯息给 Rollaend,此时 Rollaend 只有一个连线: write Rollaend 接下来就是将讯息打上去,结束请按 ctrl+c 例子.2 :传讯息给 Rollaend,Rollaend 的连线有 pts/2,pts/3: write Rollaend pts/2 接下来就是将讯息打上去,结束请按 ctrl+c 注意:若对方设定 mesg n,则此时讯席将无法传给对方 expr123456789101112131415161718192021 使用权限：所有使用者 ### 字串长度 shell&gt;&gt; expr length &quot;this is a test&quot; 14 ### 数字商数 shell&gt;&gt; expr 14 % 9 5 ### 从位置处抓取字串 shell&gt;&gt; expr substr &quot;this is a test&quot; 3 5 is is ### 数字串 only the first character shell&gt;&gt; expr index &quot;testforthegame&quot; e 2 ### 字串真实重现 shell&gt;&gt; expr quote thisisatestformela thisisatestformela clear12 用途：清除萤幕用。 使用方法：在 console 上输入 clear。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线工具收藏]]></title>
    <url>%2F20190422.html</url>
    <content type="text"><![CDATA[在线工具 爱信息图床 图片素材 熊猫图片压缩 图片压缩 json在线 jquery插件 Java 1.6 JDK IP查询 图片合并 ascii字体 应用评测 思维导图 代码对比 在线视频转换 在线资源 字体图标 CDN加速 maven资源 网站UI jar下载 css动画 在线海报 天气API PDF转换 ascii生成推荐 网址缩短 在线画图 程序下载 asciiworld 在线文档 正则手册 jqGrid文档 docker gitbooks freemarker文档 jquery文档 docker文档 git文档 spring Cloud 中文 dubbo文档 开源镜像 北京理工大学 阿里巴巴 开源社 docker 在线书籍 大话设计模式 鸟哥的私房菜 Elasticsearch权威指南 并发程序设计 zooKeeper 学习网站 自强学堂 mrbird 各种手册 java指南 菜鸟教程 vue视频 java进阶 其他 医疗手册 google论坛 zoomeye 源代码 google趋势 百度流量研究院]]></content>
      <categories>
        <category>utils</category>
      </categories>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud学习]]></title>
    <url>%2F20190315.html</url>
    <content type="text"><![CDATA[启动顺序dependences(依赖管理) &gt; config(配置中心) &gt; eureka(服务注册与发现) &gt; zipkin(链路追踪) &gt; 分布式配置中心 &gt; 服务注册中心 &gt; 服务提供者 &gt; 服务消费者 &gt; API网关 服务注册中心(Eureka)1234567891011121314151617181920// pom.xml 配置&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; // yml 配置spring: application: name: hello-spring-cloud-eurekaserver: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 分布式配置中心12345678910111213141516171819202122232425262728293031323334// 服务端pom.xml配置&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;// 客户端pom.xml配置&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;// 配置服务端yml配置spring: application: name: hello-spring-cloud-config cloud: config: label: master server: git: uri: https://github.com/topsale/spring-cloud-config search-paths: respo username: password:// 客户端yml配置spring: application: name: hello-spring-cloud-config-client cloud: config: uri: http://localhost:8888 name: config-client label: master profile: dev 服务提供者12345678910// ribbon服务提供者&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;// yml配置eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 服务消费者123456789101112131415// ribbon服务消费&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;//Feign服务消费&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;// yml配置eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ API网关123456789101112131415// zuul配置&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;// yum 配置zuul: routes: api-a: path: /api/a/** serviceId: hello-spring-cloud-web-admin-ribbon api-b: path: /api/b/** serviceId: hello-spring-cloud-web-admin-feign 熔断器防止服务雪崩12345678910// pom 配置&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;// yum配置feign: hystrix: enabled: true// application里面添加@EnableHystrix注解，调用方法上面增加@HystrixCommand(fallbackMethod = &quot;hiError&quot;)注解 熔断器仪表盘监控1234567891011121314151617181920// pom.xml配置&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;// application中添加@EnableHystrixDashboard注解//创建 hystrix.stream 的 Servlet 配置@Configurationpublic class HystrixDashboardConfiguration &#123; @Bean public ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean; &#125;&#125; 服务链路追踪1234567891011121314151617181920// pom.xml 配置&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;&lt;/dependency&gt;// aplication添加@EnableZipkinServer注解// yml配置management: metrics: web: server: auto-time-requests: false Spring Boot Admin12345678910111213141516171819202122232425262728293031323334// 服务端pom.xml依赖&lt;dependency&gt; &lt;groupId&gt;org.jolokia&lt;/groupId&gt; &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;&lt;/dependency&gt;// 客户端pom.xml依赖&lt;dependency&gt; &lt;groupId&gt;org.jolokia&lt;/groupId&gt; &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;&lt;/dependency&gt;// application添加@EnableAdminServer依赖// 服务端yml配置management: endpoint: health: show-details: always endpoints: web: exposure: include: health,info// 客户端yml配置spring: boot: admin: client: url: http://localhost:8084 其他 Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。 Spring Cloud Netflix：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。 Netflix Eureka：云端负载均衡，一个基于REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。 Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。 Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。 Netflix Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。 Spring Cloud for Cloud Foundry：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。 Spring Cloud Sleuth：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。 Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。 Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。 Spring Cloud Consul：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。 Spring Cloud Zookeeper：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。 Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。 Spring Cloud CLI：基于 SpringBoot CLI，可以让你以命令行方式快速建立云组件。]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi 快捷键记录]]></title>
    <url>%2F201902241.html</url>
    <content type="text"><![CDATA[vim键盘图 vi小抄 vi 常用 进入vi vi filename 打开或新建文件，并将光标置于第一行首 vi +n filename 打开文件，并将光标置于第n行首 vi + filename 打开文件，并将光标置于最后一行首 vi +/pattern filename 打开文件，并将光标置于第一个与pattern匹配的串处 vi -r filename 在上次正用vi编辑时发生系统崩溃，恢复filename vi filename….filename 打开多个文件，依次进行编辑 退出vi w /tmp1 另存为/tmp1 20,59w /tmp1 仅将20-59行之间的内存另存为/tmp1 !command 执行shell命令command wq 保存退出 n1,n2 w !command 将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入 r !command 将命令command的输出结果放到当前行 w !sudo tee % 保存没权限时，可获取权限再保存 光标移动 k、j、h、l 上、下、左、右 space 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 w(W)、b(B) 光标右、左移一个字至字首 e(E) 光标右移一个字至字尾 (、) 光标移至句首、尾 {、} 光标移至段落开头、结尾 nG 光标移至第n行首 n+、n- 光标下、上移n行 n$ 光标移至第n行尾 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 0 （注意是数字零）光标移至当前行首 $ 光标移至当前行尾 搜索（查找） /abc 从光标开始处向文件尾搜索abc ?abc 从光标开始处向文件首搜索abc /\/abc 从光标开始处向文件尾搜索/abc，其中/是转义 n 在同一方向重复上一次搜索命令 N 在反方向上重复上一次搜索命令 替换 s/vivian/sky/ 替换当前行第一个 vivian 为 sky s/vivian/sky/g 替换当前行所有 vivian 为 sky n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为sky %s/vivian/sky/g （等同于 g/vivian/s//sky/） 替换每一行的每一个 vivian 为 sky s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/（可以使用 #或+作为分隔符，此时中间出现的 / 不会作为分隔符） s/p1/p2/g 将当前行中所有p1均用p2替代 n1,n2s/p1/p2/g 将第n1至n2行中所有p1均用p2替代 g/p1/s//p2/g 将文件中所有p1均用p2替换 %s/^/123 把123添加到每行的行首 %s/$/123 把123添加到每行的行尾 g/^\s*$/d 去除所有空白行 %s/\n//g 删除换行符 屏幕翻滚 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl＋b 向文件首翻一屏 nz 将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部插入 i、a 在光标前 、后 I、A 在当前行首、尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 s 从当前光标位置处开始，以输入的文本替代指定数目的字符 S 删除指定数目的行，并以所输入文本代替之 R 替换当前字符及其后的字符，直至按ESC键 ncw或 nCW 修改指定数目的字 nCC 修改指定数目的行 删除 ndw 或 ndW 删除光标处开始及其后的n-1个字 do 、d$ 删至行首、行尾 x 或 X 删除一个字符，x删除光标后的，而X删除光标前的 ndd 删除当前行及其后n-1行 Ctrl+u 删除输入方式下所输入的文本 n1,n2 d 将n1行到n2行之间的内容删除 %d 删除全部内容 1,$d 删除全部内容 复制粘贴、剪切、移动 yy 复制当前行 nyy 复制当前行开始的n行 先按 v 然后方向键选择区域，按 y 复制选中行 dd 剪切当前行 p（小） 在当前光标处下面粘贴内容。 P（大） 在当前光标处上面粘贴内容 n1,n2 co n3 将n1行到n2行之间的内容拷贝到第n3行下 n1,n2 m n3 将n1行到n2行之间的内容移至到第n3行下 选项设置 set number 显示行号 set number! 不显示行号，其它选项同理加！号 set all 列出所有选项设置情况 set term 设置终端类型 set ignorance 在搜索中忽略大小写 set list 显示制表位(Ctrl+I)和行尾标志（$) set report 显示由面向行的命令修改过的数目 set terse 显示简短的警告信息 set warn 在转到别的文件时若没保存当前文件则显示NO write信息 set nomagic 允许在搜索模式中，使用前面不带“”的特殊字符 set nowrapscan 禁止vi在搜索到达文件两端时，又从另一端开始 set mesg 允许vi显示其他用户用write写到自己终端上的信息 寄存器 “?nyy 将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字 “?nyw 将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字 “?nyl 将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字 “?p 取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字 ndd 将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中]]></content>
      <categories>
        <category>vi</category>
      </categories>
      <tags>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyCat－学习笔记]]></title>
    <url>%2F20190224.html</url>
    <content type="text"><![CDATA[MyCat－学习笔记MyCat权威指南 拆表学习 当一张表的数量达到千万数据量以上的时候，加了索引可以正常查询， 但是在往上增加的话，可能就会出现查询速度慢的情况， 所有需要一些解决方案防止这种情况的发生。我暂时知道的解决方案如下： 数据读写分离：将应用的读写请求分到多个服务器上面，降低服务器访问压力。（适用于并发量大的情况下） 归档：将历史不用的数据进行归档处理，将数据压缩存放至硬盘、云盘等地方。 页面限制：用户查询时限制用户查询时间点，用户查询历史数据需求量大的话，可以单独做一个历史归档数据查询功能等。 拆库、拆表：同一个库里面的数据量太多，将数据拆分到多个表，多个库提高查询效率。解决表过大导致的访问出现卡顿现象。 &nbsp;&nbsp;读写分离的情况， 在并发量特别大的情况下很适用， 这种方法后期研究。 归档功能本公司已经在处理， 但是归档之后数据量还是特别大，这个时候就要拆库、拆表，拆库拆表之后对应用是有影响的，有两种情况， 一种就是改动应用的源代码，工作量就很大了，再有一种就是利用数据库中间件做一个数据库的代理。各种查询通过走中间件的方式进行，中间件负责分发查询请求到多个表，并汇总数据反馈给查询调用方。经过对比，最终选择了MyCat作为数据库中间件。由于数据库是oracle，MyCay对oracle的兼容性不是很好。后期可能调试的地方就比较多了。 水平拆表摘要 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张表的数据拆成多张表来存放(数据结构一样，每个表存放不同的数据按时间存放、ID取模的方法等)。水平分库需要对系统做大的改造; 方式 部分业务逻辑也可以通过地区，年份等字段来进行归档拆分; 进行拆分后的表，只能满足部分查询的高效查询需求，这时我们可以从界面上约束用户查询行为。比如我们是按年来进行归档拆分的,这个时候在页面设计上就约束用户必须要先选择年,然后才能进行查询; 在做分析或者统计时，由于是自己人的需求,多点等待其实是没关系的,并且并发很低,这个时候可以用union把所有表都组合成一张视图来然后再进行查询; 垂直拆表摘要 垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表;垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用jion关联起来即可;数据库里的表太多，拿出部分到新的库里，一般是根据业务划分表，关系密切的表放同一数据库，应用修改数据库连接即可; 方式 把不常用的字段单独放在一张表; 把text，blob等大字段拆分出来放在附表中; 经常组合查询的列放在一张表中; 拆表需要注意 跨节点join的问题、跨节点合并、排序、分页等处理数据的问题。 MyCat安装下载 在MyCat官网:http://dl.mycat.io/1.6.6.1/下载并解压。 MyCat配置 schema.xml配置 管理着 MyCat 的逻辑库、表、分片规则、 DataNode 以及 DataSource 123456789101112131415161718&lt;!-- 定义逻辑库，MyCat可以有多个逻辑库，每个逻辑库都有自己的相关配置。用schema 标签划分不同的逻辑库，checkSQLschema：否去掉表前面的数据库的名称，缺省未false，db1的名称不是schema的名称则不会去掉，官方不建议设置为true。sqlMaxLimit：每次执行语句，如果没有加上 limit 语句，mycat自动加。--&gt;&lt;schema name=&quot;db1&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;!-- 定义逻辑表，所有需要拆分的表都需要在这个标签中定义。具体含义相见表1-1 &lt;table name=&quot;travelrecord&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-long&quot; &gt; &lt;!-- 定义 E-R 分片的子表。通过标签上的属性与父表进行关联。 具体含义相见表1-2--&gt; &lt;childTable name=&quot;c_a&quot; primaryKey=&quot;ID&quot; joinKey=&quot;customer_id&quot; parentKey=&quot;id&quot; /&gt; &lt;/table&gt;&lt;/schema&gt;&lt;!-- 定义了 MyCat 中的数据节点，也就是我们通常说所的数据分片。一个 dataNode 标签就是一个独立的数据分片。具体含义相见表1-3--&gt;&lt;dataNode name=&quot;dNode1&quot; dataHost=&quot;dHost128&quot; database=&quot;db1&quot; &gt;&lt;/dataNode&gt;&lt;!-- 具体的数据库实例、读写分离配置和心跳语句.具体含义相见表1-4--&gt;&lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt; &lt;!--这个标签内指明用于和后端数据库进行心跳检查的语句。 例如：MYSQL 可以使用 select user()，Oracle 可以使用 select 1 from dual 等。--&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- writeHost /readHost:这两个标签都指定后端数据库的相关配置，用于实例化后端连接池。唯一不同的是，writeHost 指定写实例、readHost 指定读实例。 在一个 dataHost 内可以定义多个 writeHost 和 readHost。但是，如果 writeHost 指定的后端数据库宕机，那么这个 writeHost 绑定的所有 readHost 都将不可用。另一方面，由于这个 writeHost 宕机，系统会自动的检测到，并切换到备用的 writeHost 上去. 具体含义相见表1-5--&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;localhost:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/writeHost&gt;&lt;/dataHost&gt; table标签：1-1 childTable标签：1-2 dataNode标签：1-3 dataHost标签：1-4 writeHost/readHost标签：1-5 详细注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt; &lt;!-- schema 数据库设置，此数据库为逻辑数据库，name与server.xml中schema对应 dataNode 分片信息，也就是分库相关配置 dataHost 物理数据库，真正存储数据的数据库 命令行连接mycat: mysql -uroot -p123456 -h127.0.0.1 -P8066 -DTESTDB --&gt; &lt;!-- schema标签用来定义mycat实例中的逻辑库，mycat可以有多个逻辑库，每个逻辑库都有自己的相关配置。可以使用schema标签来划分这些不同的逻辑库如果不配置schema标签，所有表的配置会属于同一个默认的逻辑库。逻辑库的概念和MySql的database的概念一样，我们在查询两个不同逻辑库中的表的时候，需要切换到该逻辑库下进行查询。 name: 逻辑数据库名，与server.xml中的schema对应 checkSQLschema： 描述的是当前的连接是否需要检测数据库的模式 sqlMaxLimit： 表示返回的最大的数据量的行数 (sqlMaxLimit=&quot;100&quot;) 暂时不加limit限制 dataNode=&quot;dn1&quot;： 该操作使用的数据节点是dn1的逻辑名称 --&gt; &lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; dataNode=&quot;dn1&quot;&gt; &lt;!-- name 表名，物理数据库中表名 dataNode 表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的name primaryKey 主键字段名，自动生成主键时需要设置 autoIncrement 是否自增 rule 分片规则名，具体规则下文rule详细介绍 type 该属性定义了逻辑表的类型，目前逻辑表只有全局表和普通表。全局表： global 普通表：无 注：全局表查询任意节点，普通表查询所有节点效率低 autoIncrement mysql对非自增长主键，使用last_insert_id() 是不会返回结果的，只会返回0.所以，只有定义了自增长主键的表，才可以用last_insert_id()返回主键值。 mycat提供了自增长主键功能，但是对应的mysql节点上数据表，没有auto_increment,那么在mycat层调用last_insert_id()也是不会返回结果的。 needAddLimit 指定表是否需要自动的在每个语句后面加上limit限制，由于使用了分库分表，数据量有时候会特别庞大，这时候执行查询语句， 忘记加上limt就会等好久，所以mycat自动为我们加上了limit 100，这个属性默认为true，可以自己设置为false禁用。如果使用这个功能，最好配合使用数据库模式的全局序列。 subTables 分表，分表目前不支持Join。--&gt; &lt;table name=&quot;pub_corporate&quot; dataNode=&quot;dn1&quot; type=&quot;global&quot;&gt;&lt;/table&gt; &lt;!-- childTable 标签用于定义 E-R 分片的子表。通过标签上的属性与父表进行关联。 name 子表的名称 joinKey 子表中字段的名称 parentKey 父表中字段名称 primaryKey 同Table needAddLimit 同Table --&gt; &lt;!-- &lt;childTable name=&quot;c_a&quot; primaryKey=&quot;ID&quot; joinKey=&quot;customer_id&quot; parentKey=&quot;id&quot; /&gt; --&gt; &lt;/schema&gt; &lt;!-- datanode标签定义了mycat中的数据节点，也就是我们所说的数据分片。一个datanode标签就是一个独立的数据分片。 例子中的表述的意思为，使用名字为localhost1数据库实例上的db1物理数据库，这就组成一个数据分片，最后我们用dn1来标示这个分片。 name 定义数据节点的名字，这个名字需要唯一。我们在table标签上用这个名字来建立表与分片对应的关系 dataHost 用于定义该分片属于哪个数据库实例，属性与datahost标签上定义的name对应 database 用于定义该分片属于数据库实例上的具体库。 --&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;TESTLOCALHOST&quot; database=&quot;test&quot; /&gt; &lt;!-- name 唯一标示dataHost标签，供上层使用 maxCon 指定每个读写实例连接池的最大连接。 minCon 指定每个读写实例连接池的最小连接，初始化连接池的大小 balance 负载均称类型 balance=&quot;0&quot;：不开启读写分离机制，所有读操作都发送到当前可用的writeHost上 balance=&quot;1&quot;：全部的readHost与stand by writeHost参与select语句的负载均衡，简单的说，当双主双从模式（M1-S1，M2-S2 并且M1 M2互为主备），正常情况下，M2,S1,S2都参与select语句的负载均衡。 balance=&quot;2&quot;：所有读操作都随机的在writeHost、readHost上分发 balance=&quot;3&quot;：所有读请求随机的分发到writeHst对应的readHost执行，writeHost不负担读写压力。（1.4之后版本有） writeType 负载均衡类型。 writeType=&quot;0&quot;, 所有写操作发送到配置的第一个 writeHost，第一个挂了切到还生存的第二个writeHost，重新启动后已切换后的为准，切换记录在配置文件中:dnindex.properties . writeType=&quot;1&quot;，所有写操作都随机的发送到配置的 writeHost。1.5以后版本废弃不推荐。 switchType -1不自动切换 1 默认值 自动切换 2 基于MySql主从同步的状态决定是否切换心跳语句为 show slave status 3 基于mysql galary cluster 的切换机制（适合集群）1.4.1 心跳语句为 show status like &apos;wsrep%&apos; dbType 指定后端链接的数据库类型目前支持二进制的mysql协议，还有其他使用jdbc链接的数据库，例如：mongodb，oracle，spark等 dbDriver 指定连接后段数据库使用的driver，目前可选的值有native和JDBC。使用native的话，因为这个值执行的是二进制的mysql协议，所以可以使用mysql和maridb，其他类型的则需要使用JDBC驱动来支持。 如果使用JDBC的话需要符合JDBC4标准的驱动jar 放到mycat\lib目录下，并检查驱动jar包中包括如下目录结构文件 META-INF\services\java.sql.Driver。 在这个文件写上具体的driver类名，例如com.mysql.jdbc.Driver writeHost readHost指定后端数据库的相关配置给mycat，用于实例化后端连接池。 tempReadHostAvailable 如果配置了这个属性 writeHost 下面的 readHost 仍旧可用，默认 0 可配置（0、1）。 mysql: dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; oracle: dbType=&quot;oracle&quot; dbDriver=&quot;jdbc&quot; --&gt; &lt;dataHost name=&quot;TESTLOCALHOST&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;oracle&quot; dbDriver=&quot;jdbc&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt; &lt;!--mysql心跳检查的语句 oracle: select 1 from dual mysql: select user()--&gt; &lt;heartbeat&gt;select 1 from dual&lt;/heartbeat&gt; &lt;!-- writeHost /readHost 标签 这两个标签都指定后端数据库的相关配置，用于实例化后端连接池。唯一不同的是，writeHost 指定写实例、readHost 指定读实例。 在一个 dataHost 内可以定义多个 writeHost 和 readHost。但是，如果 writeHost 指定的后端数据库宕机，那么这个 writeHost 绑定的所有 readHost 都将不可用。 另一方面，由于这个 writeHost 宕机，系统会自动的检测到，并切换到备用的 writeHost 上去。这两个标签的属性相同，这里就一起介绍。 host 用于标识不同实例，一般 writeHost 我们使用*M1，readHost 我们用*S1。 url 后端实例连接地址。Native：地址：端口 JDBC：jdbc的url password 后端存储实例需要的密码 user 后端存储实例需要的用户名字 weight 权重 配置在 readhost 中作为读节点的权重 usingDecrypt 是否对密码加密，默认0。具体加密方法看官方文档。--&gt; &lt;!--&lt;writeHost host=&quot;hostM1&quot; url=&quot;localhost:3306&quot; user=&quot;root&quot;--&gt; &lt;!--password=&quot;123456&quot;&gt;--&gt; &lt;!--&lt;/writeHost&gt;--&gt; &lt;!--&lt;writeHost host=&quot;hostM1&quot; url=&quot;localhost:3306&quot; user=&quot;root&quot; password=123456i&quot;&gt;--&gt; &lt;!--&lt;/writeHost&gt;--&gt; &lt;!--oracle: jdbc:oracle:thin:@IP地址:1521:orcl mysql: localhost:3306 --&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot; user=&quot;tysp&quot; password=&quot;123456&quot;&gt; &lt;/writeHost&gt; &lt;/dataHost&gt;&lt;/mycat:schema&gt; Server.xml的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&gt;&lt;mycat:server xmlns:mycat=&quot;http://io.mycat/&quot;&gt; &lt;system&gt; &lt;property name=&quot;charset&quot;&gt;utf8&lt;/property&gt; &lt;property name=&quot;nonePasswordLogin&quot;&gt;0&lt;/property&gt; &lt;!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户--&gt; &lt;property name=&quot;useHandshakeV10&quot;&gt;1&lt;/property&gt; &lt;property name=&quot;useSqlStat&quot;&gt;0&lt;/property&gt; &lt;!-- 1为开启实时统计、0为关闭 --&gt; &lt;property name=&quot;useGlobleTableCheck&quot;&gt;0&lt;/property&gt; &lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt; &lt;property name=&quot;sequnceHandlerType&quot;&gt;2&lt;/property&gt; &lt;property name=&quot;subqueryRelationshipCheck&quot;&gt;false&lt;/property&gt; &lt;!-- 子查询中存在关联查询的情况下,检查关联字段中是否有分片字段 .默认 false --&gt; &lt;!-- &lt;property name=&quot;useCompression&quot;&gt;1&lt;/property&gt;--&gt; &lt;!--1为开启mysql压缩协议--&gt; &lt;!-- &lt;property name=&quot;fakeMySQLVersion&quot;&gt;5.6.20&lt;/property&gt;--&gt; &lt;!--设置模拟的MySQL版本号--&gt; &lt;!-- &lt;property name=&quot;processorBufferChunk&quot;&gt;40960&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;processors&quot;&gt;1&lt;/property&gt; &lt;property name=&quot;processorExecutor&quot;&gt;32&lt;/property&gt; --&gt; &lt;!--默认为type 0: DirectByteBufferPool | type 1 ByteBufferArena | type 2 NettyBufferPool --&gt; &lt;property name=&quot;processorBufferPoolType&quot;&gt;0&lt;/property&gt; &lt;!--默认是65535 64K 用于sql解析时最大文本长度 --&gt; &lt;!--&lt;property name=&quot;maxStringLiteralLength&quot;&gt;65535&lt;/property&gt;--&gt; &lt;!--&lt;property name=&quot;sequnceHandlerType&quot;&gt;0&lt;/property&gt;--&gt; &lt;!--&lt;property name=&quot;backSocketNoDelay&quot;&gt;1&lt;/property&gt;--&gt; &lt;!--&lt;property name=&quot;frontSocketNoDelay&quot;&gt;1&lt;/property&gt;--&gt; &lt;!--&lt;property name=&quot;processorExecutor&quot;&gt;16&lt;/property&gt;--&gt; &lt;!-- &lt;property name=&quot;serverPort&quot;&gt;8066&lt;/property&gt; &lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt; &lt;property name=&quot;idleTimeout&quot;&gt;300000&lt;/property&gt; &lt;property name=&quot;bindIp&quot;&gt;0.0.0.0&lt;/property&gt; &lt;property name=&quot;frontWriteQueueSize&quot;&gt;4096&lt;/property&gt; &lt;property name=&quot;processors&quot;&gt;32&lt;/property&gt; --&gt; &lt;!--分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志--&gt; &lt;property name=&quot;handleDistributedTransactions&quot;&gt;0&lt;/property&gt; &lt;property name=&quot;useOffHeapForMerge&quot;&gt;1&lt;/property&gt;&lt;!--off heap for merge/order/group/limit 1开启 0关闭--&gt; &lt;property name=&quot;memoryPageSize&quot;&gt;64k&lt;/property&gt; &lt;!--单位为m--&gt; &lt;property name=&quot;spillsFileBufferSize&quot;&gt;1k&lt;/property&gt;&lt;!--单位为k--&gt; &lt;property name=&quot;useStreamOutput&quot;&gt;0&lt;/property&gt; &lt;property name=&quot;systemReserveMemorySize&quot;&gt;384m&lt;/property&gt;&lt;!--单位为m--&gt; &lt;property name=&quot;useZKSwitch&quot;&gt;false&lt;/property&gt;&lt;!--是否采用zookeeper协调切换 --&gt; &lt;!-- XA Recovery Log日志路径 --&gt; &lt;!--&lt;property name=&quot;XARecoveryLogBaseDir&quot;&gt;./&lt;/property&gt;--&gt; &lt;!-- XA Recovery Log日志名称 --&gt; &lt;!--&lt;property name=&quot;XARecoveryLogBaseName&quot;&gt;tmlog&lt;/property&gt;--&gt; &lt;!--如果为 true的话 严格遵守隔离级别,不会在仅仅只有select语句的时候在事务中切换连接--&gt; &lt;property name=&quot;strictTxIsolation&quot;&gt;false&lt;/property&gt; &lt;property name=&quot;useZKSwitch&quot;&gt;true&lt;/property&gt; &lt;/system&gt; &lt;!-- 全局SQL防火墙设置 --&gt; &lt;!--白名单可以使用通配符%或着*--&gt; &lt;!--例如&lt;host host=&quot;127.0.0.*&quot; user=&quot;root&quot;/&gt;--&gt; &lt;!--例如&lt;host host=&quot;127.0.*&quot; user=&quot;root&quot;/&gt;--&gt; &lt;!--例如&lt;host host=&quot;127.*&quot; user=&quot;root&quot;/&gt;--&gt; &lt;!--例如&lt;host host=&quot;1*7.*&quot; user=&quot;root&quot;/&gt;--&gt; &lt;!--这些配置情况下对于127.0.0.1都能以root账户登录--&gt; &lt;!-- &lt;firewall&gt; &lt;whitehost&gt; &lt;host host=&quot;1*7.0.0.*&quot; user=&quot;root&quot;/&gt; &lt;/whitehost&gt; &lt;blacklist check=&quot;false&quot;&gt; &lt;/blacklist&gt; &lt;/firewall&gt; --&gt; &lt;!--name登录的用户名，也就是连接Mycat的用户名--&gt; &lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt; &lt;!--password 登录的密码，也就是连接Mycat的密码--&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;!--schemas 数据库名，这里会和schema.xml中的配置关联，多个用逗号分开，例如需要这个用户需要管理两个数据库db1,db2，则配置db1,dbs--&gt; &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt; &lt;!-- 表级 DML 权限设置 对用户的 schema以及表进行精细化的DML权限控制 check 表示是否开启DML权限检查。默认是关闭。server.dtd文件中 &lt;!ELEMENT privileges (schema)*&gt; 说明可以有多个schema的配置。 dml 顺序说明：insert,update,select,delete db1的权限是update,select。 tb01的权限是啥都不能干。 tb02的权限是insert,update,select,delete。 其他表默认是udpate,select。 --&gt; &lt;!-- &lt;privileges check=&quot;false&quot;&gt; &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt; &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt; &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt; &lt;/schema&gt; &lt;/privileges&gt; --&gt; &lt;/user&gt; &lt;user name=&quot;user&quot;&gt; &lt;property name=&quot;password&quot;&gt;user&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt; &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt; &lt;/user&gt;&lt;/mycat:server&gt; rule.xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mycat:rule SYSTEM &quot;rule.dtd&quot;&gt;&lt;mycat:rule xmlns:mycat=&quot;http://io.mycat/&quot;&gt; &lt;!--对表进行拆分所涉及到的规则定义。我们可以灵活的对表使用不同的分片算法，或者对表使用相同的算法但具体的参数不同。 name 属性指定唯一的名字，用于标识不同的表规则。 内嵌的 rule 标签则指定对物理表中的哪一列进行拆分和使用什么路由算法。 columns 内指定要拆分的列名字。 algorithm 使用 function 标签中的 name 属性。连接表规则和具体路由算法。当然，多个表规则可以连接到 同一个路由算法上。table 标签内使用。让逻辑表使用这个规则进行分片。 --&gt; &lt;tableRule name=&quot;rule1&quot;&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;func1&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;rule2&quot;&gt; &lt;rule&gt; &lt;columns&gt;user_id&lt;/columns&gt; &lt;algorithm&gt;func1&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;sharding-by-intfile&quot;&gt; &lt;rule&gt; &lt;columns&gt;sharding_id&lt;/columns&gt; &lt;algorithm&gt;hash-int&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;auto-sharding-long&quot;&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;rang-long&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;mod-long&quot;&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;mod-long&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;sharding-by-murmur&quot;&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;murmur&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;crc32slot&quot;&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;crc32slot&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;sharding-by-month&quot;&gt; &lt;rule&gt; &lt;columns&gt;create_time&lt;/columns&gt; &lt;algorithm&gt;partbymonth&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;latest-month-calldate&quot;&gt; &lt;rule&gt; &lt;columns&gt;calldate&lt;/columns&gt; &lt;algorithm&gt;latestMonth&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;auto-sharding-rang-mod&quot;&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;rang-mod&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;tableRule name=&quot;jch&quot;&gt; &lt;rule&gt; &lt;columns&gt;id&lt;/columns&gt; &lt;algorithm&gt;jump-consistent-hash&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;!-- name 指定算法的名字。 class 制定路由算法具体的类名字。 property 为具体算法需要用到的一些属性。--&gt; &lt;function name=&quot;murmur&quot; class=&quot;io.mycat.route.function.PartitionByMurmurHash&quot;&gt; &lt;property name=&quot;seed&quot;&gt;0&lt;/property&gt;&lt;!-- 默认是0 --&gt; &lt;property name=&quot;count&quot;&gt;2&lt;/property&gt;&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片 --&gt; &lt;property name=&quot;virtualBucketTimes&quot;&gt;160&lt;/property&gt;&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍 --&gt; &lt;!-- &lt;property name=&quot;weightMapFile&quot;&gt;weightMapFile&lt;/property&gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 --&gt; &lt;!-- &lt;property name=&quot;bucketMapPath&quot;&gt;/etc/mycat/bucketMapPath&lt;/property&gt; 用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt; &lt;/function&gt; &lt;function name=&quot;crc32slot&quot; class=&quot;io.mycat.route.function.PartitionByCRC32PreSlot&quot;&gt; &lt;/function&gt; &lt;function name=&quot;hash-int&quot; class=&quot;io.mycat.route.function.PartitionByFileMap&quot;&gt; &lt;property name=&quot;mapFile&quot;&gt;partition-hash-int.txt&lt;/property&gt; &lt;/function&gt; &lt;function name=&quot;rang-long&quot; class=&quot;io.mycat.route.function.AutoPartitionByLong&quot;&gt; &lt;property name=&quot;mapFile&quot;&gt;autopartition-long.txt&lt;/property&gt; &lt;/function&gt; &lt;function name=&quot;mod-long&quot; class=&quot;io.mycat.route.function.PartitionByMod&quot;&gt; &lt;!-- how many data nodes --&gt; &lt;property name=&quot;count&quot;&gt;3&lt;/property&gt; &lt;/function&gt; &lt;function name=&quot;func1&quot; class=&quot;io.mycat.route.function.PartitionByLong&quot;&gt; &lt;property name=&quot;partitionCount&quot;&gt;8&lt;/property&gt; &lt;property name=&quot;partitionLength&quot;&gt;128&lt;/property&gt; &lt;/function&gt; &lt;function name=&quot;latestMonth&quot; class=&quot;io.mycat.route.function.LatestMonthPartion&quot;&gt; &lt;property name=&quot;splitOneDay&quot;&gt;24&lt;/property&gt; &lt;/function&gt; &lt;function name=&quot;partbymonth&quot; class=&quot;io.mycat.route.function.PartitionByMonth&quot;&gt; &lt;property name=&quot;dateFormat&quot;&gt;yyyy-MM-dd&lt;/property&gt; &lt;property name=&quot;sBeginDate&quot;&gt;2015-01-01&lt;/property&gt; &lt;/function&gt; &lt;function name=&quot;rang-mod&quot; class=&quot;io.mycat.route.function.PartitionByRangeMod&quot;&gt; &lt;property name=&quot;mapFile&quot;&gt;partition-range-mod.txt&lt;/property&gt; &lt;/function&gt; &lt;function name=&quot;jump-consistent-hash&quot; class=&quot;io.mycat.route.function.PartitionByJumpConsistentHash&quot;&gt; &lt;property name=&quot;totalBuckets&quot;&gt;3&lt;/property&gt; &lt;/function&gt;&lt;/mycat:rule&gt; 暂时在mysql测试是可以的。 oracle链接的时候，jdbc一直无法链接。后期在正式环境使用的时候，在记录吧！ mycat的权威指南链接： http://www.mycat.io/document/Mycat_V1.6.0.pdf]]></content>
      <categories>
        <category>MyCat</category>
      </categories>
      <tags>
        <tag>MyCat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OracleDatabase9i10g11g编程艺术深入数据库体系结构(第2版)－学习笔记]]></title>
    <url>%2F20190218.html</url>
    <content type="text"><![CDATA[一些sql语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171-- 时间格式化to_date(&apos;2019-01-28&apos;, &apos;yyyy-mm-dd&apos;)TO_DATE(&apos;2018-1-21 17:21:11&apos;, &apos;YYYY-MM-DD HH24:MI:SS&apos;)-- 删除表空间以及内容drop tablespace tablespace_name including contents and datafiles;-- 查看oracle库的表空间以及使用情况select sum(bytes)/(1024*1024) as free_space,tablespace_name from dba_free_space group by tablespace_name; -- 服务器表空间的存储位置select tablespace_name,file_name,bytes/1024/1024 file_size,autoextensible from dba_temp_files;-- 创建临时表空间create temporary tablespace test_temptempfile &apos;/u01/app/oracle/oradata/XE/test_temp.dbf&apos;size 32mautoextend onnext 32m maxsize unlimitedextent management local;-- 创建表空间create tablespace test_dataloggingdatafile &apos;/u01/app/oracle/oradata/XE/test-data.dbf&apos;size 32mautoextend onnext 32m maxsize unlimitedextent management local;-- 创建用户create user test identified by manageraccount unlockdefault tablespace test_datatemporary tablespace test_temp;-- 授权给用户 grant connect,resource,dba to test;-- 创建索引CREATE UNIQUE INDEX ID_EQ ON TABLENAME (ID);-- 创建非唯一索引CREATE INDEX ID_EQ ON TABLENAME (ID);-- 查询当前被锁的对象 select t2.username, t2.sid, t2.serial#, t2.logon_timefrom v$locked_object t1, v$session t2where t1.session_id = t2.sidorder by t2.logon_time -- 杀会话136,45267为对应的ID ALTER SYSTEM KILL SESSION &apos;136,45267&apos;-- 普通查询（硬解析）SELECT * FROM TEST.DC_PROJECT WHERE SEQ_ID = 1-- 绑定变量查询（软解析）SELECT * FROM TEST.DC_PROJECT WHERE SEQ_ID = :SEQ_IDCREATE TABLE t (x int); -- 创建t表DELETE FROM TEST.T; -- 删除表数据-- 循环给t表添加100条数据 （硬解析）DECLARE i number := 0;BEGIN FOR i IN 1 .. 100 LOOP INSERT INTO TEST.T VALUES (i); END LOOP;COMMIT;END;-- 循环给t表添加100条数据(软解析）相比于硬解析快20倍（未验证， oracle编程艺术书解释）DECLARE i number := 0;BEGIN FOR i IN 1 .. 100 LOOP EXECUTE IMMEDIATE &apos;INSERT INTO TEST.T VALUES ( :X )&apos; USING i; END LOOP;COMMIT;END;-- 查看oracle版本select * from v$versionselect version from v$instance;Select version FROM Product_component_version Where SUBSTR(PRODUCT,1,6)=&apos;Oracle&apos;;-- SQL&gt;：查看当前的数据库参数undo_retention设置（闪回时间）SQL&gt;：show parameter undo-- 修改系统的undo_retention时间ALTER SYSTEM SET undo_retention=10800 SCOPE=BOTH;-- SQL&gt;：闪回测试SQL&gt;：variable scn NUMBERSQL&gt;：EXEC :scn := dbms_flashback.get_system_change_number;SQL&gt;：print scn;-- 查看闪回是否开启select flashback_on from V$database;-- 开启闪回alter system set db_recovery_file_dest_size=2G scope=both;alter system set db_recovery_file_dest=&apos;/u01/app/oracle/oradata/XE/flashback&apos; scope=both;root: su - oracle -- 必须用oracle用户访问 linux命令行执行oracle: sqlplus /nolog -- 进入sqlplus控制台 linux命令行执行SQL&gt;：connect / as sysdba -- 系统管理员登陆SQL&gt;：shutdown IMMEDIATE; -- 不允许新的连接、不等待会话结束、不等待事务结束、做一个检查点并关闭数据文件。没有结束的事务是自动ROLLBACK的。启动时不需要实例恢复。SQL&gt;：startup mount; -- mount数据库，仅仅给dba进行管理操作，不允许数据库的用户访问。仅仅只是当前实例的控制文件被打开，数据文件未打开。SQL&gt;：alter database archivelog; -- 归档日志SQL&gt;：alter database flashback on; -- 闪回开启 报错：ORA-00439: feature not enabled: Flashback Database 。 oracle的标准版和标准1版均不支持！只有购买了企业版本才支持flashback.SQL&gt;：alter database open; -- 打开数据库-- 闪回查询（在某个时间节点表做了什么）select count(*), :scn then_scn, dbms_flashback.get_system_change_number now_scn from test.emp as of scn :scn;-- 闪回查询（同一个对象在两个时间节点所做的事情）select count(*), :scn then_scn, dbms_flashback.get_system_change_number now_scn from (select count(*) cnt_now from test.emp), (select count(*) cnt_then from test.emp as of scn :scn-- 查询资源被锁的简单信息select username,object_name, sid,serial#,logon_time from v$locked_object,v$session, dba_objects where v$locked_object.session_id=v$session.sid AND dba_objects.object_id =v$locked_object.object_id ;/** 查询资源被锁的详细信息 v$locked_object 视图中记录了所有session中的所有被锁定的对象信息。 v$session 视图记录了所有session的相关信息。 dba_objects 为oracle用户对象及系统对象的集合，通过关联这张表能够获取被锁定对象的详细信息。 username：oracle用户名 sid：进程号 serial#：序列号 object_name：表名 osuser：操作系统用户名 machine：机器名 program：操作工具 logon_time：登陆时间 lockwait：表示当前这张表是否正在等待其他用户解锁这张表 locked_mode：锁表模式（下面详细说明） 0：none 1：null 空 2：Row-S 行共享(RS)：共享表锁，sub share 3：Row-X 行独占(RX)：用于行的修改，sub exclusive 4：Share 共享锁(S)：阻止其他DML操作，share 5：S/Row-X 共享行独占(SRX)：阻止其他事务操作，share/sub exclusive 6：exclusive 独占(X)：独立访问使用，exclusive 1级锁有：Select，有时会在v$locked_object出现。 2级锁有：Select for update,Lock For Update,Lock Row Share select for update当对话使用for update子串打开一个游标时，所有返回集中的数据行都将处于行级(Row-X)独占式锁定，其他对象只能查询这些数据行，不能进行update、delete或select for update操作。 3级锁有：Insert, Update, Delete, Lock Row Exclusive 没有commit之前插入同样的一条记录会没有反应, 因为后一个3的锁会一直等待上一个3的锁, 我们必须释放掉上一个才能继续工作。 4级锁有：Create Index, Lock Share locked_mode为2,3,4不影响DML(insert,delete,update,select)操作, 但DDL(alter,drop等)操作会提示ora-00054错误。 00054, 00000, “resource busy and acquire with NOWAIT specified” // *Cause: Resource interested is busy. // *Action: Retry if necessary. 5级锁有：Lock Share Row Exclusive 具体来讲有主外键约束时update / delete … ; 可能会产生4,5的锁。 6级锁有：Alter table, Drop table, Drop Index, Truncate table, Lock Exclusive */select t2.LOGON_TIME,t2.username,t2.sid,t2.serial#,t3.object_name,t1.LOCKED_MODE,t2.OSUSER,t2.MACHINE,t2.PROGRAM,t2.COMMAND,t2.LOCKWAITfrom v$locked_object t1, v$session t2, dba_objects t3 where t1.session_id = t2.sid and t1.object_id = t3.object_id order by t2.logon_time;--查某session 正在执行的sql语句，从而可以快速定位到哪些操作或者代码导致事务一直进行没有结束等.SELECT sql_text FROM v$sqltext a WHERE (a.hash_value, a.address) IN(SELECT DECODE(sql_hash_value, 0, prev_hash_value, sql_hash_value),DECODE(sql_hash_value, 0, prev_sql_addr, sql_address)FROM v$session b WHERE b.sid = &apos;665&apos;) ORDER BY piece ASC;-- kill 资源被锁alter system kill session &apos;988,24597&apos;-- 查看链接数select username,count(username) from v$session where username is not null group by username-- 查看表的剩余空间,是否自动扩展，可以自动扩展的最大值select FILE_NAME,TABLESPACE_NAME,BYTES/1024/1024 BYTES_M, MAXBYTES/1024/1024 MAX_M,AUTOEXTENSIBLE from dba_data_files;-- 查看表的表空间select tablespace_name,table_name from user_tables where table_name=&apos;TABLE_NAME&apos;;-- 查看表的实际使用情况，和剩余空间select f.tablespace_name tablespace_name,round((d.sumbytes/1024/1024)) total_m,round((d.sumbytes-f.sumbytes)/1024/1024) used_m,round(f.sumbytes/1024/1024,2) free_m,round((d.sumbytes-f.sumbytes)*100/d.sumbytes,2)||&apos;%&apos; used_percent,round((f.sumbytes)*100/d.sumbytes,2)||&apos;%&apos; free_percent from (select tablespace_name,sum(bytes) sumbytes from dba_free_space group by tablespace_name) f,(select tablespace_name,sum(bytes) sumbytes from dba_data_files group by tablespace_name) d where f.tablespace_name= d.tablespace_name(+) order by (d.sumbytes-f.sumbytes)*100/d.sumbytes desc;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop学习笔记]]></title>
    <url>%2F20190126.html</url>
    <content type="text"><![CDATA[安装hadoop 在apache官网下载. 找到发布版本通过wget下载.gz的安装包。 1wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-3.1.1/hadoop-3.1.1.tar.gz 解压安装包 1tar zxvf hadoop-3.1.1.tar.gz hadoop环境变量 1234567891011121314151617sudo vi ~/.bashrc // 编辑环境变量的文件，并在最后追加如下内容。#HADOOP VARIABLES STARTexport HADOOP_INSTALL=/usr/hadoop/hadoop-3.1.1 // hadoop解压路径export PATH=$PATH:$HADOOP_INSTALL/binexport PATH=$PATH:$HADOOP_INSTALL/sbinexport HADOOP_MAPRED_HOME=$HADOOP_INSTALLexport HADOOP_COMMON_HOME=$HADOOP_INSTALLexport HADOOP_HDFS_HOME=$HADOOP_INSTALLexport YARN_HOME=$HADOOP_INSTALLexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_INSTALL/lib/nativeexport HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_INSTALL/lib&quot;#HADOOP VARIABLES ENDsource ~/.bashrc //生效hadoop version // 验证是否生效，查看版本 编辑/etc/hadoop/hadoop-env.sh的默认jdk路径 1JAVA_HOME=/usr/java-jdk //添加JAVA_HOME路径。不知道路径可以用echo $JAVA_HOME查看 配置hadoop/etc/hadoop/core-site.xml文件 12345678910111213&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;!-- hadoop数据存储路径 --&gt; &lt;value&gt;file:/usr/hadoop/hadoop-3.1.1/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;!-- hadoop访问路径 --&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置hadoop/etc/hadoop/hdfs-site.xml文件 1234567891011121314151617&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;!-- 副本份数 --&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;!-- namenode路径 --&gt; &lt;value&gt;file:/usr/hadoop/hadoop-3.1.1/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;!-- datanode路径 --&gt; &lt;value&gt;file:/usr/hadoop/hadoop-3.1.1/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置hadoop/etc/hadoop/yarn-site.xml文件 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置hadoop/etc/hadoop/mapred-site.xml文件 12345678mv mapred-queues.xml.template mapred-queues.xml // 重命名mapred-queues.xml.template文件&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;localhost:9001&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 格式化hadoop 12cd hadoop/bin ./hadoop // 应该2.8版本前需要初始化，3.1.1直接格式化一下 hadoop namenode -format 启动hadoop 12345678910在sbin文件夹下依次执行：start-dfs.sh start-yarn.sh 如果报错：ERROR: Attempting to launch hdfs namenode as root 需要在start-dfs.sh和sbin/stop-dfs.sh 顶部空白处添加内容：HDFS_DATANODE_USER=root HDFS_DATANODE_SECURE_USER=hdfs HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[短语]]></title>
    <url>%2F20190108.html</url>
    <content type="text"><![CDATA[It’s impossible to find someone who never hurts you, so go for the one who’s worth the pain. // 想找一个永远不会伤害你的人是不可能的， 所有就找一个值得你去承受这种痛苦的人吧！ It takes only a minute to get a crush on someone, an hour to like someone,and a day to love someone - but it takes a lifetime to forget someone. // 迷上一个人只需要一分钟，喜欢上某人需要一小时，爱上某人则要一天，忘记某人却要一辈子的事情。 We all have moments of desperation. But if we can face them head on, that’s when we find out just how strong we really are.// 我们都有绝望的时候，只有在勇敢面对时，才知道自己有多坚强。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>frase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lead in开班笔记]]></title>
    <url>%2F20190106.html</url>
    <content type="text"><![CDATA[Lead in开班笔记总结形容词动词名词 可数名词才有单复数变化，不可数名词一般只有单数形式，没有复数形式。物质名词和抽象名词借助单位词表示一定的数量,如：a cup of tea, a loaf of bread。 有些物质和抽象名词变为复数后意义就不一样了，如：air &gt; airs （神气）, good &gt; goods (商品), time &gt; times (时代）等。 规则变化 规则 单数变复数方式 例子 一般情况 直接加s map &gt; maps, car &gt; cars 以s,x,ch,sh 直接加es bus &gt; buses, box &gt; boxes 以y结尾 辅音+y结尾为i加es,元音直接s boy &gt; boys, baby &gt; babies 以f或fe结尾 变f／fe为ves wife &gt; wives, leaf &gt; leaves 以o结尾 有生命的加es，否则加s radio &gt; radios, hero &gt; heroes 特例 zero –&gt; zero(e)s. // 可加可不加 以y结尾的专有名词，若在某些特殊情况下需要用复数形式，通常直接加s。 不规则变化 规则 例子 改变单数名词中的元音字母 foot &gt; feet, tooth &gt; teeth 在词尾加-en 或 -ren child &gt; children 变man为men man &gt; men 单复数同形 series &gt; series 名称 总称（谓语用复数） 一个人 两个人 中国人 the Chinese a Chinese two Chinese 日本人 the Japanese a Japanese two Japanses 法国人 the French a Frenchman two Frenchmen 英国人 the English an Englishman two Englishmen 澳大利亚人 the Australians an Australian two Australians 德国人 the Germans a German two Germans 美国人 the Americans an American two Americans 俄国人 the Russians a Russian two Russians 复合词 变化方式 例子 变中心词 a son-in-low &gt; a sons-in-law 在最后加s a grown-up &gt; a grown-ups 前后名词变 woman doctor &gt; women doctors boy/girl在前，变后面词 a boy student &gt; a boy &gt; students 少数名词，单复数同形 sheep, people 名词所有格 名称 例子 解释 ‘s Tom’ pens the fox’s tail.各自拥有的Lily’s and Lucy’s root.共同拥有的 主要用于人或动物等有生命的名词词尾，有时用于时间、距离、国家、城市等。 of a photo of the family 表示无生命的名词的所有关系 双重 a photo of mime 由’s和of一起构成的即是双重所有格 句子种类陈述句 主－谓－宾 主－系－表 疑问句封闭式 Yes/No 人称代词基础版 第一人称 第二人称 第三人称 单数 I You She/He/It 复数 We You They 例子 肯定句 否定句 一般疑问句 I I play I don’t play Do you play? You You help You don’t help Do you help? He He answers He does not answer Does he answer? She She sings She does not sing Does she sing? It It rains It does not rain Does it rain? We We dream We does not dream Do we dream? You You read You does not read Do you read? They They work They don’t work Do they work? 123456789101112笔记：// 一般陈述句转一般疑问句在动词前加Do(第三人称单数用Does, 非三单用Do） not，其他的照搬。（加s/es，变y为i加es）// 第三人称单数的动词后要加s，非三单的动词为原型。// 西洋乐器动词前面加the， 运动项目的动词前不加the1. 为什么It rains后面加s，而It does not rain的rain不加s。 答： 一个三单的句子，动词已经加s了，后面的就不加s。2. 需要注意的如：My best friend seldom studies. 这个主要看friend这个词，friend是第三人称单数，所以study要变形为studies（加s）。3. He answers. 第三人单数加s？？？？？4. Do you play? 为什么不是Do i play? 答：第一人称转第二人称疑问句时，要将i变为you5. He has a bath every day. 转为： He doesn&apos;t have bath every day. 注意：has的原型为have， 不能照搬为has。 人称代词加强版 人称代词 主格 宾格 形容词性物主代词 名词性物主代词 第一人称单数 I Me My Mine 第二人称单数 You You Your Yours 第三人称单数 He/She/It Him/Her/It His/Her/Its His/Hers/Its 第一人称复数 We Us Our Ours 第二人称复数 You You Your Yours 第三人称复数 They Them Their Theirs 12// 名词性物主代词 ＝ 形容词物主代词 ＋ 名词// 形容词物主代词 ＝ 形容词 开放性 wh开头12345What is your name? // 你叫什么名字？Where do you live in? // 你住在那里？Who do you work for? // 你为谁工作When do you play basketball. // 你什么时候打篮球When do he plays basketball. // 他什么时候打篮球 单词记忆]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>englishLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker模拟集群并进行代码同步功能的练习记录]]></title>
    <url>%2F20181228.html</url>
    <content type="text"><![CDATA[多个服务器同步的需求，利用rsync就可以实现。线上正式环境中无法进行测试，因此只能在本地进行测试，测试通过之后才可以在线上进行运行。虚拟机和docker我就不犹豫的选择了docker。看了下docker的文档，pull了ubuntu的进行模拟测试。 dockerdocker Toolbox 更改镜像源12345678910111213// 临时处理docker-machine ssh default // 先进入虚拟机，default 是默认的虚拟机名称sudo vi /var/lib/boot2docker/profile // 编辑这个文件，添加镜像源 --registry-mirror https://registry.docker-cn.comsudo /etc/init.d/docker restart // 重启 docker 进程exit // 退出虚拟机docker info // 看一下镜像源是否设置成功（是否有刚刚设置的 --registry-mirror 这一行）docker pull nginx // 现在可以愉快地拉取`nginx`镜像了// 永久解决修改启动脚本 start.sh 注释掉 yes | &quot;$&#123;DOCKER_MACHINE&#125;&quot; regenerate-certs &quot;$&#123;VM&#125;&quot;if [ &quot;$&#123;VM_STATUS&#125;&quot; != &quot;Running&quot; ]; then &quot;$&#123;DOCKER_MACHINE&#125;&quot; start &quot;$&#123;VM&#125;&quot; # yes | &quot;$&#123;DOCKER_MACHINE&#125;&quot; regenerate-certs &quot;$&#123;VM&#125;&quot;fi docker 构建脚本1234567891011121314151617181920212223242526272829FROM ubuntu:18.04# 签名MAINTAINER ln &quot;1073825890@qq.com&quot;# 添加本地jdk到服务器ADD jdk-8u191-linux-x64.tar /usr/local# 添加本地tomcat到服务器ADD apache-tomcat-8.5.37.tar.gz /usr/local# 添加项目到tomcat的webapps文件中ADD dpm.war /usr/local/apache-tomcat-8.5.37/webapps# ADD时自动解压了，否则需要解压#RUN tar -xzvf /usr/local/jdk-8u191#RUN rm /usr/local/jdk-8u191-linux-x64.tar#环境变量ENV JAVA_HOME /usr/lib/jvm/java-8-oracle/ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV PATH $PATH:$JAVA_HOME/bin# 设置中文ENV LANG C.UTF-8RUN mkdir -p /usr/lib/jvm \ &amp;&amp; mv /usr/local/jdk1.8.0_191/ /usr/lib/jvm/java-8-oracle/ \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install net-tools -y \ &amp;&amp; apt-get install curl -y \ &amp;&amp; apt-get install vim -y \ &amp;&amp; apt-get install rsync -y \ &amp;&amp; apt-get install openssh-server -y \ &amp;&amp; echo &quot;PermitRootLogin yes&quot; &gt;&gt; /etc/ssh/sshd_config \ &amp;&amp; echo &quot;Port 8000&quot; &gt;&gt; /etc/ssh/sshd_config \# &amp;&amp; sudo /etc/init.d/ssh stop &amp;&amp; sudo /etc/init.d/ssh start docker常用命令123456789101112docker build -t java:image . // 用docker脚本进行构建项目docker image ls // 查看镜像docker run --name=application001 -p 8888:8080 -itd ab // 将本地的8888端口映射到docker应用的8080端口以交互模式重新分配一个伪输入终端在后台运行容器docker exec -it ab /bin/bash // 进入应用的命令行页面docker stop ab // 停止应用 ab为ID或名词docker start ab // 启动应用docker rm ab // 删除未运行的应用docker image rm ab // 删除镜像， 删除镜像时需要删除应用，删除应用时需要停止应用docker inspect mycat // 检查docker运行的容器iptables -t nat -A docker -p tcp --dport 2222 -j DNAT --to-destination 172.17.0.2:22 // 把本地的2222映射到172.17.0.2的22端口上面。docker port id // 查看映射端口， 映射的端口直接用127.0.0.1访问 通过构建docker &gt; 查看镜像 &gt; 运行应用 &gt; 进入ubuntu命令行完成整个构建过程。强大的docker使用就这么简单的几步就把应用启动起来了。运行的时候可以用不同的端口运行多个应用。 rsync同步代码 rsync服务端需要安装sshpass、ssh、rsync才能进行同步 脚本 123456789101112131415161718192021222324252627282930313233#/bin/bash# 当前服务器项目绝对路径fromPath=/usr/local/apache-tomcat-8.5.37/webapps/dpm/WEB-INF/classes/templates/# tomcat里面的相对路径toPath=/webapps/dpm/WEB-INF/classes/templates# 依次为：IP 端口号 TOMCAT路径 SSH密码 登陆用户名。 多个服务器用如：(&quot;172.17.0.2 8000 /usr/local/apache-tomcat-8.5.37 123456&quot; &quot;172.17.0.2 8000 /usr/local/apache-tomcat-8.5.37 123456&quot;)注意中间空格隔开。 创建的是一个shell的二维数组servers=(&quot;172.17.0.2 8000 /usr/local/apache-tomcat-8.5.37 123456 root&quot;)currentDate=`date &quot;+%Y-%m-%d %H:%M:%S&quot;`input=$1rsyncFun()&#123; echo &quot;$&#123;currentDate&#125; INFO:rsync start !!!&quot; for key in $&#123;!servers[@]&#125; do server=($&#123;servers[$key]&#125;) rsync -e &quot;sshpass -p $&#123;server[3]&#125; ssh -p $&#123;server[1]&#125;&quot; -avH $&#123;fromPath&#125; $&#123;server[4]&#125;@$&#123;server[0]&#125;:$&#123;server[2]&#125;$&#123;toPath&#125; if [ -n &quot;$&#123;input&#125;&quot; ] then # 注意tomcat的bin目录下setclasspath.sh文件里面的JAVA_HOME和JRE_HOME是否正常.如&gt;果报错需要在if上方增加JAVA_HOME=/usr/lib/jvm/java-8-oracle和JRE_HOME=/usr/lib/jvm/java-8-oracle/jre sshpass -p $&#123;server[3]&#125; ssh -p $&#123;server[1]&#125; $&#123;server[4]&#125;@$&#123;server[0]&#125; &quot;sh $&#123;server[2]&#125;/bin/shutdown.sh&quot; sshpass -p $&#123;server[3]&#125; ssh -p $&#123;server[1]&#125; $&#123;server[4]&#125;@$&#123;server[0]&#125; &quot;sh $&#123;server[2]&#125;/bin/startup.sh&quot; fi done&#125;endDate=`date &quot;+%Y-%m-%d %H:%M:%S&quot;`timeFun()&#123; startTime=`date -d &quot;$currentDate&quot; +%s` entTime=`date -d &quot;$endDate&quot; +%s` return $(($entTime-$startTime))&#125;rsyncFuntimeFunecho &quot;$&#123;endDate&#125; INFO:rsync success!!! $?&quot; 运行的时候直接用bash fileName.sh进行启动，如果用sh fileName.sh启动的话，会报错。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux docker rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归类记忆单词]]></title>
    <url>%2F20181231.html</url>
    <content type="text"><![CDATA[数字 1~10 one two three four five six seven eight nine ten 11~19 eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen 20~100 twenty thirty forty fifty sixty seventy eighty ninety hundred 第1～第10 first second third fourth fifth sixth seventh eighth ninth tenth 第11～第20 eleventh twelfth thirteenth fourteenth fifteenth sixteenth seventeenth eighteenth nineteenth twenty 第30～第100 thirtieth fortieth fiftith Sixtieth Seventieth Eightieth Ninetieth Ninetieth 21: twenty-one, 第21: the twenty-first 星期和月份 星期一 星期二 星期三 星期四 星期五 星期六 星期天 monday tuesday wedensday thursday friday saturday sunday 一月 二月 三月 四月 五月 六月 january february march april may june 七月 八月 九月 十月 十一月 十二月 july august septemter october november december 名词 &gt; 形容词 &gt; 动词 &gt; 副词(频度) &gt; 场所 &gt; 句子 名词 客厅 living room / sitting room 厕所 bathroom / rest room 厨房 kitchen 餐厅 dinning room 卧室 bedroom / second lie 阳台 balcony 书房 study room 茶几 eat table 形容词 大 big/large-sized 中等大小 medium-sized 小 small-sized 宽敞 spacious 昏暗 dark ／ din 新 new 旧 old 明亮 bright 拥挤 narrow 动词 居住 watch TV 泡茶 make eat 喝茶 drink eat 吹牛 brag / talk horse / have a chat 玩电脑游戏 play computer games 看新闻 read news 洗衣服 wash clothes / do the laundany 洗碗筷 wash bowl 洗菜 wash food 做饭 make food / cook meals 洗脸 wash face 刷牙 brush teeth 洗澡 take a bath 频度副词(主语跟动词之间) usually 常常 often / frequently seldom 有时 sometimes 偶尔 once in a while never 从来不 我居住在中套户型的公寓里，公寓里面有三个房间，我的客厅很大很明亮，我经常晚上和我老妈在客厅看电视。 I live in a medium-sized apartment, there are three rooms in my apartment,my living room is large and bright, I often watch TV with my mom in the evening. I live in a small dorm. there are four rooms in my dorm, my living room is bright and clean. I only sleep every day.123456789英语语句 句子结构－主谓宾， 主系表）there be (什么地方有什么东西)！就近原则场所内的物品基本表述－出动作This is my bedroom, there is computer is on the desk.I always watch movie on my computer.电器： turn on 打开, turn off 关闭 wash^洗 clothes 衣服 bowl 碗 socks 袜子 car 汽车 hair 头发 hand 手 123456789101112131415161718192021222324252627282930313233343536373839404142washing clothes. // 洗衣服I&apos;m washing clothes. // 我洗衣服 I want to wash my clothes. // 我要洗衣服 现在时I will wash my clothes right away. // 我马上洗衣服 一般将来时I will wash my clothes tomorrow. // 我明天洗衣服 一般将来时I washed clothes yesterday. // 我昨天洗衣服 一般过去时do the washing up. // 洗碗I&apos;m do the washing up. // 我洗碗I want to wash the dishes // 我要洗碗I will wash the dishes right away. // 我马上洗碗I will wash the dishes tomorrow. // 我明天洗碗I washed the dishes yesterday. // 我昨天洗碗washing socks // 洗袜子I&apos;m washing socks. // 我洗碗I want to wash my socks. // 我要洗袜子I will wash my socks right away. // 我马上洗袜子I will wash my socks tomorrow. // 我明天洗袜子I washed clothes yesterday. // 我昨天洗袜子washing the car. // 洗汽车I wash the car. // 我洗车I want to wash the car. // 我要洗车I am washing the car right away. // 我马上洗车I will wash the car tomorrow. // 我明天要洗车I washed the car yesterday. // 我昨天洗车washing hair. // 洗头发I wash my hair. // 我洗头I want to my hair. // 我要洗头I will wash my hair right away. // 我马上洗头I will wash my hair tomorrow. // 我明天洗头I washed my hair yesterday. // 我昨天洗头washing hands. // 洗手I wash my hands. // 我洗手I want to wash my hands. // 我要洗手I will wash my hands right away. // 我马上洗手I will wash my hands tomorrow. // 我明天洗手I washed my hands yesterday. // 我昨天洗手 总结百度的动词变换方式（昨天干了什么……一般过去时: 动词＋ed） 直接加ed：work—— worked look——looked 以不发音e结尾的单词，直接加d：live ——lived hope——hoped use——used 以辅音字母+y结尾的，变y为i加ed：study—— studied carry——carried worry——worried 以重读闭音节结尾的，双写最后的辅音字母+ed：stop—— stopped plan——planned重读闭音节体现形式为辅-元-辅结构，例如nod,n为辅音，o为元音，d为辅音。 以ic结尾的动词，要把ic变成ick再加ed，如picnic→picnicked，traffic→trafficked 不规则变化的动词过去式：have—had are—were get—got say—said feel—felt do/does—did is—was go—wentdrink–drank eat–ate bring—-brought think—-thought buy—-bought catch—- caught teach —- taught sit—-sat wear—-wore cut—-cut sweep—-swept sleep——slept become—-became 以辅元辅结尾的加d 明天干什么……一般将来时: will + 动词 颜色 red 红色 green 绿色 purple 紫色 black 黑色 brown 棕色 bule 蓝色 yellow 黄色 white 白色 pink 粉红色 body body 身体 eye 眼睛 ear 耳朵 hand 手 foot 脚 tummy 胃 face 脸 nose 鼻子 mouth 嘴 hair 头发 lash 睫毛 ass 屁股 https://www.bilibili.com/video/av15390641/?p=4 第8节到10:58地方]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>englishLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The fifth week of English learning]]></title>
    <url>%2F20181217.html</url>
    <content type="text"><![CDATA[星期五单词(归类记忆) body 身体 eye 眼睛 ear 耳朵 hand 手 foot 脚 tummy 胃 face 脸 nose 鼻子 mouth 嘴 hair 头发 lash 睫毛 ass 屁股 星期三(初级英语学习方法 Lead-ing) 训练营学习内容 词性＋记忆 句子成分和结构 常见句子种类 基本实用时态－一般时 基本实用时态－景象 精讲精练－全盘大复习 词性＋记忆单词方法 名词 第一位， 动作给予 动词 形容词 I 用am 第三人称单数用is 其他用are 星期一 winter 冬季 drum 击鼓 listen 倾听 music 音乐 piano 钢琴 come 来 read 读 love 爱 plan 飞机 ship 船 星期一 together 一起 play 玩 lion 狮子 like 喜欢 ping-pong 兵乓 football 足球 clothes 衣服 put on 穿上 sock 袜子 swim 游泳 星期四 get up 起床 party 聚会 trousers 裤子 dress 连衣裙 T-shirt t桖衫 favourite 特别喜欢的 really 真的 tomato 番茄 fruit 水果 milk 牛奶 句子成份（常用的五种基本句型） 《主语＋谓语》；《主语＋系动词＋表语》；《主语＋谓语＋宾语》；《主语＋谓语＋间接宾语＋直接宾语》；《主语＋谓语＋宾语＋宾语补足语》； 主语＋谓语： 特点：句子的谓语动词都能表达完整的意思。这类动词叫做不及物动词，后面可以跟副词、介词短语、状语从句等。 12345The moon ｜ rose. // 月亮升起The sun ｜ was shining. // 太阳照耀The pen | writes smoothly. // 这支笔书写流利 主语 ＋ 系动词 ＋ 表语 特点：句子谓语动词都不能表达一个完整的意思，必须加上一个表明主语身份或状态的表语构成复合谓语，才能表达完整的意思。 123This | is | an English-Chinese dictionary; //这是本英汉词典。He | is growing | tall and strong; // 他长的又高又壮 主语 ＋ 谓语 ＋ 宾语 谓语动词都具有实义，都是主语产生的动作，但不能表达完整的意思，必须跟一个宾语，即动作的承受者，才能使意思完整。 12345Who ｜ knows ｜ the answer? // 谁知道答案 He | enjoys | reading; // 他喜欢看书I | want | to have a cup of tea; // 我想喝杯茶 主语 ＋ 谓语 ＋ 间宾 ＋直宾 有些及物动词有两个宾语。这两个宾语通常一个指人，为间接宾语。一个指物，为直接宾语。间接宾语一般位于直接宾语之前。一般顺序：动词 ＋ 间接宾语 ＋ 直接宾语 123456789I | gave | my car | a wash. // 我洗了我的车He | showed | me | how to run the machine. // 他教我开机器 ``` #### 主语 ＋ 谓语 ＋ 宾语 ＋ 补语- 动词虽然是及物动词，但是只跟一个宾语还不能表达完整的意思，必须加一个补充成份来补足宾语，才能使意思完整。 We | saw | him | out. // 我们送他出去。 He | asked | me | to come back soon. // 他要我早点回来。 `]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>englishLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目集群，实现单个服务器操作其余服务器自动同步。]]></title>
    <url>%2F20181211.html</url>
    <content type="text"><![CDATA[原因项目是一个分布式集群的项目，一个项目运行在多个tomcat服务器上面。功能需要改动，如果手动管理代码，是一件很容易出现操作失误导致项目代码同步不一致的情况。 实现目标 在一个地方操作，其余服务器中的代码自动同步。 支持回滚操作，如果同步之后的代码有问题，立马回滚到之前的版本（不影响线上操作）。 实现思路方案一：git ＋ shell（svn和git的部署方式思路一致） git是程序员常用的代码版本控制工具，比较重要的功能就是分支和版本，回退到之前的版本是一件很很容易的事情。第一种方式可以利用git的版本机制。 用一台服务器A专门管理代码，并创建git仓库。 在这台服务器A上面用maven进行代码编译生成.class文件。（非maven管理的项目，可以在本地编译成功后上传到git仓库） 在其他需要同步的服务器上面clone服务器A上面的代码。 在其他服务器上面创建同步脚本和回退脚本。 同步脚本： 拉取最新代码 关闭tomcat服务器 启动tomcat服务器 如果代码出现问题的回退脚本: 关闭tomcat服务器 代码回退 启动tomcat 用工具远程执行脚本。如果配置了ssh免密码登陆，可以用：ssh user@remoteNode “sh /home/sync.sh” 来执行远程脚本。也可以在服务器A上面写一个执行多个服务器远程命令的命令脚本。 缺点：每台子服务器都要部署svn或git 方案二: jenkins + rsync + git/svn 环境: ssh, rsync, git/svn 安装ssh： apt-get install openssh-server rsync -y ssh启动：/etc/init.d/ssh start 直接用rsync的ssh命令同步： rsync -e “ssh -p 8000” -avH /home root@172.17.0.2:/home 每次执行的时候都需要输入密码， 可以安装sshpass在脚本中写入密码实现不输入密码自动同步（在执行的命令前加sshpass -p password即可）。或者让两台服务器的ssh互信，实现免密码远程执行ssh命令（）。 还有一种通过daemon方式通过tcp同步的，需要写配置文件，没有实现出来。 jenkins+svn+rsync+php_一键自动化部署可持续化集成服务器集群项目_支持回滚 这个写的比较详细，只是语言是php的，换成java的语言应该影响不大。 方案三：rsync + svn/git + svn上传class文件 思路：找一台分发服务器（安装svn，rsync）或者本地电脑代替分发服务器，开发者将代码提交至svn之后，分发服务器进行拉取代码之后，即进行测试环境和生产环境的代码的发布（利用rsync写脚本进行代码增量同步，可同步至多台服务器）。需要注意的就是非maven环境的代码编译（如果svn上传class文件，负担就是svn占用空间大）。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The first month of English learning]]></title>
    <url>%2F20181119.html</url>
    <content type="text"><![CDATA[总结句子成份 主、谓、宾、表、定、状、补 名称 描述 充当者 例子 位置 主语《句子最主要的》 需要描述的事物或者对象，全句诉说的对象 名词、代词、数词、短语 I^主语 will drink water 一般句子开头 谓语《主语的行为》 表示主语的行为或状态，对主句加以称述 be动词、行为动词(跑、动等实际动作意义的词) I will^谓语 drink water 一般主语之后 宾语《谓语行为的承受》 动作承受的对象就是宾语 名词、代词、数词构成 我敲打了电视。“电视”就是宾语 动词、谓语后面 表语《表明主语特征》 表明主语的身份或者特征。 名词、代词、数词、介词短语、副词 This table^表语 is long. (这个桌子是长的。) 放在be动词和系动词的后面。 定语《给名词等定位》 修饰名词或代词（即在汉语里的……的），一般起描述作用 形容词或者相当于形容词的短语或从句担任 优秀的人。“优秀的”就是定语 名词前 状语《形容词等的状态》 修饰动词，形容词或副词，有的修饰全句，用于说明地点，时间，方式，程度，原因，目的，结果，条件，让步等 副词 I often^状语 write to him. (我常给他写信。) 不定 宾语补足语（宾补）《对宾语的补充》 就是对宾语的描述（有时如果没有宾语补足语，句子就不完整） (定语） 主语 （状语） 谓语 （定语） 宾语 （状语） 如：(The tall) boy (often) go (to the big) zoo. &nbsp;&nbsp;// 这个高大的男孩经常去大动物园。 词性 名称 描述 分类 常见 简写 名词 表示人或者事物的名称 可数和不可数 toy 玩具，head 头 n 代词 代替名词、数词、形容词（人称代词） 单数、复数 I, you, it pron 形容词 用来修饰名词、表示人或事物的特征 litte 小的、big 大的 adv 副词 表示行为或状态特征的词 adv 动词 表示动作或状态 look 看，know 认识 v 数词 表示数量或者顺序的词 one、 two num 冠词 说明名词所指的范围 a、an、the art 介词 说明它与别的词之间的关系，时间介词 in， down prep 连词 逻辑关系词，表示人或事物的名称 if、but conj 感叹词 语气词，代替名词，数词，形容词等 oh、hi int 第四周 Fourthly week of English learning星期一单词 toy 玩具 n under 在…之下 prep in 在…里 prep on 在…上 prep nurse 护士 n hat 帽子 n pupil 护士 n policeman 警察 n doctor 医生 n driver 医生 n 星期二单词 nose 鼻子 touch 触摸 head 头 tree 树 fish 鱼 know 知道 bear 熊 at 在 look 看 bed 床 星期三单词 cow 奶牛 baby 宝贝 feet 脚 hand 手 leg 腿 body 身体 eye 眼睛 mouth 嘴巴 ear 耳朵 face 脸 星期四 snake 蛇 little 少的 big 大的 fat 肥胖的 thin 瘦的 egg 蛋 chicken 鸡肉 duck 鸭 farm 农场 pig 猪 星期五 cute 宝贝 tiger 老虎 tall 高大的 giraffe 长颈鹿 long 长的 zoo 动物园 go 走 elephant 大象 small 小的 short 短的 星期天(句子的成份)主语 位置：句子开头 充当者：名词、代词、数词、短语。 描述：需要描述的事物或者对象。 例子：I^主语 will drink water. // 我要喝水的“我”就是主语 谓语 位置：主语之后 描述：描述表示主语的动作或状态。 充当者：be动词（am,is,are）、行为动词（跑、动等实际动作意义的词） 例子：I will^谓语 drink water. // 我要喝水的“要”就是谓语 表语 位置：放在be动词（与感觉有关的东西。look、smell等）和系动词（包括be动词，表示状态变化的动词）的后面。 描述：表明主语的身份或者特征。 充当者：名词、代词、数词、介词短语、副词 例子： 宾语 位置：动词后面、谓语后面。 描述：动作承受的对象就是宾语 充当者：名词、代词、数词构成。 例子：我敲打了电视。“电视”就是宾语。 宾语补足语（宾补） 位置：宾语的后面。 描述：就是对宾语的描述（有时如果没有宾语补足语，句子就不完整）。 充当者： 例子： 定语 位置：名词前。 描述：修饰名词或代词（即在汉语里的……的），一般起描述作用。 例子：优秀的人。“优秀的”就是定语 状语 位置：不定（开头，中间，末尾都可以） 描述：修饰动词，形容词或副词，有的修饰全句，用于说明地点，时间，方式，程度，原因，目的，结果，条件，让步等。 例子： 第三周 Thirdly week of English learning星期一笔记 看 123456789look // 不看内容， look at（小心）／ look out （小心）／ look after（照顾）， 不看内容whatch // 有思想的看，watch＋内容（watch TV）,有动作的。read // read book(看书)／ newspaper／mind **mind reader**see // 看到实质，会面。见到一个朋友。看到一只狗。see sb doing。see tv（想看电视）meet // 接近see meet-see-visit(参观)。 visit＋place 听 123456listen //不听内容。listen-lookhear //听见有实质的内容。 hear-watch/read。hear from sb/n-receive // 收到来信，收取sound // 声音 sounds good(听起来很棒) 拿 123456789101112take // take up (占据)，take away(带走), take off(脱掉，起飞),拿起来pick // pick up(接送某人)，pick out(挑出来)get // get up （起床）， get out(滚)，get on ， get down，get away from(离某人或某物远) ，get ingrab // grab sth（抢夺）／sbcarry //挑、抗。carry on （坚持前行），carry out(执行)hold // hold a meeting(举办)， be held in（在哪里举办什么内容） 被动语态 Be held in 1234567891011121314Be + Ved2 The woman killed a dog last night.The dog is killed by the woman last night.The school published some English books last summer.Some English books were published by the school.Be - vingshe is reading a book.Be - vedThe book is read by her. 单词 four 四 three 三 two 二 one 一 box 盒子 house 房子 monster 怪物 monkey 猴子 kite 风筝 crayon 蜡笔 星期三单词 ball 球 pink 粉色 ten 10 nine 9 eight 8 seven 7 six 6 five 5 say 说 count 计算 星期四 has 他的 friend 朋友 grandpa 爷爷 mother 妈妈 father 爸爸 but 但是 birthday 生日 happy 快乐 brown 棕色 many 许多 星期天（词性分类）词性分类名词(noun,n) 描述：表示人或者事物的名称 分类： 可数名词(countable noun,c)（有单数变复数的变化[plural,pl]，apple – apples） 不可数名词(uncountable noun,u)， 没有变化形式。 常见 toy 玩具 pupil 小学生 driver 驾驶员 doctor 医生 head 头 tree 树 bear 熊 baby 宝贝 feet 脚 body 身体 eye 眼睛 face 脸 hat 帽子 policeman 警察 nurse 护士 nose 鼻子 fish 树 bed 床 cow 奶牛 mouth 嘴 ear 耳朵 代词 (pronoun,pron) 描述：代替名词、数词、形容词(人称代词) 常见 第一人称、我 第二人称、你 第三人称、他她它 单数 I you It 复数 we You They 形容词(adjective,adj) 描述：用来修饰名词、表示人或事物的特征 位置：放在名词前面修饰名词 常见：little 小的，fat 肥胖的，thin 瘦的，big 大的 副词(adverb,adv) 描述：表示行为或状态特征的词 位置：修饰动词或者形容词 动词(verb,v) 描述：表示动作或者状态 位置：动作或者状态的词 touch 触摸 look 看 know 认识 数词(numeral,num) 描述：表示数量或顺序的词语 冠词(article,art) 描述：帮忙说明名词名词所指的范围 位置：用在名词前 共三个 an a 不定冠词 一、一个 the 定冠词 这、这个 中文样式：我今天买了一支^不定冠词 笔，这^定冠词 支笔很好看 介词(preposition, prep) 位置：用在名词或者代词前。 描述：说明它与别的词之间的关系，时间介词，方位介词 常见： in 在…离,on 在 … 上,down,up,under 在 … 之下，at 在 连词(conjunction,conj) 描述：逻辑关系词,表示人或事物的名称。 常见：if,because,but 感叹词(interjection,int) 描述：语气词，代替代替名词，数词，形容词等。 常见：oh,hello,hi,yeah 第二周 Second week of English learning星期三单词 up 向上 panda 熊猫 stand 站立 down 向下 sit 坐 girl 女孩 boy 男孩 bird 鸟 please 请 name 名字 星期四单词 red 红色 door 门 window 窗口 colour 颜色 open 打开 point 点 yellow 黄色 desk 桌子 chair 椅子 blue 蓝色 星期五单词 school 学校 teacher 老师 orange 橘子 look 看 cat 猫 dog 狗 white 白色 black黑色 how 怎么 green 绿色 星期六 pencilcase 文具盒 eraser 橡皮擦 ruler 尺子 pencil 铅笔 pen 钢笔 book 书 schoolbag 学校 bag 包 child 孩子 classroom 教师 音标 音标分为元音、辅音。 辅音就是通过辅助的发音，就可以是音标。如：B [bi:]，读的时候就是b和i连在一起读就是B了，单独的b就是B的音标读法。 J: zh /dʒ/ ｝ 红色标记的辅音是比较特殊的辅音，读法不一样。 C: ce, cy, ci ｛ /k/ ｝ G: ge, gy, gi ｛ /g/ ｝ H: sh, ch, gh ｛ /h/ ｝ 元音就是字母除了辅音之外还有另一个读法的音标。 A , E , I , O , U 星期天 音标技巧提示 θ si ts ci ʃ sh tr chuo tʃ 吃 ð ri dz 资 ʒ 日 dr zhuo dʒ 知 第一周（2018-11-19）First week of English learning星期一单词 run out of 用完 since 从…以来 collect 收集 shell 外壳 several 几个 marathon 马拉松 skate 溜冰 pair 一对 raise 举起 russian 俄罗斯 several 若干 stamp 邮票 kite 风筝 monster 怪物 emperor 皇帝 笔记123456789101112It&apos;s pink // 它是粉红色It&apos;s red // 它是红色It&apos;s white // 它是白色It&apos;s yellow // 它是黄色It&apos;s gray // 它是灰色It&apos;s orange // 它是橘黄色It&apos;s brown // 它是棕色It&apos;s blue // 它是蓝色It&apos;s black // 它是黑色It&apos;s green // 它是绿色It&apos;s purple // 它是紫色 复习 chair椅子 eraser 橡皮擦 book 书 pen 钢笔 ruler 尺子 bag书包 desk 桌子 pencil 铅笔 星期二 particularly 特别地 capital 首都 writer 作家 extra 额外的 thousand 一千 topic 主题 jewith 犹太人 coin 硬币 european 欧洲人 globe 球体 common 通用 foreigner 外国人 by the way 顺便说一下 cake 蛋糕 anyone 任何人 难记的单词：particularly 特别地。 笔记123456They&apos;re notebook // 它们是笔记本 They&apos;re calculators // 它们是计算器They&apos;re markers // 它们是记号笔单数用It is 简写为： It&apos;s复数用They are 简写为: They&apos;re 星期三单词 clothing 衣服 bring 带来 waitress 作家 poster 海报 the Olympic Games 奥林匹克 task 任务 dish 盘子 right away 立即 yard 院 quite 相当 turn down 拒绝 not at all 一点也不 mind 头脑 miss 想念 certain 肯定的 笔记1234567who&apos;s he? // 他是谁？who&apos;s she? // 她是谁？It&apos;s he old? // 它是老的Yes, he is. // 是的，他是It&apos;s yang. // 她是年轻的 No, she is not. // 不她不是It&apos;s he short // 他是小的 星期四单词 cut 剪 line 行 door 门 perhaps 也许 polite 客气的 annoyed 愤怒的 wait the line 排队等候 annoy 烦恼的 solution 解答 笔记1234Is it a book? // 它是书？Is it a ball? Is it little? // 他是小的？Is it a doll? // 它是一个娃娃？ 星期五单词 europe 欧洲人 asian 亚洲人 behavior 行为 normal 正确的 etiquette 礼仪 term 学期 voice 语音 keep 保持 cut 剪 public 公众 笔记1234567891011Where is the bag? // 包在那里Where are the books? // 书都在那里are the cars by the bag? // 我的汽车都在包里吗？no，they are not？ // 不，它们不在Is the yo-yo on the table? // yo-yo 在桌子下面?Is the doll in the tree? // 玩偶在树下？Is the bag on the table? // 包在桌子上？Are the crayons in the bag? // 蜡笔都在包里？Are the bats by the tree? // 球拍都在树下单数is，复数are 星期六单词 criticize 批评 cigarette 香烟 put out 熄灭 smoke 烟 sneene 喷嚏 sough 咳嗽 allow 允许 impolite 不礼貌的 uncomfortable 不舒服的 in 在…里 笔记123I want fish an milk. // 我要鱼和牛奶Do you want bread? // 你想要面包 星期天 看到字母‘n’，‘m’ 发鼻音。 看到’r’ 发卷舌。看到‘v’咬嘴唇，‘w‘不咬嘴唇 发音。 自然拼读（字母、字母组合）＋音标 字母 音标 典型单词 备注 字母 音标 典型单词 备注 A a /æ/ /ei/ apple 元音 N n /n/ nice 发鼻音 B b /b/ * book O o /o/ /au/ open 元音 C c /k/ * cat P p /p/ * pencil D d /d/ dog Q q /k/ * quit E e /e/ /i/ egg 元音 R r /r/ ruler 卷舌 F f /f/ fish S s /s/ six G g /g/ good T t /t/ * time H h /h/ * head U u / ^ / /ju:/ under 元音 I i /əu/ /ɔ/ in 元音 V v /v/ van 咬嘴唇 J j /dƷ/ jeep W w /w/ want 不咬嘴唇 K k /k/ * kill X x /x/ x L l /l/ like 不发鼻音 Y y /y/ yes M m /m/ money 发鼻音 Z z /z/ zero A a ／æ／ apple ant 元音字母之一。／æ／ ／ei／ B b ／b／ book bag C c ／k／ cat cake can D d ／d／ Dad dead Dog door E e ／e／ bed egg end 五个元音字母之一／e／ ／i／ F f ／f／ fish G g ／g／ good girl game goat green go H h ／h／ hat head hand house I i ／i／ in it ink internet 五个元音字母之一 ／i／ ／e／ J j ／dj／ jam jeep jenny K k ／k／ kill kitten kind take kick kiss kill L l ／l／ like lie land look large little M m ／m／ mother mind morning money monkey mouse N n ／n／ notebook nine notice nice night O o ／o／ octopus on open orange office 备注：五个元音之一。／o／ ／au／ P p ／p／ pay paint picture paper pencil Q q ／k／ quick quit quite Question R r ／r／ [卷舌] Ruler rainy rice right rude S s ／s／ sun six some summer sunday T t ／t／ Table Tall teacher time ten U u |^| [嘴巴两边张] under hug uncle ugly 五个元音字母之一。／^／ ／ju:／ V v ／v／ ［咬嘴唇］ van violin five virus W w ／w／ ［不咬嘴唇］ window walk windy want win X x ／eks／ x Y y ／y／ yellow young yes you Yo-yo Z z ／z／ zero zoo zone zipper A E I O U 元音字母 one two three four five six seven eight nine ten eleven twenty thirteen fourteen fifteen sixteen eventeen eighteen nineteen twenty 总结： 这一周每天背了10个单词，记的单词基本忘记了，一点效果都没有，今天是第一周的最后一天。Amanda老师调整了我背单词的难度，下周从小学的星期三开始。这两天练习上面学习的自然拼读。从零开始，加油！]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>englishLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用js写了一个比较方便的表单验证器]]></title>
    <url>%2F20181114.html</url>
    <content type="text"><![CDATA[一、实现方式 导入jquery 将以下代码复制到html页面中 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt;$(function() &#123; // 调用此方法获取表单是否合法 function checkInputPostData() &#123; var list = $(&quot;.validInputs&quot;) var j = 0 for(var i = 0; i&lt;list.length; i++) &#123; j = j+inputDataValid(list[i]) &#125; if (j == 4) &#123; return false &#125; return true &#125; // 自定义表单效验 gqs function inputDataValid(then) &#123; var th, promt, value, reg th = $(then) promt = th.parent().find(&quot;.Validform_info&quot;)[0] value = th.val() if(value == null || value == &quot;&quot;) &#123; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;+th.attr(&apos;nullmsg&apos;)+&apos;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_right&apos;).addClass(&apos;Validform_wrong&apos;) return false &#125; reg = th.attr(&quot;datatype&quot;) if(!eval(reg).test(value))&#123; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;+th.attr(&apos;errormsg&apos;)+&apos;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_right&apos;).addClass(&apos;Validform_wrong&apos;) return false &#125; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_wrong&apos;).addClass(&apos;Validform_right&apos;) return true &#125;&#125;&lt;/script&gt; input框写入自定义属性 123456789&lt;input id=&quot;name&quot; onblur=&quot;inputDataValid(this)&quot; name=&quot;name&quot; type=&quot;text&quot; class=&quot;span3 validInputs&quot; &lt;!-- 必须要validInputs的class,或者和checkInputPostData函数中的validInputs一致 --&gt; datatype=&quot;/^[a-zA-Z\u4E00-\u9FA5]&#123;1,20&#125;$/&quot; &lt;!-- 正则：用于效验表单 --&gt; value=&quot;123&quot; nullmsg=&quot;此项不能为空&quot; &lt;!-- 表单为空时的提示 --&gt; errormsg=&quot;请填写字母或汉字&quot;/&gt; &lt;!-- 正则效验失败时的提示 --&gt; 在input下创建 1&lt;div class=&quot;Validform_info&quot;&gt;&lt;/div&gt; 注：需要和下面的代码层级一致，如果不一致要注意层级查找（ th.parent().find(“.Validform_info”) ）的更换 二、全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;简单的表单验证器&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/core.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .Validform_right&#123; 正确提示的css &#125; .Validform_wrong&#123; 错误提示的css &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table class=&quot;gritter-with-table&quot; cellspacing=&quot;1&quot;&gt; &lt;tbody id=&quot;tbody&quot;&gt; &lt;tr name=&quot;posts&quot;&gt; &lt;th&gt;姓名：&lt;/th&gt; &lt;td&gt; &lt;input id=&quot;name&quot; onblur=&quot;inputDataValid(this)&quot; name=&quot;name&quot; type=&quot;text&quot; class=&quot;span3 validInputs&quot; datatype=&quot;/^[a-zA-Z\u4E00-\u9FA5]&#123;1,20&#125;$/&quot; value=&quot;123&quot; nullmsg=&quot;此项不能为空&quot; errormsg=&quot;请填写字母或汉字&quot;/&gt; &lt;div class=&quot;Validform_info&quot;&gt;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr name=&quot;posts&quot;&gt; &lt;th&gt;电话：&lt;/th&gt; &lt;td&gt; &lt;input onblur=&quot;inputDataValid(this)&quot; nullmsg=&quot;此项不能为空&quot; value=&quot;1234&quot; datatype=&quot;/^[a-zA-Z\u4E00-\u9FA5]&#123;1,40&#125;$/&quot; placeholder=&quot;例：*********&quot; class=&quot;span3 validInputs&quot; id=&quot;phone&quot; type=&quot;text&quot; name=&quot;phone&quot; &gt; &lt;div class=&quot;Validform_info&quot;&gt;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;script&gt;$(function() &#123; // 调用此方法获取表单是否合法 function checkInputPostData() &#123; var list = $(&quot;.validInputs&quot;) var j = 0 for(var i = 0; i&lt;list.length; i++) &#123; j = j+inputDataValid(list[i]) &#125; if (j == 4) &#123; return false &#125; return true &#125; // 自定义表单效验 gqs function inputDataValid(then) &#123; var th, promt, value, reg th = $(then) promt = th.parent().find(&quot;.Validform_info&quot;)[0] value = th.val() if(value == null || value == &quot;&quot;) &#123; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;+th.attr(&apos;nullmsg&apos;)+&apos;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_right&apos;).addClass(&apos;Validform_wrong&apos;) return false &#125; reg = th.attr(&quot;datatype&quot;) if(!eval(reg).test(value))&#123; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;+th.attr(&apos;errormsg&apos;)+&apos;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_right&apos;).addClass(&apos;Validform_wrong&apos;) return false &#125; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_wrong&apos;).addClass(&apos;Validform_right&apos;) return true &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript jquery form</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看《码农翻身》的一些收获]]></title>
    <url>%2F20181111.html</url>
    <content type="text"><![CDATA[今天是双十一，哪里也没去，早晨10点多就出门了，在新华书店里面呆了一天，在书架中找到了这本书，很容易的就看了进去，这本书用故事的方式描述生涩的代码以及程序。前段时间看的head frist也是比较很容易理解的书籍，自己购买的java并发编程实战看了几页总是无法集中精力看下去，内容很充实，可能一直在家里躺在床上太安逸的看书，导致看着看着就放弃了，希望坚持下去。 这本书学会了一个很重要的做事方式&lt;凡事必先骑上虎背&gt;，在自己做一件事情犹豫不决的时候，想想这句话,在做事情的时候，需要先骑在老虎的背上。和明知山有虎，偏上虎山行差不多。在这种状态下，经常会出现骑虎难下的尴尬情况。只要不恐惧这种情况，那么在这种状态下学习就收获更多的东西。 一、大概的内容书籍用第一人称描述计算机的各个组成如：内存、进程等，和日本的《工作细胞》动漫差不多。从底层描述描述进程、线程、cpu、内存、硬盘等。整本书籍阅读起来相当的有趣，看的时候完全当成一本小说在读，但是读到最后，确实学到很多知识，虽然很多东西都是之前学习过的，但是很多也是自己理解不够透彻的。还是推荐大家可以阅读以下，一方面可以巩固自己的知识，一方面也可以学习一些自己没接触过的东西。 计算机的世界 进程：比如QQ运行，QQ音乐运行，微信运行，都需要一个进程去处理，一个计算机可以有多个进程。进程之间的切换实现了多个程序同时运行的效果。（理解不够透彻，需要完善） 线程：一个进程可以拥有多个线程 cpu：由寄存器和运算器组成，寄存器用来存储数据，运算器负责运算，速度特别快 内存：内存负责把硬盘的数据加载到内存里面，并且各种指令，执行速度一半 硬盘：负责把数据持久化，存储数据，防止断电，执行速度特别慢 汇编语言：比较难理解的语言，负责和底层的二进制（机器语言）打交道 高级语言： 如c、c++、java、python等。用人类方便理解的语言和汇编语言打交道 tcp/ip：只要解决的就是网络传输数据的问题，通过没次发送少量数据拆包，并进行失败重发的功能解决发送大量数据的问题。发送的过程中由多个路由器进行转发到目的地完成。 java帝国 java class : java类主要由java的类加载调用，每个线程都会有一个函数栈（栈祯），用来进行方法调用 JDBC ： 由一个工厂方法实现，封装了各种实现，用于和各种数据库对接，便于数据的持久化，代替的文件存储方法，提高效率。 jsp : java的模版套用mvc的view。用于将html和数据组合生成html页面。freemarker也是类似的，但是freemarker静态的页面也是可以浏览的。 JTA : 在多个数据库之间传送数据，保证数据的事务性。由一个全局事务管理器实现，统一准备和统一提交。失败案例（全局事务管理器出现问题，将无法保存数据的一致性） 消息队列（JMS - java message service）：为了实现分布式项目的数据传递问题。如订单服务器给物流服务器发送订单，物流服务器出现问题，暂时无法接受订单。就可以由一个消息队列处理，有订单了，由订单服务器发送订单到消息队列排队，物流服务器可以随时接收订单，就是物流服务器有事情，也不会影响到订单服务器。 动态代理：可以实现给一个类动态的添加新的行为。动态代理可以实现aop的切面功能。 java注解：注解相当于加强的注释。注解有元注解^(注解的注解)，通过注解可以减少xml文件的编写，只好的方式就是xml和注解配合一起使用。 泛形：泛形就是可以限制一组数据的数据类型。&lt;? extends Object&gt; 的意思就是可以传入继承了对象类的任意对象。 序列化：把java对象编程二进制字节流存储在硬盘上，当然还有一种办法就是把二进制字节流反序列化为java对象。 java程序的锁：在java中synchronized就是同步锁，每个线程需要访问锁里面的内容必须要拿到锁，没有拿到的就需要在线程池里面等待。这个是一个重量级的悲观锁（觉得线程随时都会更改数据）。另一种办法就是乐观锁（认为大部分情况多线程的情况都比较少），可以给数据添加一个版本号，每次更改数据后版本变化。在实现功能的时候，可以把数据获取出来更改之后，在修改的时候对比版本号是否一致，如果不一致则继续重新获取，直到版本号一致为止。这样就减少了同步锁导致的线程在线程里面等待所消耗的资源。 spring DI和IOC、AOP: 在一个大型的项目中日志、事务、登录等功能都会涉及到程序的各个层面，如果统一管理，就回出现大量冗余的代码，而去大量的代码会导致代码的臃肿。想这些经常会出现的代码，可以用模版方法和装饰者模式区封装常用的代码，但是这样很多类都需要实现接口。为了避免这种情况，于是出现了控制反转ioc，和依赖注入di（把类的依赖情况转交给spring容器）。aop利用的java动态代理实现的面向切面编程。 web冲浪 hyperText Transfer Protocol (HTTP) : 超文本传输协议,这里的超文本就是HyperText Markup Language (HTML，一种文本的标记形语言) HTTPS : 在使用HTTP在网上传输HTML的时候是使用的明文，如果中途被截取了，隐私就会被泄露。HTTPS解决了安全性问题，用对称数据加密和非对称数据加密结合解决了网络传输HTML的安全性问题。对称加密利用一个公匙和私匙，公匙加密（所有人都可以知道公私），私匙解密（对应的公私加密的文件只有对应的私匙解密）。解密的私匙是需要双方都持有的，因为双方都需要加密解密，所以在保证安全的情况下把私匙传给对方就需要非对称加密了。非对称加密需要第三方的证书＋签名，才可以完成（非对称加密还需要理解一下）。 SSO : 一个由很多子系统组合在一起的大型项目就需要实现在一个小的项目中登录之后，进入相关的项目就不用再次登录的单点登录功能。实现原理就是利用一个认证中心实现登录，用户首次登录时会获取到认证中心的一个cookie用于存放在浏览器端，浏览器上面存两个cookie，一个是认证中心的cookie一个是当前访问应用的cookie。用户访问另一个应用时，只需要将之前的cookie携带访问应用，后端通过应用验证cookie是否有效即可判断用户是否已经登录。 授权 ： 比如QQ、微信、微博第三方登录等，都是使用的授权登录方法。应用可以通过自己申请的第三方的appid和密匙，获取授权的code，授权code会有超时时间等，通过code可以获得token，最后通过token就可以实现登录逻辑。 负载均衡 ： 多台服务器运行相同的应用，nginx在进行接口转发时均衡的转化，不出现有的服务器严重负载，有的服务器轻松自在。 高可用 ： 当服务器出现故障之后，有备用的服务器顶上去，不会出现无法访问的情况。 tomcat集群：通过多台tomcat服务器实现高可用，由nginx来进行服务转发（实现负载均衡）。 redis集群：通过jedis负责分发tomcat的请求（redis cluster）。 数据库读写分离：由多台数据库实现，一个master数据库可读可写已写为准，多个slave数据库进行只读操作（读时需将数据同步至slave数据库，master出现故障由slave数据库顶替） 代码管理 VCS(Version Controller System): 版本控制系统，svn采取的就是这种方式管理的代码！采用更新，提交的方式进行。 分支，多版本并行: 通过分支实现多版本并行，在代码开发的时候可以有多个版本并行开发，每个人在本地都有一个私有库，每个人都可以有选择性的提交不同版本的代码，最后只需进行合并即可。git就是采用的这种方式。 build: 代码的自动化构建。manven的pom.xml就是可以用build脚本进行自动化构建的一个工具（自动打包、编译、部署）。 其他 声明式编程： SQL语句就是命令式编程（只提供声明，具体实现有系统负责） 命令式编程： 大多数程序员使用的语言都是命令式编程（通过指令告诉计算机怎么做）。 end]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>java code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《java 并发编程实战》笔记]]></title>
    <url>%2F20181109.html</url>
    <content type="text"><![CDATA[最近干了些什么从上个月离职到现在，已经10多天了。这段时间里面，自己都没怎么看书。感觉换了个环境，就变懒散一些了，看书也没能集中精力。最近在研究新的项目，有很多都是之前没有接触过的，这几天下来，收获还是特别多的。希望在以后的工作中学习到更多的东西，多看书，多学习。]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－总结]]></title>
    <url>%2F20181009.html</url>
    <content type="text"><![CDATA[已经将head first一书看完了，应该总结一下这本书学到了些什么，下面就将自己学习的设计模式整理一下，方便自己后期复习，以及简短的描述各个设计模式的定义，以及在哪些方面需要使用到设计模式。 什么是设计模式设计模式就是很多面向对象的开发者，根据自己开发的经验，想出来的一些模式，经过时间的认证和大多数程序员的认同后形成的一种比较好的开发模式。利用这些模式，程序员之间可以有自己的方言，程序之间沟通也更加便捷。也很利于代码的维护和扩展。是一套反复使用、多人知晓、分类遍目的代码设计经验的总结。 模式词汇(23个) 创建型 5个 singleton 单例 builder 生成器（建造者） prototype 原型 abstract factory 抽象工厂 factory method 工厂方法 行为型 11个 template method 模版方法 command 命令 observer 观察者 state 状态 mediator 中介 iterator 迭代器 strategy 策略 interpreter 解释器 chain of responsibility 责任链 memento 备忘录 visitor 访问者 结构型 7个 proxy 代理 decorator 装饰 composite 复合 facade 外观 adapter 适配器 flyweight 享元 bridge 桥接 模式何时用创建型模式 模式名称 何时用 备注 单例 singleton 创建的类只需要一个实例的时候 确保一个类只有一个实例 建造者 builder 需要创建一个复杂对象的时候 由多个简单对象构建为一个复杂对象 原型 prototpye 需要创建许多重复且互不干扰的对象时 通过复制对象实现 抽象工厂 abstract factory 创建一系列产品族时 提供一个创建一系列相互依赖对象的接口 工厂方法 factory method 当一个类的实例需要延迟到子类时 通过简单工厂模式的抽象和推广 行为型模式 模式名称 何时用 备注 模版方法 template method 定义操作算法，可以将一些步骤延迟到子类 可以用钩子实现不改变算法结构的时候改变步骤 命令 command 多个回退操作，宏纪录 通过把请求或操作封装到类中，支持撤销、恢复操作 观察者 observer 在对象之间定义一对多的关系时 依赖它的对象都会收到通知并自动更新，就像微信订阅号 迭代器 iterator 遍历不同类型集合的一种方式 通过访问迭代器接口实现‘下一个’、和’有下一个方法‘ 策略 strategy 客服端可以根据自己的需求进行相应的选择 把一系列的算法分别封装到对应的类中，实现相同接口之后可以相互替换 解释器模式 interpreter 当需要使用一个简单的语言时 将每一个语法规则表示为一个类 访问者 visitor 在封装不是很重要，需要给类添加新的能力时 封装某些结构元素的操作，在不改变数据结构的情况下新增新的操作 中介者 mediator 利用中介者改善类与类之间的过多耦合 利用星型结构改善 备忘录 在需要纪录操作备忘时，捕获类的内部状态 将被记录的状态记录在外部，帮助维护类聚 责任链 chain of responsibility 一个请求需要多个对象处理，形成链条 让对个对象都可以接受请求，就像请假一样 状态 state 在内部状态改变时，进行不同的行为操作 一个状态一个类，改变状态时，对象看这向修改了类 结构型模式 模式名称 何时用 备注 代理 proxy 需要隐藏真实身份时 通过类似黄牛的代理角色去处理 装饰者 decorator 动态的给类添加职责，有别于继承的另外一种选择 通过动态运行时选择不同的具体装饰类，从而实现不同的行为。常见的就是io流 复合 composite 大杂烩，多种模式混合使用 常见的有经典的mvc模式，mvvm模式等 外观模式 facade 接口特别多，比较混乱，需要统一调用时 将各个接口统一在一个类中，调用时只需要调用一次 适配器 adapter 将一个对象转化为另一个对象 就想转换插头，适配不同的插座一样 享元模式 flyweight 共享之前的元对象，减少实例化次数 在相同的对象特别多的时候，通过map存储对象。每次需要新对象时，就去map里面查找，没有则创建 桥接模式 bridge 当出现了两个以上的类别需要组合时 就像多种颜色和多种形状组合一样，两种类别都需要扩展 模式定义与用途创建型模式单例模式 定义：确保一个类只有一个实例，并提供全局访问点 用途：当只需要一个实例的时候 建造者模式 定义：将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 用途：经常被用来创建组合结构 原型模式 定义：通过‘复制’一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们称之为的‘原型’，这个原型是可定制的。 用途：在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象的时候，可以考虑使用原型。 抽象工厂模式 定义：提供一个创建一系列相关或相互依赖对象的接口。 用途：系统中有多个的产品族，而每次只使用一个产品族。用来创建一系列相关或相互依赖对象的接口 工厂方法模式 定义：由子类决定要创建的具体类是那一个 用途：由工厂生产产品，如果用简单工厂模式生产新的产品，就要更改工厂类，违背了开闭原则。工厂方法模式就是将类更工厂化，让扩展更简单。 行为型模式模版方法 定义：在一个方法中定义一个算法的骨架,而将一些步骤延伸到之类中，模版方法使得之类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 用途：一个可共用的模版，在共用的方法中子类可以利用钩子重新定义算法步骤。 命令模式 定义：将请求封装成对象，这可以让你使用不同的请求、队列或者日志请求来参数化其他对象。命令模式也支持撤销操作 用途：将单个的请求封装为对象。 观察者模式 定义：让对象在状态改变时被通知 用途：观察者模式就是相当于公众号一样，你关注公众号就会受到消息，取消就收不到消息，一对多的关系。 迭代器 定义：提供一种方法，顺序访问一个聚合对象中的各个元素，而又不暴露内部的实现。 用途：用来遍历集合中有不同对象的一种统一方式。 策略模式 定义：封装可以交互的行为，并使用委托来决定要使用那一个 用途：策略模式就是通过不同的策略可以给对象组装不同的行为，比如给小猫小狗添加不同的行为等。 解释器模式 定义：提供了评估语言的语法或表达式的方式，这种模式实现了一个表达式接口，该接口解释一个特定的上下文。 用途: 当需要实现一个简单的语言时，可以使用解释器。 访问者模式 定义：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的情况下定义作用于这些元素的新的操作。 用途：当你想要为一个对象的组合增加新的能力，且封装并不重要时，可以使用访问者模式。 中介者模式 定义：用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而时耦合松散，而且可以独立地改变它们之间的交互。 用途：使用中介者模式来集中相关对象之间复杂的沟通和控制方式。常常用来协调相关的GUI组件。 备忘录模式 定义：在不破坏封装的情况下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。 用途：当你需要让对象返回之前的状态，如你的用户请求‘撤销’，就可以使用备忘录模式。常常用来存储状态。 责任链模式 定义：使多个对象都有机会处理请求，从而避免了请求的发送者与接收者之间的耦合关系。将这些对象连成一条链，并沿着一条链传递这请求，直到有对象处理它为止。 用途：当你想让一个以上的对象能有机会处理某个请求的时候，就可以使用责任链模式。 状态模式 定义：允许一个对象在其内部状态发生改变时改变它的行为，对象看起来似乎修改了它的类。又叫状态对象。 用途：在工作流和游戏等类型的软件中经常使用，经常处理一批状态。比如请假流程（主管批准、经理批准、总经理批准） 结构型模式代理模式 定义：为另一个对象提供一个替身或占位符以访问这个对象。 用途：代理常常用来保护目标对象的作用，协调调用者和被调用者，降低了系统的耦合度。 装饰者模式 定义：包装一个对象，并提供新的行为 用途：就像装修房子一样，选择不同的厂商，不同的材料装饰房子。java io流就是使用的装饰模式 复合模式 定义：结合两个或两个以上的模式，组成一个解决方案，解决一再发生的一般性问题。 用途：通过多个模式去解决复杂的问题，实现不同的功能。常见的就是mvc模式 外观模式 定义：提供了一个统一的接口。用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。 用途: 封装一个统一的接口，就像很多插头插在一个大擦板上面，每次使用的时候，只需要按大插板的开关。 适配器模式 定义：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 用途: 就像转换插头一样，转换接口。 享元模式 定义：运用共享技术有效地支持大量细粒度对象的复用，系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次反复使用，由于享元模式对象需要是细粒度对象，所以又叫轻量模式、蝇量模式。 用途：如果想让某个实例能提供很多的虚拟实例，就可以使用享元模式，也叫蝇量模式。 桥接模式 定义：将抽象部分与它的实现部分分离，使它们可以独立的变化 用途：不只改变你的实现，也改变你的抽象，适合使用在跨越多个平台的图形和窗口系统上。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－访问者模式]]></title>
    <url>%2F20181027.html</url>
    <content type="text"><![CDATA[一、理解访问者模式访问者模式定义:封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 个人理解访问者模式就是让不同的访问者可以访问不同的操作。访问者模式在实现过程中可以在不改变数据结构的情况下，添加新的操作，实现开闭原则。 二、代码实现创建电脑访问者 12345678910111213141516171819// 电脑组件访问者public interface ComputerPartVisitor &#123; public void visit(Keyboard k); // 访问键盘 public void visit(Mouse mouse); // 访问鼠标&#125;class ComputerPartDisplayVisitor implements ComputerPartVisitor&#123; @Override public void visit(Keyboard k) &#123; System.out.println(&quot;键盘&quot;); &#125; @Override public void visit(Mouse mouse) &#123; System.out.println(&quot;鼠标&quot;); &#125; &#125; 创建电脑 123456789101112131415161718192021222324252627282930313233// 电脑组件public interface ComputerPart &#123; public void accept(ComputerPartVisitor cpv); // 接受方法&#125;// 键盘class Keyboard implements ComputerPart&#123; @Override public void accept(ComputerPartVisitor cpv) &#123; cpv.visit(this); &#125;&#125;// 鼠标class Mouse implements ComputerPart&#123; @Override public void accept(ComputerPartVisitor cpv) &#123; cpv.visit(this); &#125;&#125;// 电脑class Computer implements ComputerPart&#123; ComputerPart[] parts; public Computer() &#123; // 构造器给parts赋值 parts = new ComputerPart[]&#123;new Mouse(), new Keyboard()&#125;; &#125; @Override public void accept(ComputerPartVisitor cpv) &#123; for(ComputerPart cp : parts) &#123; cp.accept(cpv); &#125; &#125;&#125; main 方法实现 1234public static void main(String[] args) &#123; ComputerPart cp = new Computer(); cp.accept(new ComputerPartDisplayVisitor()); &#125; 运行结果 12鼠标键盘 三、UML类图 四、笔记当你想要为一个对象的组合添加新的能力的时候，而且感觉封装不是很重要的时候，就可以使用访问者模式。 访问者模式的优点： 允许你对组合结构加入新的操作，而无需改变结构本身。 想要加入新的操作，相对容易 访问者所进行的操作，其代码是集中在一起的。 访问者的用途和缺点 在使用访问者模式的时候，会打破组合类的封装。 因为经常性的新增操作，所以对组合结构的改变就更加困难]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－原型模式]]></title>
    <url>%2F20181026.html</url>
    <content type="text"><![CDATA[一、对原型模式的理解原型模式是创建模式的一种，主要通过复制一个实例来创建一个实例，而不是通过新建一个实例。被复制的实例，我们称之为原型，这个原型是可定制的。 二、代码实现创建原型类，实现原型接口 1234567891011121314151617181920// 原型public abstract class Prototype implements Cloneable&#123; public Object clone() throws CloneNotSupportedException&#123; return super.clone(); &#125;&#125;class ConcretePrototype1 extends Prototype&#123; public static int classFlay = 1; // 克隆自身方法 public Object clone() throws CloneNotSupportedException&#123; return (ConcretePrototype1)super.clone(); &#125;&#125;class ConcretePrototype2 extends Prototype&#123; public static int classFlay = 2; // 克隆自身方法 public Object clone() throws CloneNotSupportedException&#123; return (ConcretePrototype2)super.clone(); &#125;&#125; main方法实现 12345678public static void main(String[] args) throws CloneNotSupportedException&#123; Prototype pro = new ConcretePrototype1(); ConcretePrototype1 cp = (ConcretePrototype1)pro.clone(); System.out.println(&quot;标记：&quot;+ cp.classFlay); Prototype pro2 = new ConcretePrototype2(); ConcretePrototype2 cps = (ConcretePrototype2)pro2.clone(); System.out.println(&quot;标记：&quot;+ cps.classFlay); 运行结果 12标记：1标记：2 三、UML类图 四、笔记原型的优点: 性能提高 避免构造函数的约束 让客户隐藏制造新实例的复杂性 提供然客户能够产生未知类型对象的选项 在有些时候，复制对象比创建对象更有效 原型的用途和缺点 在一个复杂类层次中，当系统需要许多类型创建新对象的时候，可以考虑使用原型模式 对象复制的时候，有些时候特别的复杂]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－备忘录模式]]></title>
    <url>%2F20181025.html</url>
    <content type="text"><![CDATA[一、对备忘录模式的理解 备忘录就是备忘的意思，就像git一样，每个状态都记得，如果代码写错了，还可以回到历史版本。而且对现有版本不回产生影响，如果还需要回到现有版本也是可以的。可以实现撤销功能。实现的时候主要需要一个发起人、守护人、和一个备忘录类。 二、代码实现创建备忘录类，用于存放数据 1234567891011 // 备忘录public class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return this.state; &#125;&#125; 创建发起人类、用来设置状态，获取备忘录、设置备忘录等功能。 1234567891011121314151617181920// 发起人public class Originator &#123; private String state; public void setState(String state)&#123; this.state = state; &#125; public String getState() &#123; return this.state; &#125; // 保存状态到备忘录 public Memento saveStateToMemento()&#123; return new Memento(state); &#125; // 通过备忘录获取状态 public void getStateFromMemento(Memento m) &#123; state = m.getState(); &#125;&#125; 创建守护者类、用于存放历史备忘录、增加历史版本备忘录，通过下标获取备忘录等 1234567891011// 守护者public class CareTaker &#123; private List&lt;Memento&gt; list = new ArrayList&lt;Memento&gt;(); public void add(Memento m) &#123; list.add(m); &#125; public Memento getMemento(int i) &#123; return list.get(i); &#125;&#125; main 方法实现 1234567891011121314151617public static void main(String[] args) &#123; Originator origin = new Originator(); CareTaker ct = new CareTaker(); origin.setState(&quot;状态1&quot;); origin.setState(&quot;状态2&quot;); ct.add(origin.saveStateToMemento()); origin.setState(&quot;状态3&quot;); ct.add(origin.saveStateToMemento()); origin.setState(&quot;状态4&quot;); System.out.println(&quot;当前状态为:&quot;+ origin.getState()); origin.getStateFromMemento(ct.getMemento(0)); System.out.println(&quot;回到第一个状态为:&quot;+ origin.getState()); origin.getStateFromMemento(ct.getMemento(1)); System.out.println(&quot;回到第二个状态为:&quot;+ origin.getState()); &#125; 运行结果 123当前状态为:状态4回到第一个状态为:状态2回到第二个状态为:状态3 三、UML类图 四、笔记定义：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 备忘录的优点： 将被存储的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。 保持关键对象的数据封装 提供了容易实现的恢复能力 备忘录的用途和缺点： 备忘录用于存储状态 存储和恢复状态可能比较费时间 java中可以考虑使用序列化机制存储系统的状态。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java memento</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－中介者模式]]></title>
    <url>%2F20181024.html</url>
    <content type="text"><![CDATA[一、对中介者模式的理解中介者就是处理很多类与类之前耦合太多的的一种方式。比如5个类都互相耦合，改动一个类都会动到其他的类，中介者模式利用星形结构改善这种情况。 二、 代码实现中介类 12345678910111213141516171819202122232425262728293031// 抽象中介者public abstract class AbstractMediator &#123; public AbstractColleague A; public AbstractColleague B; public AbstractMediator(AbstractColleague A, AbstractColleague B)&#123; this.A = A; this.B =B; &#125; public abstract void AaffectB(); // a转b public abstract void BaffectA(); // b转a&#125;// 中介者class Mediator extends AbstractMediator&#123; public Mediator(AbstractColleague A, AbstractColleague B) &#123; super(A, B); &#125; @Override public void AaffectB() &#123; int i = A.getNumber(); B.setNumber(i*1000); &#125; @Override public void BaffectA() &#123; int i = B.getNumber(); A.setNumber(i/1000); &#125; &#125; 同事类 12345678910111213141516171819202122232425262728293031// 抽象中介者public abstract class AbstractMediator &#123; public AbstractColleague A; public AbstractColleague B; public AbstractMediator(AbstractColleague A, AbstractColleague B)&#123; this.A = A; this.B =B; &#125; public abstract void AaffectB(); // a转b public abstract void BaffectA(); // b转a&#125;// 中介者class Mediator extends AbstractMediator&#123; public Mediator(AbstractColleague A, AbstractColleague B) &#123; super(A, B); &#125; @Override public void AaffectB() &#123; int i = A.getNumber(); B.setNumber(i*1000); &#125; @Override public void BaffectA() &#123; int i = B.getNumber(); A.setNumber(i/1000); &#125; &#125; main方法运行 1234567891011121314public static void main(String[] args) &#123; AbstractColleague collA = new ColleagueA(); AbstractColleague collB = new ColleagueB(); AbstractMediator am = new Mediator(collA, collB); collA.setNumber(1000, am); System.out.println(&quot;collA:&quot;+collA.getNumber()); System.out.println(&quot;collB:&quot;+collB.getNumber()); System.out.println(&quot;-------&quot;); collB.setNumber(1000, am); System.out.println(&quot;collA:&quot;+collA.getNumber()); System.out.println(&quot;collB:&quot;+collB.getNumber()); &#125; 运行结果 12345collA:1000collB:1000000----collA:1collB:1000 三、UML类图 四、笔记中介者模式定义: 用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而使耦合松散，而且可以独立的改变它们之间的交互。 中介者模式的优点： 将对象解耦之后，可以增加对象的互用 通过将控制逻辑集中，可以简化系统维护 可以让对象之间传递的消息变的简单，而且大幅度减少 中介者模式用途和缺点 中介者模式常常被用来协调相关的GUI组件 如果设计不当，中介者对象本身会变的过于复杂]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java mediator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－解释器模式]]></title>
    <url>%2F201810231.html</url>
    <content type="text"><![CDATA[一、对解释器的理解解释器就像翻译一样，将我们不认识的语言（简化的语言如o2o）翻译为我们认识的普通的语言。如果事物频繁的出现，但是比较复杂，不容易看懂。我们就可以把它表述为一个简单的事物，最用用一个解释器去解释简单的事物就可以了。 二、代码实现创建表达式接口 1234// 创建一个表达式接口public interface Expression &#123; public boolean interpret(String content); // 解释&#125; 终端表达式 1234567891011121314// 终端表达式public class TerminalExpression implements Expression&#123; private String data; public TerminalExpression(String data)&#123; this.data = data; &#125; @Override public boolean interpret(String content) &#123; if (content.contains(data)) &#123; // 包含 return true; &#125; return false; &#125;&#125; 与表达式 12345678910111213// 与表达式public class OrExpression implements Expression&#123; private Expression ex1; private Expression ex2; public OrExpression (Expression ex1, Expression ex2) &#123; this.ex1 = ex1; this.ex2 = ex2; &#125; @Override public boolean interpret(String content) &#123; return this.ex1.interpret(content) || this.ex2.interpret(content); &#125;&#125; 和表达式 12345678910111213// 和表达式public class AndExpression implements Expression&#123; private Expression ex1; private Expression ex2; public AndExpression(Expression ex1, Expression ex2) &#123; this.ex1 = ex1; this.ex2 = ex2; &#125; @Override public boolean interpret(String content) &#123; return ex1.interpret(content) &amp;&amp; ex2.interpret(content); &#125;&#125; 解析器 123456789101112131415// 解析器public class Interpreter &#123; // 获取男性表达式 public static Expression getMaleExpression()&#123; Expression wang = new TerminalExpression(&quot;小王&quot;); Expression zhang = new TerminalExpression(&quot;小张&quot;); return new OrExpression(wang,zhang); &#125; // 获取女性表达式 public static Expression getWomanExpression() &#123; Expression wu = new TerminalExpression(&quot;小吴&quot;); Expression li = new TerminalExpression(&quot;小李&quot;); return new OrExpression(wu,li); &#125;&#125; main方法实现 1234567public static void main(String[] args) &#123; Expression isMale = Interpreter.getMaleExpression(); Expression isWoman = Interpreter.getWomanExpression(); System.out.println(&quot;小李是女的&quot;+ isWoman.interpret(&quot;小李&quot;)); System.out.println(&quot;小王是男的&quot;+ isMale.interpret(&quot;小王&quot;)); System.out.println(&quot;小王是男的&quot;+ isMale.interpret(&quot;小李&quot;)); &#125; 运行结果 123小李是女的true小王是男的true小王是男的false 三、UML类图 四、笔记解释器模式的优点: 将每一个语法规则表示成一个类，方便与实现语言. 因为语法由多个类组成，因此你可以轻易的扩张语言. 可以在新的类中增加新的方法，可以在解释的同时增加新的行为。 解释器的用途和缺点: 当需要实现一个简单的语言的时候，可以使用解释器。 当有一个简单的语法，简单比效率更重要是，使用解释器。 可以处理脚本语言和编程语言 如果语法规则数量太多，使用解释器模式可能会很复杂。这个时候可以使用解析器／编译器的产生器更合适。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java interpreter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[translation spring]]></title>
    <url>%2F20181023.html</url>
    <content type="text"><![CDATA[home 导航：projects^(项目)、guides^(指南)、blog^(博客) spring cloud Edgware released^(发布) spring framework5.0 the right^(正确) stack^(堆栈) for the right job^(工作) 谷歌翻译：适合正确工作的正确堆栈 join^(加入) us in austin , texas 谷歌翻译:加入我们在 austin， texas automate ops for spring cloud on cloud foundry 谷歌翻译:自动化Spring的Ops Cloud Foundry上的云 pivotal^(关键的) web service 有道翻译: 关键web服务 spring: the source^(来源) for modern^(现代) java spring: 来源现代java源代码 your app : spring &gt; spring boot &gt; spring cloud &gt; spring cloud data flow projects whatever^(无论什么) you’re building , these guides are designed^(计划) to get you productive^(生产的) as quickly^(快速的) as possible^(可能性) - using the latest^(最新) spring project releases^(释放) and techniques^(技术) as recommended^(推荐) by the spring team. 无论你正在构建什么，这些指南都尽可能快的提高你的工作效率－spring 团队推荐你使用最新项目版本和技术 have a suggestion^(建议) for a new guide ? let^(允许) us know at @springcentra 有新指南的建议吗? 请告诉我们@springcentra getting started guides 入门指南 designed to be completed^(完成) in 15-30 minutes , these guides provide^(提供) quick^(核心)，hands-on^(动手) instructions^(指令) for building the “hello world” of any development^(开发) task^(任务) with spring.in most^(大多数) cases^(情况), the only^(仅仅) prerequisites^(先决条件) are a JDK and a text editor^(编辑). 计划15-30分钟完成，这些指南提供快速，简单的操作指令用spring可以构建任何的“helle world” 开发任务。在大多数情况，它的先决条件仅仅是JDK和文本编辑器。 building a RESTful Web Service 构建一个RESTful web 服务 learn how to create a RESTful web service with spring 学习怎样用spring创建一个RESTful web 服务 scheduling^(行程安排) tasks^(任务) 计划任务 learn how to schedule tasks with spring 学习怎样用spring 去计划任务 consuming^(消耗) a RESTful Web Service 使用RESTful web 服务 learn how to retrieve^(检索) web page data with spring’s RestTemplate 学习怎样用spring的RestTemplate检索网页数据 building java projects with grable 用grable构建java项目 learn how to build a java projects with grable 学习怎样用grable构建一个java项目 building java projects with maven 用maven构建java项目 learn how to build a java projects with maven 学习怎样用maven构建一个java项目 accessing relational data using jdbc with spring 用spring使用jdbc访问关系形数据 learn how access relational data with spring 学习怎样访问关系形数据用spring uploading files 上传文件 learn how build a spring application that accepts multi-part^(多部分) file uploads. 学习怎样创建一个多文件上传的spring应用 authenticating a user with LDAP 用LDAP认证用户 learn how to secure an application with LDAP 学习怎样用LDAP保护一个应用程序 messaging with Redis 用redis消息传递 learn how to use redis as a message broker^(经纪人) 学习怎样使用redis消息代理 messaging with rabbitMQ 用rabbitMQ发送消息 learn how to create a simple publish-and-subscribe application with spring and rebbitMQ 学习怎样用spring和rebbitMQ去创建一个简单的发布订阅应用]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>translation spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－蝇量模式]]></title>
    <url>%2F201810221.html</url>
    <content type="text"><![CDATA[一、对蝇量模式（享元模式）的理解蝇量模式的作用就是减少对象的创建次数，比如相同的对象，总是需要实例化，而且量比较大这个时候就可以考虑使用蝇量模式了。它的实现方式就是创建Map去存储对象，每次需要新创建对象的时候，就可以在map中去判断是否存在，如果不存在则新创建，否则共享之前的对象。所有也称之为享元模式。 二、代码实现创建汽车类 1234567891011public class Car &#123; private String brand; public Car(String brand)&#123; System.out.println(&quot;___创建&quot;+brand+&quot;汽车&quot;); this.brand = brand; &#125; public void drive() &#123; System.out.println(&quot;开&quot;+ brand + &quot;车&quot;); &#125;&#125; 创建汽车管理者 12345678910111213public class CarKeeper &#123; private Map&lt;String, Car&gt; map = new HashMap&lt;String, Car&gt;(); public Car getCar(String name) &#123; Car car = this.map.get(name); if (car == null) &#123; car = new Car(name); this.map.put(name, car); return car; &#125; return car; &#125;&#125; main方法实现 123456789101112131415public static void main(String[] args) &#123; CarKeeper ck = new CarKeeper(); Car car1 = ck.getCar(&quot;奥迪&quot;); car1.drive(); Car car2 = ck.getCar(&quot;宝马&quot;); car2.drive(); Car car3 = ck.getCar(&quot;雷克萨斯&quot;); car3.drive(); Car car4 = ck.getCar(&quot;雷克萨斯&quot;); car4.drive(); Car car5 = ck.getCar(&quot;宝马&quot;); car5.drive(); Car car6 = ck.getCar(&quot;奥迪&quot;); car6.drive(); &#125; 运行结果 123456789___创建奥迪汽车开奥迪车___创建宝马汽车开宝马车___创建雷克萨斯汽车开雷克萨斯车开雷克萨斯车开宝马车开奥迪车 三、UML类图 四、笔记感觉这个模式的UML图是最简单的，和单例模式差不多。 蝇量模式的优点： 减少运行时对象实例的个数，节省内存。 将许多“虚拟”对象的状态集中管理 蝇量模式的用途和缺点: 当一个类有许多的实例，而这些实例能被同一个方法控制的时候，就可以使用蝇量模式 一旦实现了蝇量模式，那么单个的逻辑实例将无法独立的实现不同的行为。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java chainOfResponsibility</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在2018结束之前的目标]]></title>
    <url>%2F20181021.html</url>
    <content type="text"><![CDATA[2018年还有最多四个月就结束了，从写第一行代码到现在已经有两年多了。在这两年多的时间里，学习的很多的知识，总是在马不停蹄的学习，但是总是感觉学习的不够，也总是很浮躁，总想学习更多的东西，总是想贪多。但是如果一直这样下去的话，自己只会变的越来越浮躁。必须逼自己一下，要让自己沉淀下来，深入学习底层原理，这样才能走的更远。 一、设计模式 最近买了head first的书，已经看完了，总共23个设计模式。距离实现全部的模式我还差6个。学习的方式，就是先看一遍书籍，然后想一个相同案例,之后源码实现，画UML类图，通过自己的总结之后在纪录到自己的博客里面。在写博客的时候，全部手打，不能容忍自己command c 之后 command v 。当然只是这样还是不够的，需要在以后的代码中灵活的使用这些设计模式，这才是最重要的。 目标总的目标就是实现完所有的设计模式，并理解每个设计模式的原理。并大量的在代码中实现。 二、英语对于我的垃圾英语，我已经无力吐槽了。总是想好好的学习，但是自己总是给了自己种种的借口，这种借口我也不知道要持续到什么时候。我想要尽快的结束这种借口，能让自己可以在看English的文档的时候能游刃有余。今天看到了有大牛写的关于学习English的博客，自我感觉最重要的就是坚持，只要在学习的道路上坚持下去就会有所沉淀。对于English的学习也就是听、说、读、写。我现在写English文档那是还有很大一段的路要走的。听和说，对于不想讲话的我也是比较遥远的。所以只剩下了读，这也是对我最重要的，也是最迫切需要的。对许学习读的方法对我比较好的就是看各种美剧的剧本（很喜欢看美剧），或者技术文档（很大文档都是需要看的）。于是我选择的就是看技术文档。 目标 每天看技术文档，目前想要学习的技术就是spring,spring boot,spring cloud，就从这个开始，尽量多的抽时间看技术文档。让自己的技术和英语一起进步，让自己泡在English的spring里面。 如果看的实在费劲，就写博客，一边翻译spring的技术，一边学习English. 三、spring, spring boot, spring cloud现在公司写的项目就是基于spring boot实现的，虽然功能实现了，但是感觉很多的技术，自己都没有摸透。需要花大量的时间，去好好的琢磨。spring 也是只会基础的。底层原理自己也没有去梳理一遍。spring cloud更是才了解一点。 目标看spring源码，了解spring底层实现。了解spring boot原理，学习spring cloud搭建以及实现。 总结总的来说，事情还是很多的，首先先看spring的英文文档。通过文档学习技术和英语。如果技术无法增长，就购买最近很想买的spring 三剑客。好好学习。 在就是自己的娱乐时间，感觉需要缩短一些。现在看新闻、看短视频、看朋友圈，总是会花很多的时间。希望自己能合理安排时间，多一些学习的时间，加油。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life 2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记]]></title>
    <url>%2F20181022.html</url>
    <content type="text"><![CDATA[java方法中参数的传递(java中只有值传递)： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型)(方法中改变基本类型数据，不会影响到之前的数据。相当于拷贝数据) 一个方法可以改变一个对象参数的状态。(对象: 方法中改变对象的数据，原始的对象的值会跟着改变。) 一个方法不能让对象参数引用一个新的对象 ==与equals的区别== 判断的是是否是对象的地址，即判断连个对象是不是同一个地址。（基本数据类型对比的是值，引用数据类型对比的是对象地址） equals 判断的是值是否相同（对象没有覆盖equals方法相当于== ，否则通过覆盖的equals判断对象的值是否相等） 如果对象需要用equals对比，需要重写equals方法。 String 对象是重写过equals方法的，所有string的equals对比的是值。 当创建string类型对象的时候，虚拟机会在常量池中找是否有相同的对象，如果有就把它赋给当前引用，否则就新创建对象 hashCode与equals hashCode的作用就是获取哈西码。它实际返回的是一个int整数。这个哈西码的作用就是确定索引的位置（可以快速找到所需要的对象）。 hashCode在map中的作用就是为了减少equals的执行次数,相应就提高了执行速度。 如果不同的对象拥有相同的hashCode值，他们也不一定是相等的。如果相同的情况下，就像HashSet一样，会使用equals去对比值是否相同。 java iojava jvm多线程集合]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－责任链模式]]></title>
    <url>%2F20181019.html</url>
    <content type="text"><![CDATA[一、对责任链模式的理解一个请求需要由多个对象处理，这些对象可以链接成为一条链。具体由那个类处理，由判断条件决定，如果该对象不能处理，则传给下一个对象处理。责任链将请求和处理分开。责任链比较好的例子就向请假一样，你需要请假10天，需要由你的主管确认，经理确认，总经理确认，全部通过才可以休假。但是如果请假5天，可能总经理就不用审核了，经理直接就可以处理这件事情。还有Logger的异常处理也是这种方式。下面的代码就是基于日志实现的。 二、代码实现创建一个抽象日志类 1234567891011121314151617181920212223// 抽象日志public abstract class AbstractLogger &#123; public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; public int level; public AbstractLogger nextLogger; // 下一个链条 public void setNextLogger(AbstractLogger al) &#123; this.nextLogger = al; &#125; public void logMessage(int le, String message) &#123; if (this.level&lt;=le) &#123; write(message); &#125; if (this.nextLogger != null) &#123; this.nextLogger.logMessage(le, message); &#125; &#125; abstract public void write(String message);&#125; 创建其他类继承抽象日志类 123456789101112131415161718192021222324252627282930// 打印日志public class ConsoleLogger extends AbstractLogger&#123; public ConsoleLogger(int le) &#123; this.level = le; &#125; @Override public void write(String message) &#123; System.out.println(&quot;打印日志:&quot;+message); &#125;&#125;class ErrorLogger extends AbstractLogger&#123; public ErrorLogger(int le) &#123; this.level = le; &#125; @Override public void write(String message) &#123; System.out.println(&quot;异常日志:&quot;+message); &#125;&#125;// 文件日志class FileLogger extends AbstractLogger&#123; public FileLogger(int le) &#123; this.level = le; &#125; @Override public void write(String message) &#123; System.out.println(&quot;文件日志:&quot; + message); &#125;&#125; 创建责任链链条 12345678910public class Chain &#123; public static AbstractLogger getChainOfLogger() &#123; AbstractLogger el = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fl = new FileLogger(AbstractLogger.DEBUG); AbstractLogger cl = new ConsoleLogger(AbstractLogger.INFO); el.setNextLogger(fl); fl.setNextLogger(cl); return el; &#125;&#125; main方法实现 1234567public static void main(String[] args) &#123; AbstractLogger al = Chain.getChainOfLogger(); al.logMessage(AbstractLogger.INFO, &quot;文件信息&quot;); al.logMessage(AbstractLogger.DEBUG, &quot;debug信息&quot;); al.logMessage(AbstractLogger.ERROR, &quot;异常信息&quot;); &#125; 执行结果 打印日志:文件信息 文件日志:debug信息 打印日志:debug信息 异常日志:异常信息 文件日志:异常信息 打印日志:异常信息 三、UML类图 四、笔记 责任链定义: 避免请求发送者和接收者耦合到一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。责任链模式是一种对象行为行模式。 责任链优点 将请求的发送者和接收者解耦。 简化对象，它不需要知道链的结构。 通过改变或调用链内成员的次序，允许动态新增和删除责任 责任链的用途和缺点 经常用到窗口系统中，处理鼠标键盘等事件。 并不保证请求一定会被执行，如果没有处理类去处理请求的话，可以会落到链尾之外。有好有坏 不较不容易观察运行特征，不好排除错误。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java chainOfResponsibility</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－桥接模式]]></title>
    <url>%2F201809011.html</url>
    <content type="text"><![CDATA[一、对桥接模式的理解在很多个网站都看到了桥接模式的定义，最直观的理解就是要画正方形、圆形、长方形，画笔有红色、蓝色、紫色。当出现了两个以上的类别(形状、颜色。一个类出现了两个独立的变化的维度，且这两个维度都需要进行扩展)的时候，就可以考虑使用桥接模式了。 桥接模式定义:将抽象部分与实现部分分离，使他们都可以独立的变化。它是一种对象结构型模式，又称为柄体模式或接口模式。 二、 代码实现创建颜色和形状的api接口，并创建红色、绿色、圆形、正方形等实现各自的接口。 12345678910111213141516171819202122232425262728293031323334353637383940// 颜色apipublic interface ColorAPI &#123; // 画 public void Draw();&#125;// 红色class Red implements ColorAPI&#123; @Override public void Draw() &#123; System.out.println(&quot;用红色的笔&quot; ); &#125;&#125;// 绿色class Green implements ColorAPI&#123; @Override public void Draw() &#123; System.out.println(&quot;用绿色的笔&quot;); &#125; &#125;// 形状apiinterface ShapeAPI &#123; // 画 public void Draw();&#125;// 圆形class Circle implements ShapeAPI&#123; @Override public void Draw() &#123; System.out.println(&quot;画圆形&quot;); &#125; &#125;class Square implements ShapeAPI&#123; @Override public void Draw() &#123; System.out.println(&quot;画正方形&quot;); &#125; &#125; 创建形状的抽象类，与抽象类的实现类 123456789101112131415161718192021222324// 形状抽象类public abstract class Shape &#123; ColorAPI colorAPI; ShapeAPI shapeAPI; Shape(ColorAPI ca ,ShapeAPI sa) &#123; this.colorAPI = ca; this.shapeAPI = sa; &#125; // 画的抽象方法 public abstract void draw();&#125;// 形状实现class ShapeImpl extends Shape&#123; ShapeImpl(ColorAPI ca, ShapeAPI sa) &#123; super(ca, sa); // TODO Auto-generated constructor stub &#125; @Override public void draw() &#123; this.colorAPI.Draw(); this.shapeAPI.Draw(); &#125;&#125; main方法运行 12345678public static void main(String[] args) &#123; Shape redCircle = new ShapeImpl(new Red(), new Circle()); Shape greenSquare = new ShapeImpl(new Green(), new Square()); Shape greenCircle = new ShapeImpl(new Green(), new Circle()); redCircle.draw(); greenSquare.draw(); greenCircle.draw(); &#125; 运行结果 123456用红色的笔画圆形用绿色的笔画正方形用绿色的笔画圆形 三、UML类图 四、 笔记 桥接模式定义: 将抽象个部分与它的实现部分分离，使他们可以独立的变化。它是一种对象结构型模式。 00原则 封装变化 针对接口编程，不针对实现编程 对增加开放，对修改关闭 不要来找我，我来找你 只对朋友交谈 为交互对象之间的松耦合设计而努力 多用组合，少用继承 类应该只有一个被改变的理由 依赖抽象，不依赖具体实现类 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－建造者模式]]></title>
    <url>%2F201810182.html</url>
    <content type="text"><![CDATA[一、对建造者模式的理解就是将多个简单的对象一步一步构建为一个复杂的对象。主要解决软件开发中的一个复杂对象的创建。代码就实现汉堡和饮料的点餐功能。我们创建包装接口，由瓶子装饮料，包装纸包装汉堡的实现类去实现包装接口。在创建一个项目接口，由汉堡和冷饮的抽象类去实现，之后创建各自的实现类去实现，汉堡有蔬菜汉堡和鸡肉汉堡，冷饮后百事可乐和可口可乐。在然后创建用餐的类采用list存放项目。最后创建一个用餐建造类来建造蔬菜餐和非蔬菜餐。 二、代码实现创建包装接口和各自的实现类 123456789101112131415161718192021package study.builder;// 装食物的填料接口public interface Packing &#123; public String pack(); // 大包&#125;// 包装纸材料class Wrapper implements Packing&#123; @Override public String pack() &#123; return &quot;包装材料&quot;; &#125;&#125;// 瓶子包装class Bottle implements Packing&#123; @Override public String pack() &#123; return &quot;瓶子包装&quot;; &#125; &#125; 创建项目接口，汉堡、冷饮接口以及各自的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 项目接口public interface Item &#123; public String name(); public Packing packing(); public float price();&#125;// 汉堡使用包装纸包装抽象类abstract class Burger implements Item&#123; public Packing packing()&#123; return new Wrapper(); &#125;; public abstract float price(); &#125;// 冷饮抽象类abstract class ColdDrink implements Item&#123; public Packing packing() &#123; return new Bottle(); &#125; public abstract float price();&#125;// 蔬菜汉堡class VegBurger extends Burger&#123; @Override public String name() &#123; return &quot;蔬菜汉堡&quot;; &#125; @Override public float price() &#123; return 18.8f; &#125;&#125;// 鸡肉汉堡class ChickenBurger extends Burger&#123; @Override public String name() &#123; return &quot;鸡肉汉堡&quot;; &#125; @Override public float price() &#123; return 28.8f; &#125;&#125;// 可口可乐class Coke extends ColdDrink&#123; @Override public String name() &#123; return &quot;可口可乐&quot;; &#125; @Override public float price() &#123; return 5.5f; &#125;&#125;// 百事可乐class Pepsi extends ColdDrink&#123; @Override public String name() &#123; return &quot;百事可乐&quot;; &#125; @Override public float price() &#123; return 5.6f; &#125;&#125; 创建用餐类 123456789101112131415161718192021// 餐public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void add(Item it )&#123; this.items.add(it); &#125; public float getCost() &#123; float cost = 0.0f; for(Item it : items) &#123; cost += it.price(); &#125; return cost; &#125; public void showItem()&#123; for(Item it : items) &#123; System.out.print(&quot;项目：&quot;+it.name()); System.out.print(&quot;, &quot; +it.packing().pack()); System.out.println(&quot;, 价格&quot; + it.price()); &#125; &#125;&#125; 创建构造餐类 12345678910111213141516// 建造餐public class MealBuilder &#123; // 准备蔬菜餐 public Meal prepareVegMeal() &#123; Meal meal = new Meal(); meal.add(new VegBurger()); meal.add(new Coke()); return meal; &#125; public Meal prepareNonVegMeal() &#123; Meal meal = new Meal(); meal.add(new ChickenBurger()); meal.add(new Pepsi()); return meal; &#125;&#125; main方法实现 12345678910public static void main(String[] args) &#123; MealBuilder mb = new MealBuilder(); Meal vegMeal = mb.prepareVegMeal(); vegMeal.showItem(); System.out.println(&quot;蔬菜餐的总价：&quot;+ vegMeal.getCost()); Meal nonvegMeal = mb.prepareNonVegMeal(); nonvegMeal.showItem(); System.out.println(&quot;肉类餐的总价：&quot;+ nonvegMeal.getCost()); &#125; 运行结果 123456项目：蔬菜汉堡, 包装材料, 价格18.8项目：可口可乐, 瓶子包装, 价格5.5蔬菜餐的总价：24.3项目：鸡肉汉堡, 包装材料, 价格28.8项目：百事可乐, 瓶子包装, 价格5.6肉类餐的总价：34.399998 三、 UML类图 四、 笔记 定义: 将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java builder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7部署MinDoc API在线文档管理系统]]></title>
    <url>%2F20181018.html</url>
    <content type="text"><![CDATA[前言： 由于是前后端分离的项目，API是前后端最重要的沟通工具，用一个好的在线文档管理系统代替FTP等文本传输API是一个很不错的选择。在线文档比较好的开源文档系统就是wiki。MediaWiki是基于wiki用PHP开发的，配置起来比较复杂。后来发现一个MinDoc使用go语言开发的，特别方便。我将两种配置方式都记录一下。两种方式都需要安装mysql，CentOS7 的yum里面没有mysql，需要手动下载。 需要准备的就是配置外网可以访问的端口号，mindoc默认8181，可以先去配置好，阿里云的ECS服务器可以直接在安全组里面配置。 没有安装mysql的可以先安装mysql 123456789101112131415161718wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm //下载mysql的repo源sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm // 安装mysql-community-release-el7-5.noarch.rpm包sudo yum install mysql-server // 安装mysqlmysql -u root // 重置mysql密码// 出现ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)sudo chown -R root:root /var/lib/mysqlservice mysqld restart // 重启mysqlmysql //直接回车进入mysql控制台mysql &gt; use mysql; // 使用mysql数据库mysql &gt; update user set password=password(&apos;123456&apos;) where user=&apos;root&apos;; // 更改密码 一、MinDoc1. 下载MinDoc12345mkdir mindoc &amp;&amp; cd mindoc //创建一个目录wget https://github.com/lifei6671/mindoc/releases/download/v0.9/mindoc_linux_amd64.zip //下载二进制包unzip mindoc_linux_amd64.zip // 解压 2. 修改conf/app.conf 文件，打开文件注释123456789db_adapter=mysqldb_host=127.0.0.1db_port=3306db_database=mindoc_dbdb_username=rootdb_password=123456adb_adapter=sqlite3db_database=./database/mindoc.db 3. 当前目录进行安装1./mindoc_linux_amd64 install 4. 出现Install Successfully! 之后就可以运行并访问123./mindoc_linux_amd64 // 在线运行，不能退出nohup ./mindoc_linux_amd64 &amp; // 后台运行 访问http://IP:8181 即可，帐号admin 密码123456 end 二、mediawiki1. 安装需要的一些配置1yum install httpd php php-mysql php-gd php-xml mysql-server mysql libxml2 2. 在mysql启动的状态下配置mysql1mysql_secure_installation 3. 在mysql里面配置项目1234567create database wikidb; grant all on wikidb.* to root; grant all on wikidb.* to root@localhost; grant all on wikidb.* to wikiuser; grant all on wikidb.* to wikiuser@localhost; set password for wikiuser@localhost=password(&apos;wikipw&apos;); 4.修改httpd配置123456789vim /etc/httpd/conf/httpd.conf#ServerName www.example.com:80 // 前面的#去掉(去掉注释)vim /etc/hosts 127.0.0.1 localhost localhost.localadmin xxhost // 添加hostnameservice httpd restart // 启动网络服务 5.Mediawiki的手动安装12345678wget http://releases.wikimedia.org/mediawiki/1.22/mediawiki-1.22.5.tar.gztar -xvf mediawiki-1.22.5.tar.gz // 解压mv mediawiki-1.22.5 /var/www/html/w // 将解压后的文件夹移动到httpd.conf中DocumentRoot指定的文件夹中，默认是&quot;var/www/html&quot;chown -R 777 /var/www/html/w/chmod 777 /var/www/html/w/mw-config // 改变权限 通过http://ip/w/index.php访问，出现下面标志表示成功 两种方式都实现了，最后就需要自己去配置个性化的设置。这两个都有自己不同的展示方式，个人偏好与第一种页面风格很友好。功能也更加完善，编辑器也是基于Markdown的。]]></content>
      <categories>
        <category>utils</category>
      </categories>
      <tags>
        <tag>MinDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－复合模式]]></title>
    <url>%2F20181016.html</url>
    <content type="text"><![CDATA[一、对于复合模式的理解复合模式就是很多模式一起乱炖。工厂模式、抽象工厂模式、迭代器模式、组合模式、装饰模式、适配器模式、观察者模式，在一起使用。但是每次使用的时候都是在需要的时候使用。每个模式都有各自的作用，使用在一起就是会觉得代码非常的拥挤，很混乱。这个模式我是照搬书上的代码实现的。下面的代码就比较多了，书上面是循序渐进的讲解的，我是直接粘贴自己写的代码，不是很容易理解。可以先看看下面的类图。 二、代码实现创建鸭叫观察者，用于统计鸭子 123456789101112131415161718192021222324252627282930// 鸭叫观察者接口public interface QuackObservable &#123; public void registerObserver(Observer observer); public void notifyObservers();&#125;interface Observer &#123; public void update(QuackObservable duck);&#125;// 观察者辅助类class Observable implements QuackObservable&#123; ArrayList observers = new ArrayList(); QuackObservable duck; public Observable(QuackObservable q)&#123; this.duck = q; &#125; @Override public void registerObserver(Observer observer) &#123; this.observers.add(observer); &#125; @Override public void notifyObservers() &#123; Iterator it = this.observers.iterator(); while (it.hasNext()) &#123; Observer ob = (Observer)it.next(); ob.update(duck); &#125; &#125; &#125; 创建鸭叫能力接口以及各种鸭子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// 鸭叫能力接口public interface Quackable extends QuackObservable&#123; public void quack(); // 呱呱叫&#125;// 绿头鸭实现鸭叫能力接口class MallardDurk implements Quackable&#123; Observable ob; @Override public void quack() &#123; System.out.println(&quot;绿头鸭嘎嘎叫&quot;); this.ob = new Observable(this); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;// 红头鸭也实现鸭叫能力接口class RedheadDuck implements Quackable&#123; Observable ob; @Override public void quack() &#123; System.out.println(&quot;红头鸭嘎嘎叫&quot;); this.ob = new Observable(this); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;//鸭鸣器也实现了鸭叫能力接口class DuckCall implements Quackable&#123; Observable ob; @Override public void quack() &#123; System.out.println(&quot;鸭鸣器嘎嘎叫&quot;); this.ob = new Observable(this); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;// 橡皮鸭也实现了鸭叫能力接口class RubberDuck implements Quackable&#123; Observable ob; @Override public void quack() &#123; System.out.println(&quot;橡皮鸭嘎嘎叫&quot;); this.ob = new Observable(this); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;// 鹅class Goose&#123; public void honk() &#123; System.out.println(&quot;鹅咯咯叫&quot;); &#125;&#125;// 用适配器模式将鹅适配为鸭子class GooseAdapter implements Quackable&#123; Observable ob; Goose goose; public GooseAdapter(Goose goose) &#123; this.ob = new Observable(this); this.goose = goose; &#125; @Override public void quack() &#123; this.goose.honk(); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;// 利用装饰者模式，在不改变原来鸭子类的情况下给鸭子添加计数功能class QuackCounter implements Quackable&#123; Observable ob; Quackable duck; static int num; public QuackCounter (Quackable quack) &#123; this.ob = new Observable(quack); this.duck = quack; &#125; @Override public void quack() &#123; this.duck.quack(); num++; &#125; public static int getNum() &#123; return num; &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125; 创建鸭叫的各种工厂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 鸭叫抽象工厂public abstract class AbstractDuckFactory &#123; public abstract Quackable createMallardDuck(); public abstract Quackable createRedheadDuck(); public abstract Quackable createDuckCall(); public abstract Quackable createRubberDuck();&#125;// 鸭叫工厂实现鸭叫抽象工厂class DuckFactory extends AbstractDuckFactory&#123; @Override public Quackable createMallardDuck() &#123; return new MallardDurk(); &#125; @Override public Quackable createRedheadDuck() &#123; return new RedheadDuck(); &#125; @Override public Quackable createDuckCall() &#123; return new DuckCall(); &#125; @Override public Quackable createRubberDuck() &#123; return new RubberDuck(); &#125;&#125;// 统计鸭子工厂继承鸭子抽象工厂class CountingDuckFactory extends AbstractDuckFactory&#123; @Override public Quackable createMallardDuck() &#123; // 先用叫声计数装饰着将quackable装饰起来 return new QuackCounter(new MallardDurk()); &#125; @Override public Quackable createRedheadDuck() &#123; return new QuackCounter(new RedheadDuck()); &#125; @Override public Quackable createDuckCall() &#123; return new QuackCounter(new DuckCall()); &#125; @Override public Quackable createRubberDuck() &#123; return new QuackCounter(new RubberDuck()); &#125;&#125; 创建一群鸭子 123456789101112131415161718192021222324252627// 用组合模式实现一群鸭子public class Flock implements Quackable&#123; Observable ob; ArrayList list = new ArrayList(); public Flock() &#123; this.ob = new Observable(this); &#125; @Override public void quack() &#123; Iterator it = list.iterator(); // 迭代器模式 while(it.hasNext()) &#123; Quackable q = (Quackable)it.next(); q.quack(); &#125; &#125; public void add(Quackable q) &#123; list.add(q); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125; 创建呱呱叫学家 12345678public class Quackologist implements Observer&#123; @Override public void update(QuackObservable duck) &#123; System.out.println(&quot;呱呱叫学家：&quot;+duck); &#125;&#125; 创建鸭子模拟器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 鸭子模拟器public class DuckSimulator &#123; public void simulate() &#123; // 模拟 Quackable mallardDuck =new QuackCounter( new MallardDurk()); Quackable redheadDuck = new QuackCounter(new RedheadDuck()); Quackable duckCall = new QuackCounter(new DuckCall()); Quackable rubberDuck = new QuackCounter(new RubberDuck()); Quackable goose = new GooseAdapter(new Goose()); // 一只鹅 sumulate(mallardDuck); sumulate(redheadDuck); sumulate(duckCall); sumulate(rubberDuck); sumulate(goose); System.out.println(&quot;鸭子的数量为:&quot;+QuackCounter.getNum()); &#125; private void sumulate(Quackable qa) &#123; qa.quack(); &#125; // 重写构造方法 public void simulate(AbstractDuckFactory adf) &#123; Quackable mallardDuck =adf.createMallardDuck(); Quackable redheadDuck = adf.createRedheadDuck(); Quackable duckCall = adf.createDuckCall(); Quackable rubberDuck = adf.createRubberDuck(); Quackable goose = new GooseAdapter(new Goose()); // 一只鹅 Flock fock = new Flock(); // 一群乱七八糟的鸭子 fock.add(redheadDuck); fock.add(rubberDuck); fock.add(duckCall); fock.add(mallardDuck); Flock focks = new Flock(); Quackable redheadDuck1 = adf.createRedheadDuck(); //一群红头鸭子 Quackable redheadDuck2 = adf.createRedheadDuck(); Quackable redheadDuck3 = adf.createRedheadDuck(); Quackable redheadDuck4 = adf.createRedheadDuck(); focks.add(redheadDuck4); focks.add(redheadDuck3); focks.add(redheadDuck2); focks.add(redheadDuck1); System.out.println(&quot;红头鸭子打头&quot;); sumulate(focks); System.out.println(&quot;乱七八糟的鸭子来了&quot;); sumulate(fock); System.out.println(&quot;鸭子的数量为:&quot;+QuackCounter.getNum()); Quackologist ql = new Quackologist(); fock.registerObserver(ql); sumulate(fock); System.out.println(&quot;鸭子的数量为:&quot;+QuackCounter.getNum()); &#125;&#125; main方法运行 12345678public static void main(String[] args) &#123; DuckSimulator ds1 = new DuckSimulator(); ds1.simulate(); DuckSimulator ds = new DuckSimulator(); AbstractDuckFactory adf = new CountingDuckFactory(); ds.simulate(adf); &#125; 实现结果 12345678910111213141516红头鸭子打头红头鸭嘎嘎叫红头鸭嘎嘎叫红头鸭嘎嘎叫红头鸭嘎嘎叫乱七八糟的鸭子来了红头鸭嘎嘎叫橡皮鸭嘎嘎叫鸭鸣器嘎嘎叫绿头鸭嘎嘎叫鸭子的数量为:8红头鸭嘎嘎叫橡皮鸭嘎嘎叫鸭鸣器嘎嘎叫绿头鸭嘎嘎叫鸭子的数量为:12 三、UML类图 这个复合模式很复杂，需要掌握的技巧特别多，需要反复学习。后面就要学习mvc模式了，也是属于复合模式。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－mvc模式]]></title>
    <url>%2F20180901.html</url>
    <content type="text"><![CDATA[时间过的很快，什么都没学习到。就已经过去了大半的时间。这次是需要好好理解一下复合模式mvc。在java web开发中经常会用到mvc模式，总是大概的了解，没有弄懂最重要的东西。这次好好的学习一下mvc模式，用表格归纳一下常见的mvc模式。 模型 视图 控制器 mvc model view controller java中常见的mvc java bean jsp servlet mvc复合模式 观察者模式 组合模式 策略模式 一、对MVC模式的理解]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 代理模式]]></title>
    <url>%2F201809010.html</url>
    <content type="text"><![CDATA[昨天将组合模式完成了，组合模式可以遍历树状的集合。迭代器模式可以遍历不同类型的集合。如果有树状结构的集合，可以优先考虑使用组合模式。 一、对于代理模式的理解定义：给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。就想黄牛一样，委托代买票业务给黄牛，黄牛收钱买票，我不知道黄牛是如何买票的，卖票的人不知道是谁买票的，便于保护真实用户。代理模式也经常用于远程代理，和虚拟代理等 二、代码实现创建一个主题，用于黄牛和真实的我继承。12345// 创建主题接口public interface Subject &#123; // 买票 public void buyTicket();&#125; 创建一个真的我，买票.实现主题 1234567// 真实主题（我）public class RealSubject implements Subject&#123; @Override public void buyTicket() &#123; System.out.println(&quot;我要买票回家&quot;); &#125;&#125; 创建代理类，实现主题 1234567891011121314// 代理买票（黄牛）public class Proxy implements Subject&#123; @Override public void buyTicket() &#123; RealSubject rs = new RealSubject(); rs.buyTicket(); this.compterTicket(); &#125; // 不公开的买票方式，通过电脑买票 private void compterTicket() &#123; System.out.println(&quot;黄牛进行买票&quot;); &#125;&#125; mian方法运行 12345public static void main(String[] args) &#123; // 调用者完全不知道是谁买票，只知道是一个黄牛保护目标 Subject sb =new Proxy(); sb.buyTicket(); &#125; 运行结果 12我要买票回家黄牛进行买票 三、UML类图 四、笔记 封装变化 针对接口编程，不针对实现编程 对修改关闭，对扩展开放 多用组合，少用继承 为交互对象之间的松耦合设计而努力 依赖抽象，不依赖具体类 只和朋友交谈 别找我，我会找你 类应该只有一个改变的理由 定义: 为另一个对象提供一个替身或占位符以访问这个对象 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 使用jenkins+maven+git实现自动化部署java项目]]></title>
    <url>%2F20181011.html</url>
    <content type="text"><![CDATA[要将项目发布到通过外网访问，就需要将jar或者war通过scp传到服务器，在启动项目。如果项目中更改了一行代码，那么就需要进行一下步骤： 本地将项目打包为war或者jar包 将打包后的文件传到服务器 将之前项目kill掉 将新项目移动到指定位置启动 但有了jenkins后我们就可以只需要将代码提交到git或者svn上面就可以了，其它的事情全部交给jenkins去完成。要实现这个功能大概的思路如下： 1、安装jenkins（自动化配置）2、安装git（管理项目）3、安装maven(编译项目)4、配置jenkins如下 安装插件 （jenkins集成tomcat、svn、git等的插件） 全局工具配置（让jenkins找到jdk,maven,git的环境变量等） 创建任务一、安装jenkins由于yum的repo里面没有jenkins,先配置yum12sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key yum安装1yum -y install jenkins 更改jenkins配置 1vi /etc/sysconfig/jenkins 将JENKINS_NAME改为root,JENKINS_PORT改为8081 启动jenkins1service jenkins start 开通8081的端口号之后，通过在外网用http://ip地址:8081 访问出现如下页面即可： 根据提示，在/var/lib/jenkins/secrets/initialAdminPassword中找到密码复制进去点击继续，不要着急稍微等待一会之后即可看到如下页面 之后点击第一个默认配置，右边的是自定义配置，不熟悉的可以选择第一个（左边的那个）之后就是漫长的等待，等jenkins下载基础插件 安装完成之后就创建自己的账号和密码吧！ 之后点击继续后出现下面这个页面就安装完成了 二、安装maven配置yum1wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo yum安装1yum -y install apache-maven 查看是否安装成功 1mvn -v 三、安装git12yum -y install gitgit --version // 查看git版本号 四、配置jenkins1、安装插件maven integration 插件：用于maven集成jenkins，如果不安装就不会有“构建一个maven”项目选项 2、全局工具配置（让jenkins找到jdk,maven,git等）3、新建任务遇到的坑：1、配置git出现如下错误 因为此仓库为我的私有仓库，需要配置Credentials，点开add， Add Credentials的 Kind选择SSH Username with private key，Username选择之前在github上传的公钥用户的用户名，此次为root，Private Key为jenkins服务器登录github的本地私钥，查看私钥cat /root/.ssh/id_rsa （如果没有这个文件则生成命令为：ssh-keygen -t rsa）复制粘贴到Key区域，完成添加。此时可以发现报错已经消失。构建的时候可能会遇到git超时可以安装这个处理[https://www.jianshu.com/p/264772bb9264](https://www.jianshu.com/p/264772bb9264)要这个页面将超时时间设置长一些，我设置的是260分钟。默认是10分钟，由于项目比较大，通过git将项目迁到服务器总是超时。设置这个就好了 2、构建触发器，就是设置何时开始启动build，运行程序。选这里选默认3、其它的先不动将build改为如下： 4.在写sh脚本的时候要加 BUILD_ID=dontKillMe 否则项目不会启动 1234567891011121314151617#!/bin/bashport=8098echo &quot;check $port&quot;grep_port=`netstat -tlpn | grep &quot;\b$port\b&quot;`echo &quot;grep port is $grep_port&quot;if [ -n &quot;$grep_port&quot; ]then echo &quot;端口 $port 在使用&quot; netstat -nlp |grep :8098 |grep -v grep|awk &apos;&#123;print $7&#125;&apos; |awk -F &apos;/&apos; &apos;&#123;print $1&#125;&apos; |xargs kill -9 echo &quot;kill 掉$port 端口&quot;else echo &quot;端口没有被使用&quot;fiecho &quot;开始重启&quot;# 此处要注意加BUILD_ID=dontKillMe 否则jenkins不会将项目启动下去BUILD_ID=dontKillMe nohup java -jar /var/lib/jenkins/workspace/projectName/target/projectName-0.0.1-SNAPSHOT.jar &amp;echo &quot;jenkins 自动化部署成功&quot; 最后在控制台查看jenkins部署日志，项目需要用maven可以编译通过 五、配置git钩子触发jenkins构建]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装mysql]]></title>
    <url>%2F20181013.html</url>
    <content type="text"><![CDATA[下载mysql的repo源 1wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 安装mysql-community-release-el7-5.noarch.rpm包 1sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 3.安装mysql 1sudo yum install mysql-server 4.进入mysql 1mysql 5.报错ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户： 1sudo chown -R root:root /var/lib/mysql 6.重启mysql 1service mysqld restart 7.更改密码 1update user set password=password(&apos;123456&apos;) where user=&apos;root&apos;;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 组合模式]]></title>
    <url>%2F20180903.html</url>
    <content type="text"><![CDATA[已经有一段时间没有写模式了，在把迭代器模式写了之后，本应该是写组合模式的，但是组合模式涉及到递归，感觉很麻烦，于是就跳跃了，没有及时写下来，之后看了代理模式，复合模式等。都没有记录下来。现在是时候好好理一下这些模式了，昨天复习了下之前的模式，特别感觉工厂方法和抽象工厂都有些模糊了。看来要努力了，加油！ 一、对组合模式的理解组合模式定义：允许你将对象组合成树形结构来表现“整体／部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象集合。 个人理解就是处理树形结构集合的一种模式就想树一样，是有根，有无数的树枝，无数的叶子，一成一层的，就像电脑文件夹一样 二、代码实现实现抽象类12345678// 抽象组合类public abstract class Component &#123; String name; public Component(String name) &#123; this.name = name; &#125; public abstract void operation(int index); // 操作&#125; 实现叶子类,继承抽象组合类 1234567891011121314151617// 叶子public class Leaf extends Component&#123; public Leaf(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; @Override public void operation(int index) &#123; String str = &quot;&quot;; for (int i=0; i&lt;index; i++) &#123; str = str+ &quot; &quot;; &#125; System.out.println(str + name); &#125;&#125; 实现树枝类，继承抽象组合类 123456789101112131415161718192021222324252627282930public class Composite extends Component&#123; private LinkedList&lt;Component&gt; childer; public Composite(String name) &#123; super(name); this.childer = new LinkedList&lt;&gt;(); &#125; @Override public void operation(int index) &#123; String str = &quot;&quot;; for (int i=0; i&lt;index; i++) &#123; str = str+ &quot; &quot;; &#125; LinkedList&lt;Component&gt; list = this.getChilder(); System.out.println(str + name); for (Component c : list) &#123; c.operation(index+1); &#125; &#125; public void add(Component com) &#123; this.childer.add(com); &#125; public void remove(Component com) &#123; this.childer.remove(com); &#125; public LinkedList&lt;Component&gt; getChilder()&#123; return this.childer; &#125; &#125; main方法实现 123456789101112131415161718192021222324public static void main(String[] args) &#123; Composite root = new Composite(&quot;root&quot;); Composite branch = new Composite(&quot;branch&quot;); Composite branch1 = new Composite(&quot;branch1&quot;); Composite branch2 = new Composite(&quot;branch2&quot;); Composite branch3 = new Composite(&quot;branch3&quot;); branch.add(new Leaf(&quot;leaf1&quot;)); branch.add(new Leaf(&quot;leaf2&quot;)); branch1.add(new Leaf(&quot;leaf3&quot;)); branch2.add(new Leaf(&quot;leaf4&quot;)); branch1.add(branch2); branch2.add(new Leaf(&quot;leaf5&quot;)); branch2.add(new Leaf(&quot;leaf6&quot;)); branch3.add(new Leaf(&quot;leaf7&quot;)); branch3.add(new Leaf(&quot;leaf8&quot;)); branch2.add(branch3); root.add(branch); root.add(branch1); root.operation(0); &#125; 运行结果 12345678910111213root branch leaf1 leaf2 branch1 leaf3 branch2 leaf4 leaf5 leaf6 branch3 leaf7 leaf8 三、UML类图 四、笔记oo原则 封装变化 多用组合，少用继承 针对接口编程，不针对实现编程 为交互对象之间的松耦合设计而努力 类应该对扩展开放，对修改关闭 依赖抽象，不依赖具体类 只和朋友交谈 别找我，我会找你 类应该只有一个改变的理由 组合模式：允许你将对象组成树形结构来表现“整体／部分”的层次结构，组合能让客户以一致的方式处理个别对象和对象组合。 组合也可以和迭代器一起使用 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 状态模式]]></title>
    <url>%2F20180908.html</url>
    <content type="text"><![CDATA[之前学习的是组合模式和迭代器模式，迭代器模式已经实现了，但是组合模式，涉及到递归，没怎么理解透彻，因此准备最后攻克难关 一、对于状态模式的理解状态就像初中学习的物理一样（水），水是液态的、加热之后就变成了蒸汽就是雾态、结冰了就是固态。我们就可以描述水的不同状态。例如经常在公共场所会遇到自动售货机，没有用户投币的时候就可以理解为一种状态，投币之后是一种投币状态、用户选择产品就是一种选择状态、售货机从货架推出产品就是一种出售状态、产品卖空了就是一种售罄状态。如果我们只写一个类用if else去实现这种功能，就会有很多重复的代码。后期添加新的功能也特别不方便，需要改动的源代码也特别多。但是用状态模式去管理这些状态的话，后期添加新的功能，就会是一件很轻松的事情。而且对于后期的维护，也会大有裨益。状态模式就是将所有不同的状态都封装成类，最后通过一个展示的类去调用这些状态类，当然所有的状态类都实现了一个状态接口，方便利用多态在展示的类中去调用。最后实现，通过同一种调用方式，可以改变不同的状态。在不同的状态下，同一个方法，可以实现不同的业务逻辑。状态模式的定义：允许对象在内部状态改变时改变它的行为，对象看起来像是修改了它的类 二、代码实现创建状态接口，并创建通用的投币、退币、选择产品、出货等方法 1234567// 状态接口public interface State &#123; public void insertMoney(); // 投币 public void exitMoney(); // 退币 public void selectProduct(); // 选择产品 public void dispense(); // 发放产品&#125; 创建自动售货机类 123456public class AutoSales &#123; State soldOutState; State noMoneyState; State hasMoneyState; State soldState;&#125; 创建售罄类实现状态接口 1234567891011121314151617181920212223242526272829303132// 售謦状态public class SoldOutState implements State&#123; AutoSales autoSales; public SoldOutState() &#123; super(); &#125; public SoldOutState(AutoSales as) &#123; this.autoSales = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;以售罄，请不要投币&quot;); this.autoSales.setState(this.autoSales.getSoldOutState()); // 将状态改为售罄 &#125; @Override public void exitMoney() &#123; System.out.println(&quot;以售罄，无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;以售罄，无法选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;以售罄，无法获得产品&quot;); &#125;&#125; 待投币状态实现状态接口 1234567891011121314151617181920212223242526272829303132// 没有投币的状态public class NoMoneyState implements State&#123; AutoSales as; public NoMoneyState() &#123; super(); &#125; public NoMoneyState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;投币了&quot;); this.as.setState(this.as.getHasMoneyState()); // 将状态改为以投币 &#125; @Override public void exitMoney() &#123; System.out.println(&quot;没有投币，无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;没有投币，无法选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;没有投币，无法出货&quot;); &#125; &#125; 已投币状态也实现状态接口 123456789101112131415161718192021222324252627282930313233// 已投币public class HasMoneyState implements State&#123; AutoSales as; public HasMoneyState() &#123; super(); &#125; public HasMoneyState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;又投币了&quot;); &#125; @Override public void exitMoney() &#123; System.out.println(&quot;开始退币了&quot;); this.as.setState(this.as.getNoMoneyState()); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;发放产品&quot;); this.as.setState(this.as.getSoldState()); &#125; &#125; 已售出状态实现状态接口 1234567891011121314151617181920212223242526272829303132333435// 售出状态public class SoldState implements State&#123; AutoSales as; public SoldState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;又投币了&quot;); &#125; @Override public void exitMoney() &#123; System.out.println(&quot;产品已售出,无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;出货&quot;); if (this.as.getCount() &gt;0 ) &#123; this.as.setState(as.getNoMoneyState()); // 将状态变为没投币之前 &#125; else &#123; System.out.println(&quot;产品卖完了&quot;); this.as.setState(as.getSoldOutState()); // 将状态变为售罄 &#125; &#125;&#125; 完善自动售货机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 自动售货机public class AutoSales &#123; State soldOutState; State noMoneyState; State hasMoneyState; State soldState; State state = soldState; int count = 0; public AutoSales(int num) &#123; this.count = num; soldOutState = new SoldOutState(this); noMoneyState = new NoMoneyState(this); hasMoneyState = new HasMoneyState(this); soldState = new SoldState(this); if (num&gt;0) &#123; state = noMoneyState; &#125; &#125; // 投币 public void insertMoney()&#123; state.insertMoney(); &#125;; // 退币 public void exitMoney()&#123; this.state.exitMoney(); &#125;; // 选择产品 public void selectProduct()&#123; this.state.selectProduct(); &#125;; // 发放产品 public void dispense()&#123; this.state.dispense(); &#125;; public void setState(State state) &#123; this.state = state; &#125; public State getSoldOutState() &#123; return soldOutState; &#125; public State getNoMoneyState() &#123; return noMoneyState; &#125; public State getHasMoneyState() &#123; return hasMoneyState; &#125; public State getSoldState() &#123; return soldState; &#125; public State getState() &#123; return state; &#125; public int getCount() &#123; return count; &#125; @Override public String toString() &#123; return &quot;AutoSales [售罄=&quot; + soldOutState.getClass() + &quot;, 待投币=&quot; + noMoneyState.getClass() + &quot;, 已投币=&quot; + hasMoneyState.getClass() + &quot;, 出售=&quot; + soldState.getClass() + &quot;, state状态=&quot; + state.getClass() + &quot;, count=&quot; + count + &quot;]&quot;; &#125;&#125; main方法运行 1234567891011121314151617181920public static void main(String args[]) &#123; // 给自动售货机装5个产品 AutoSales as = new AutoSales(5); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.insertMoney(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.selectProduct(); as.dispense(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.exitMoney(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.insertMoney(); as.selectProduct(); as.insertMoney(); as.selectProduct(); as.dispense(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); &#125; 运行结果 1234567891011121314--当前状态：class study.state.NoMoneyState投币了--当前状态：class study.state.HasMoneyState选择产品发放产品--当前状态：class study.state.SoldState产品已售出,无法退币--当前状态：class study.state.SoldState又投币了选择产品又投币了选择产品出货--当前状态：class study.state.NoMoneyState 三、UML类图 四、笔记oo原则 封装变化 多用组合、少用继承 针对接口编程，不针对实现编程 对修改关闭，对增加开放 你不要来找我，我来找你 为交互之间的松耦合设计而努力 依赖抽象，不依赖具体类 只和朋友交谈 类应该只有一个被改变的理由 状态模式定义： 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信朋友圈python爬虫]]></title>
    <url>%2F20180907.html</url>
    <content type="text"><![CDATA[安装环境 virtualenv vir // 安装虚拟环境 pip install itchat // 安装微信插件 报错No matching distribution found for itchat之后通过https://www.jianshu.com/p/832245fc7276解决了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－单例模式]]></title>
    <url>%2F20180905.html</url>
    <content type="text"><![CDATA[之前学习是简单工厂模式、工厂方法模式、抽象工厂模式，复习一下 简单工厂模式简单工厂模式大概就是创建一个简单工厂类，由工厂类实例化对象。由参数决定实例化那个类 工厂方法模式创建一个抽象工厂类，里面包含一个抽象方法。由这个工厂去生产产品，具体的就是实现类实现工厂，并完成抽象方法的功能实现（如月饼抽象生产类，南方月饼类实现月饼抽象生产类，北方月饼实现月饼抽象生产类，等等）。调用不是由参数决定，是由创建者决定 抽象工厂模式创建抽象工厂类生产工厂，创建抽象产品类生产产品，并各自实现。形成产品族（一个大的家族）对于之前的理解模糊可以看这个：https://www.zhihu.com/question/20367734 一、 对单例模式的理解单例模式就像太阳一样，只有一个。在使用的时候，只能实例化一次。不能多次实例化。二、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 单例模式 太阳（synchronized，重量级）public class sun &#123; private static sun s = null; private sun() &#123;&#125; // 单例模式 这种方式多线程时会出现混乱的情况，不建议使用 public static sun getSun() &#123; if (s == null) &#123; s = new sun(); &#125; return s; &#125; // (同步方法)添加同步锁，在不考虑性能的时候可以使用该方法 public static synchronized sun getSunSyn() &#123; if (s == null) &#123; s = new sun(); &#125; return s; &#125;&#125;// 月亮（双重检查加锁）class moon &#123; // volatile 当moon初始化为实例时，能保证多个线程正确的处理moon变量 private volatile static moon m; private moon() &#123;&#125;; // 减少synchronized的使用 public static moon getMoon() &#123; if (m == null) &#123; synchronized (moon.class) &#123; if (m == null) &#123; m = new moon(); &#125; &#125; &#125; return m; &#125;&#125;// 地球（急切）class earth&#123; // 在静态初始化器中创建单件，这段代码保证了线程安全 private static earth e = new earth(); private earth()&#123;&#125;; // 在jvm 加载这个类的时候创建此唯一的单例模式。 public static earth getEarth() &#123; return e; &#125;&#125; 三、UML类图 四、笔记oo设计原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为对象之间的松耦合设计而努力 类应该对扩展开发、修改关闭 依赖抽象、不要依赖具体类单例模式定义：确保一个类只有一个实例，并提供全局访问点 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－命令模式]]></title>
    <url>%2F201809018.html</url>
    <content type="text"><![CDATA[之前学习的是单例模式。但里模式就是只有一个对象被实例化，如注册表等。单例模式有几种实现方式一是用同步锁创建一个私有的构造器，和一个同步的公开的方法。这种方式简便，但是性能不是很好，使用的是同步锁（重量级的）。二是创建一个静态产量直接new一个对象。也是有私有的构造器不让对象创建。通过公开的方法返回静态常量new的对象，保证对象只有一个。这种方法在jvm创建的时候就会产生对象，如果不使用该对象，则会产生浪费三是用volatile创建静态属性。用私有构造器不让对象创建，通过公开的get方法获取对象，获取的时候判断对象是否存在，如果不存在则用同步锁防止多线程出现错误。最后返回对象。这种是常用的方法。 一、对于命令模式的理解一个命令执行一个操作。每个命令都是一个操作。不用去关心对象是怎么做的，只需要发送命令即可。就像传菜员一样。 二、 代码实现创建一个命令接口 12345// 命令接口public interface Command &#123; public void execute(); // 执行 public void undo(); // 撤销&#125; 在创建一个电视 123456789// 电视public class TV &#123; public void on() &#123; System.out.println(&quot;开电视&quot;); &#125; public void off() &#123; System.out.println(&quot;关电视&quot;); &#125;&#125; 创建一个开电视命令 123456789101112131415161718// 开电视public class TVOnCommand implements Command&#123; TV tv; public TVOnCommand(TV tv) &#123; this.tv = tv; &#125; @Override public void execute() &#123; tv.on(); &#125; @Override public void undo() &#123; System.out.println(&quot;开电视撤销准备。。。&quot;); tv.off(); &#125;&#125; 创建一个关电视命令 1234567891011121314151617public class TVOffCommand implements Command&#123; TV tv; public TVOffCommand(TV tv) &#123; this.tv = tv; &#125; @Override public void execute() &#123; tv.off(); &#125; @Override public void undo() &#123; System.out.println(&quot;关电视撤销准备。。。&quot;); tv.on(); &#125;&#125; 创建一个简单的远程控制器（遥控器） 1234567891011121314151617// 简单远程控制public class SimpleRemoteController &#123; Command command; Command undoCommand; public SimpleRemoteController()&#123;&#125;; // 利用有参构造器初始化命令 public void setCommand(Command command) &#123; this.command = command; &#125; public void start() &#123; command.execute(); this.undoCommand = this.command; &#125; public void undo() &#123; this.undoCommand.undo(); &#125;&#125; main方法实现 123456789101112131415public static void main(String args[]) &#123; // 创建远程控制器 SimpleRemoteController simpleRemoteController = new SimpleRemoteController(); TV tv = new TV(); // 创建电视 TVOnCommand tvon = new TVOnCommand(tv); // 创建关电视命令 simpleRemoteController.setCommand(tvon); // 通过远程控制器设置关电视的命令 simpleRemoteController.start(); // 按开始按钮 simpleRemoteController.undo(); TVOffCommand tvoff = new TVOffCommand(tv); // 创建关电视命令 simpleRemoteController.setCommand(tvoff); // 通过远程控制器设置关电视的命令 simpleRemoteController.start(); // 按开始按钮 simpleRemoteController.undo();&#125; 运行结果 123456开电视开电视撤销准备。。。关电视关电视关电视撤销准备。。。开电视 实现宏命令（实现一组命令）创建宏命令 123456789101112131415161718192021// 宏命令public class MacroCommand implements Command&#123; Command[] commands; public MacroCommand(Command[] command)&#123; this.commands = command; &#125; @Override public void execute() &#123; for(Command c : this.commands )&#123; c.execute(); &#125; &#125; @Override public void undo() &#123; for(Command c : this.commands )&#123; c.undo(); &#125; &#125;&#125; 创建宏的远程控制 12345678910111213141516171819// 遥控器public class RemoteController &#123; Command[] onCommands; Command[] offCommands; public RemoteController () &#123; this.onCommands = new Command[2]; this.offCommands = new Command[2]; &#125; public void setCommand(int index, Command on,Command off) &#123; this.onCommands[index] = on; this.offCommands[index] = off; &#125; public void on(int index) &#123; this.onCommands[index].execute(); &#125; public void off(int index) &#123; this.offCommands[index].execute(); &#125;&#125; 创建一个电脑操作类 12345678public class Computer &#123; public void on() &#123; System.out.println(&quot;开电脑&quot;); &#125; public void off() &#123; System.out.println(&quot;关电脑&quot;); &#125;&#125; 关电脑命令 1234567891011121314151617public class ComputerOffCommand implements Command&#123; Computer computer; public ComputerOffCommand(Computer com) &#123; this.computer = com; &#125; @Override public void execute() &#123; this.computer.off(); &#125; @Override public void undo() &#123; System.out.println(&quot;关电脑撤销准备。。。&quot;); this.computer.on(); &#125;&#125; 开电脑命令 1234567891011121314151617public class ComputerOnCommand implements Command&#123; Computer computer; public ComputerOnCommand(Computer computer) &#123; this.computer = computer; &#125; @Override public void execute() &#123; this.computer.on(); &#125; @Override public void undo() &#123; System.out.println(&quot;开电脑撤销准备。。。&quot;); this.computer.off(); &#125;&#125; main方法运行 1234567891011121314Computer computer = new Computer();RemoteController remoteController = new RemoteController();ComputerOffCommand coffc = new ComputerOffCommand(computer);ComputerOnCommand conc = new ComputerOnCommand(computer);// 实现宏命令Command[] on = &#123;tvon, conc&#125;;Command[] off = &#123;tvoff,coffc&#125;;MacroCommand onmc = new MacroCommand(on);MacroCommand offmc = new MacroCommand(off);remoteController.setCommand(0, onmc, offmc);System.out.println(&quot;宏命令结束&quot;);remoteController.on(0);System.out.println(&quot;单独执行&quot;);remoteController.off(0); 运行结果 123456宏命令结束开电视开电脑单独执行关电视关电脑 三、UML类图 四、笔记 封装变化 多用组合少用继承 针对接口编程，不针对实现编程 为交互对象之间的松耦合设计而努力 对扩展开放、对修改关闭 依赖抽象，不依赖具体类 命令模式定义： 将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其它对象。命令模式也可以支持撤销操作。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－模版方法模式]]></title>
    <url>%2F201809020.html</url>
    <content type="text"><![CDATA[之前学习的是适配器模式与外观模式。 对外观模式与适配器模式的理解适配器模式的意思就是适配，将三孔插座转换为二孔插座的转换头。通过适配器可以将两个不一样的接口（有共同点）适配在一起。外观模式就是统一接口，将很多方法，统一在一个类里面实现。让使用者不会感觉方法太多杂乱。就像一个开关控制所有电器，和每个电器单独使用的一样。如果使用一个开关控制所有，就会特别方便。但是之前的开关也存在，如果需要单独使用，也是可以的。 先看下定义 模版方法：在一个方法中定义一个算法的骨架，而将一些步骤延伸到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 一、 对模版方法的理解模版方法就是将重复的方法封装在一个类中，变动的方法就用抽象方法抽象出来。将方法模版化，其它子类使用的时候，公用的方法就不用再次实现类，只需要实现抽象方法。大大的降低类代码的重复。比较好玩的就是钩子方法，可以通过子类控制父类的通用方法，很方便。我用炒大白菜和炒生菜举了个例子。 二、 代码实现创建烹饪抽象类123456789101112131415161718192021222324252627282930public abstract class Cooking &#123; // 准备烹饪 public void prepareCooking() &#123; WashingVegetables(); addVegetables(); addSalt(); // 根据菜的样式判断是否加辣椒 if (isChiliHooks()) &#123; addChili(); &#125; &#125; // 洗菜 public void WashingVegetables() &#123; System.out.println(&quot;洗菜&quot;); &#125; // 加盐 public void addSalt()&#123; System.out.println(&quot;加盐&quot;); &#125; // 加辣椒 public void addChili() &#123; System.out.println(&quot;加辣椒&quot;); &#125; // 是否加辣椒钩子 public boolean isChiliHooks() &#123; return true; &#125; // 放菜进锅炒，根据不同的实现，炒不同的菜 abstract void addVegetables();&#125; 创建大白菜类，大白菜重构类模版方法的抽象方法，放入类大白菜123456789// 大白菜public class ChineseCabbage extends Cooking&#123; @Override void addVegetables() &#123; System.out.println(&quot;放入大白菜&quot;); &#125;&#125; 创建生菜类，也实现类抽象方法。最后重写类父类的钩子，实现类不加辣椒 123456789101112// 炒生菜public class lettuce extends Cooking&#123; @Override void addVegetables() &#123; System.out.println(&quot;放入生菜&quot;); &#125; // 不放辣椒 public boolean isChiliHooks() &#123; return false; &#125;&#125; main方法实现 1234567public static void main(String agrs[]) &#123; ChineseCabbage cc = new ChineseCabbage(); cc.prepareCooking(); System.out.println(&quot;+++++++++&quot;); lettuce lt = new lettuce(); lt.prepareCooking(); &#125; 运行结果 12345678洗菜放入大白菜加盐加辣椒+++++++++洗菜放入生菜加盐 三、UML类图 四、笔记 封装变化 多用组合、少用继承 面向接口编程、不面向实现编程 只和朋友交谈 对修改关闭、对扩展开放 为交互对象之间的松耦合设计而努力 别找我、我会找你（好莱坞原则） 依赖抽象、不要依赖具体类 巩固模版方法定义: 在一个方法中定义一个算法的骨架，而将一些步骤延伸到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－适配器与外观模式]]></title>
    <url>%2F20180904.html</url>
    <content type="text"><![CDATA[之前学习的是命令模式 对于命令模式的理解命令模式就是将操作封装为一个类（一个命令）。在通过一个控制器把命令封装进去，就像一个遥控器，最后通过不同的命令就可以实现不同的操作 一、 对适配器模式和观察者模式的理解适配器模式就是改变一个接口，实现不同的操作。就像插座转换头一样，将三孔插座转换为二孔插座。外观模式字面上就是好的形象的意识。将一些操作集合在一起，统一调用，简单又方便。就像家里面的插头到处都是。我们可以把所有的插头都插在一个大插板上面。每次使用的时候，就可以只用开、关大插板就可以。不用每次都插很多插头。 二、代码实现适配器模式三孔插座1234567891011// 三孔插座public interface SocketThree &#123; public void chargeThree();&#125;class SocketThreeImpl implements SocketThree&#123; @Override public void chargeThree() &#123; System.out.println(&quot;三孔插座&quot;); &#125;&#125; 两孔插座123456789101112// 两孔插座public interface SocketTwo &#123; public void chargeTwo();&#125;class SocketTwoImpl implements SocketTwo&#123; @Override public void chargeTwo() &#123; System.out.println(&quot;两孔插座&quot;); &#125; &#125; 插座适配器123456789101112// 插座适配器 将三孔插座转换为二孔插座， 看着像二孔，但是实际上还是三孔public class SocketAdapter implements SocketTwo&#123; SocketThree socketThree; public SocketAdapter(SocketThree socketThree) &#123; this.socketThree = socketThree; &#125; @Override public void chargeTwo() &#123; System.out.println(&quot;转换后的两孔插座&quot;); this.socketThree.chargeThree(); &#125;&#125; main方法运行 123456// 适配器模式 SocketThree st = new SocketThreeImpl(); st.chargeThree(); // 通过转换器将三孔插座转换为两孔插座 SocketTwo stwo = new SocketAdapter(st); stwo.chargeTwo(); 运行结果123三孔插座转换后的两孔插座三孔插座 外观模式新建电视、电灯、烤火炉类12345678910111213141516171819202122232425public class TV &#123; public void on() &#123; System.out.println(&quot;开电视&quot;); &#125; public void off() &#123; System.out.println(&quot;关电视&quot;); &#125;&#125;class Light&#123; public void on() &#123; System.out.println(&quot;开电灯&quot;); &#125; public void off() &#123; System.out.println(&quot;关电灯&quot;); &#125;&#125;class Stove&#123; public void on() &#123; System.out.println(&quot;开火炉&quot;); &#125; public void off() &#123; System.out.println(&quot;关火炉&quot;); &#125;&#125; 大插板（不让插头凌乱，外观好看）12345678910111213141516171819202122// 买了一个大插板，将电视、烤火炉、电灯的插头都插在这个大插板上面public class FacadeSocket &#123; TV tv; Light light; Stove stove; public FacadeSocket(TV tv,Light light,Stove stove) &#123; this.tv = tv; this.light = light; this.stove = stove; &#125; // 通过外观模式统一处理 public void on() &#123; this.tv.on(); this.light.on(); this.stove.on(); &#125; public void off() &#123; this.tv.off(); this.light.off(); this.stove.off(); &#125;&#125; main方法实现12345678910public static void main(String srgs[])&#123; // 外观模式 TV tv = new TV(); Light light = new Light(); Stove stove = new Stove(); // 创建大插板， 统一开关 FacadeSocket fs = new FacadeSocket(tv, light,stove); fs.on(); fs.off();&#125; 运行结果123456开电视开电灯开火炉关电视关电灯关火炉 三、UML类图 四、笔记oo设计原则 封装变化 依赖接口编程，不依赖实现编程 为交互对象之间的松耦合设计而努力 对修改关闭、对扩展开放 多用组合，少用继承 依赖抽象、不依赖具体类 只和朋友交谈 适配器模式定义： 将一个类的接口，转移成为可以期望的另一个接口。适配器让原本不兼容的两个类可以合作无间 外观模式定义： 提供类一个统一的接口，用来访问子系统中的一群接口。外观定义类一个高层接口，让子系统更容易使用。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－迭代器模式]]></title>
    <url>%2F20180902.html</url>
    <content type="text"><![CDATA[昨天学习的是模版方法模式复习一下 对于模版方法的理解：模版方法模式就是创建一个模版类，并创建一个抽象方法，和调用方法。该方法（一般是静态方法，不能修改的）调用复用的模版类方法（实现通用的业务逻辑）和抽象方法。子类继承模版类之后，重写抽象方法（不同的业务逻辑）。模版类中可以设置钩子方法，用于控制模版类的通用方法是否调用。这样做的好处就是可以子类可以调用很多通用的方法，减少大量的重复代码。抽象方法也可以实现子类独有的方法。钩子还可以控制通用方法。使方法调用更加的灵活。模版方法就是为类的方法创建特别灵活的模版。 一、对于迭代器的理解通过看书之后，我觉得迭代器就是一个可以遍历所有不同集合类型对象的的一种方式。如用ArrayList, new [], HashMap等集合存储对象数据。如果要遍历就需要写三个for循环才可以完成遍历。但是有迭代器之后，就可以用一个迭代器完成三种不同类型的集合的遍历。总结出来就是：迭代器可以遍历所有实现了迭代器接口的不同类型的集合 二、代码实现实现思路：创建一个宠物类，有动物的名字、年龄、简介等。动物生病了就会找医生。每个医生都有自己的笼子，张医生的笼子使用ArrayList制作的。李医生的笼子使用Animal[]制作的。两个医生都在同一个宠物店里面上班。医生太忙了，领导来医院视察的时候，需要服务员小花去给领导报告两位医生的宠物都叫什么名字，年龄多少、宠物具体的情况等。如果没有迭代器，小花就需要拿张医生的ArrayList笼子的钥匙去看，李医生的钥匙和张医生的钥匙又不一样，每次都要拿不同的钥匙看不同的笼子，特别麻烦。而且还要去每个医生的工作区域才可以。但是有了迭代器，小花就不用拿这个多钥匙了，只要一种钥匙，而且不用去两个工作区域查看，就感觉像迭代器将宠物汇总了。小花只要拿一种钥匙，不用知道医生使用什么笼子关宠物的，只需要在一个地方查看在记录好报告领导就可以了。下面看代码。 1、 自己创建一个迭代器实现创建一个动物类 1234567891011121314151617181920// 动物类public class Animal &#123; String name; int age; String description; public Animal(String name, int age, String des) &#123; this.name = name; this.age = age; this.description = des; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getDescription() &#123; return description; &#125;&#125; 创建张医生和李医生，用不同的笼子关动物 123456789101112131415161718192021222324252627282930313233343536373839404142// 张医生用ArrayList笼子关动物public class DoctorZhang &#123; ArrayList ans; public DoctorZhang() &#123; ans = new ArrayList(); addAnimal(&quot;小狗&quot;,8, &quot;黄色的小狗&quot;); addAnimal(&quot;小猫&quot;,4, &quot;黑色的小猫&quot;); addAnimal(&quot;小猪&quot;,4, &quot;白色的小猪&quot;); &#125; // 增加动物方法 public void addAnimal(String name, int age, String des)&#123; Animal an = new Animal(name, age, des); this.ans.add(an); &#125; public Iterator createIterator() &#123; return new DoctorZhangIterator(this.ans); &#125;&#125;// 李医生用［］笼子关动物class DoctorLi&#123; static final int MAX=5; int number = 0; Animal[] animal; public DoctorLi() &#123; animal =new Animal[MAX]; addAnimal(&quot;小乌龟&quot;,8, &quot;黄色的小乌龟&quot;); addAnimal(&quot;小猴&quot;,4, &quot;黑色的小猴&quot;); addAnimal(&quot;大猪&quot;,4, &quot;黄色的大猪&quot;); &#125; // 增加动物方法 public void addAnimal(String name, int age, String des)&#123; if (number&gt;=MAX)&#123; return; &#125; Animal an = new Animal(name, age, des); this.animal[number] = an; this.number++; &#125; public Iterator createIterator() &#123; return new DoctorLiIterator(this.animal); &#125;&#125; 创建一个迭代器，并用张医生李医生去实现迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 迭代器接口public interface Iterator &#123; boolean hasNext(); Object next();&#125;// 李医生迭代器实现迭代器接口class DoctorZhangIterator implements Iterator&#123; ArrayList ans; int index = 0; public DoctorZhangIterator(ArrayList ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.size() || ans.get(index) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans.get(index); index ++; return animal; &#125; &#125;//张医生迭代器实现迭代器接口class DoctorLiIterator implements Iterator&#123; Animal[] animal; int index = 0; public DoctorLiIterator(Animal[] animal) &#123; this.animal = animal; &#125; @Override public boolean hasNext() &#123; if (index &gt;= animal.length || animal[index] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal an = animal[index]; index ++; return an; &#125; &#125; 创建一个宠物店类 12345678910111213141516171819202122232425// 宠物店public class PetShop &#123; DoctorZhang zhang; DoctorLi li; public PetShop(DoctorZhang zhang,DoctorLi li) &#123; this.zhang = zhang; this.li = li; &#125; // 小花就用这个方法统计宠物 public void printAnimal() &#123; Iterator it = zhang.createIterator(); Iterator its = li.createIterator(); System.out.println(&quot;张医生的宠物&quot;); printAnimal(it); System.out.println(&quot;李医生的宠物&quot;); printAnimal(its); &#125; private void printAnimal(Iterator it) &#123; while(it.hasNext()) &#123; Animal an = (Animal)it.next(); System.out.println(&quot;名字为：&quot;+an.getName()+&quot; 年龄为：&quot;+an.getAge() + &quot; 介绍：&quot;+an.getDescription()); &#125; &#125;&#125; main方法实现－－ 领导来视察了，小花就去统计 123456public static void main(String args[]) &#123; DoctorZhang zhang =new DoctorZhang(); DoctorLi li = new DoctorLi(); PetShop ps =new PetShop(zhang, li); ps.printAnimal();&#125; 运行结果 12345678张医生的宠物名字为：小狗 年龄为：8 介绍：黄色的小狗名字为：小猫 年龄为：4 介绍：黑色的小猫名字为：小猪 年龄为：4 介绍：白色的小猪李医生的宠物名字为：小乌龟 年龄为：8 介绍：黄色的小乌龟名字为：小猴 年龄为：4 介绍：黑色的小猴名字为：大猪 年龄为：4 介绍：黄色的大猪 2、用上面的代码重构为java util 类里面的迭代器实现动物类不变动，改动两个医生的代码迭代器为。注意迭代器换为了import java.util.Iterator; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 张医生实现java util里面的迭代器public class DoctorZhangIteratorJavaUtil implements Iterator&#123; Animal[] ans; int index = 0; public DoctorZhangIteratorJavaUtil(Animal[] ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.length || ans[index] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans[index]; index ++; return animal; &#125; public void remove() &#123; if (index &lt;=0) &#123; throw new IllegalStateException(&quot;没有可以删除的了&quot;); &#125; if(ans[index-1] !=null) &#123; for(int i = index-1; i&lt;(ans.length -1); i++) &#123; ans[i] = ans[i+1]; &#125; ans[ans.length - 1] = null; &#125; &#125;&#125;class DoctorLiIteratorJavaUtil implements Iterator&#123; ArrayList ans; int index = 0; public DoctorLiIteratorJavaUtil(ArrayList ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.size() || ans.get(index) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans.get(index); index ++; return animal; &#125;&#125; 改动两个医生的代码为。注意迭代器换为了import java.util.Iterator; ｀// 张医生用ArrayList区分动物public class DoctorLiJavaUtil implements Doctor{ ArrayList ans; public DoctorLiJavaUtil() { ans = new ArrayList(); addAnimal(“小狗”,8, “黄色的小狗”); addAnimal(“小猫”,4, “黑色的小猫”); addAnimal(“小猪”,4, “白色的小猪”); } // 增加动物方法 public void addAnimal(String name, int age, String des){ Animal an = new Animal(name, age, des); this.ans.add(an); } public Iterator createIterator() { // 直接使用ArrayList的迭代器 return this.ans.iterator(); }}// 李医生用［］区分动物class DoctorZhangJavaUtil implements Doctor{ static final int MAX=5; int number = 0; Animal[] animal; public DoctorZhangJavaUtil() { animal =new Animal[MAX]; addAnimal(“小乌龟”,8, “黄色的小乌龟”); addAnimal(“小猴”,4, “黑色的小猴”); addAnimal(“大猪”,4, “黄色的大猪”); } // 增加动物方法 public void addAnimal(String name, int age, String des){ if (number&gt;=MAX){ return; } Animal an = new Animal(name, age, des); this.animal[number] = an; this.number++; } public Iterator createIterator() { return new DoctorZhangIteratorJavaUtil(this.animal); }}// 新增的医生接口interface Doctor { public Iterator createIterator();}1更改宠物店的代码 // 宠物店import java.util.Iterator;public class PetShopJavaUtil { Doctor zhang; Doctor li; public PetShopJavaUtil(Doctor zhang,Doctor li) { this.zhang = zhang; this.li = li; } public void printAnimal() { Iterator it = zhang.createIterator(); Iterator its = li.createIterator(); System.out.println(&quot;张医生的宠物&quot;); printAnimal(it); System.out.println(&quot;李医生的宠物&quot;); printAnimal(its); } private void printAnimal(Iterator it) { if (it == null) { return; } while(it.hasNext()) { Animal an = (Animal)it.next(); System.out.println(&quot;名字为：&quot;+an.getName()+&quot; 年龄为：&quot;+an.getAge() + &quot; 介绍：&quot;+an.getDescription()); } } } 1main方法运行 public static void main(String args[]) { // java.util 迭代器使用 System.out.println(&quot;++++++++++++++++java.util 迭代器 &quot;); DoctorZhangJavaUtil zhangJavaUtil =new DoctorZhangJavaUtil(); DoctorLiJavaUtil liJavaUtil = new DoctorLiJavaUtil(); PetShopJavaUtil psJavaUtil =new PetShopJavaUtil(zhangJavaUtil, liJavaUtil); psJavaUtil.printAnimal(); } 12运行结果 ++++++++++++++++java.util 迭代器张医生的宠物名字为：小乌龟 年龄为：8 介绍：黄色的小乌龟名字为：小猴 年龄为：4 介绍：黑色的小猴名字为：大猪 年龄为：4 介绍：黄色的大猪李医生的宠物名字为：小狗 年龄为：8 介绍：黄色的小狗名字为：小猫 年龄为：4 介绍：黑色的小猫名字为：小猪 年龄为：4 介绍：白色的小猪` 三、UML类图 四、笔记 封装变化 多用组合,少用继承 面向接口编程，不面向实现编程 为交互对象之间的松耦合设计而努力 对扩展开放，对修改关闭 只跟朋友交谈 依赖抽象不要依赖具体类 别找我，我会找你 类应该只有一个被改变的理由 迭代器模式定义： 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴其露内部的表示 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－工厂模式]]></title>
    <url>%2F201809017.html</url>
    <content type="text"><![CDATA[之前学的是装饰者模式 装饰者模式的优点动态地为对象增加新的功能或者撤销功能（继承就不能做到这一点） 装饰者模式的缺点会产生过多的相似的对象！ 一、对工厂模式的理解简单工厂：通过工厂类生成不同的类。工厂类返回一个父类型的类，通过if或者switch判断用户给的数据，通过不同的数据返回不同的类。工厂方法：比较重要的就是抽象类里面的一个抽象方法，所有继承了抽象类的类都必须实现该方法，之后在调用的时候利用多态动态的调用实现类的方法。抽象的方法里面就可以用简单工厂模式实现不同的类 二、代码实现(简单工厂、工厂方法、抽象工厂)1、简单工厂 创建月饼类123456789101112131415161718192021public class MoonCake &#123; public String name; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125;&#125;// 糖陷月饼class sugar extends MoonCake&#123; public sugar()&#123; System.out.println(&quot;糖陷&quot;); &#125;&#125;// 肉陷月饼class meat extends MoonCake &#123; public meat() &#123; System.out.println(&quot;肉馅&quot;); &#125;&#125; 创建简单月饼工厂1234567891011public class SimpleFactory &#123; public MoonCake createProduct(String type) &#123; MoonCake product = null; if (type.equals(&quot;meat&quot;))&#123; product = new meat(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; product = new sugar(); &#125; return product; &#125;&#125; 创建月饼工厂12345678910public class MoonCakeFactory &#123; SimpleFactory factory; public MoonCakeFactory(SimpleFactory factory) &#123; this.factory = factory; &#125; public MoonCake orderMoonCake(String type) &#123; MoonCake product = factory.createProduct(type); return product; &#125;&#125; main方法实现1234567public class run &#123; public static void main(String args[]) &#123; // 简单工厂模式 生产月饼 SimpleFactory simpleFactory = new SimpleFactory(); new MoonCakeFactory(simpleFactory).orderMoonCake(&quot;meat&quot;); &#125;&#125; 运行结果1肉馅 2、工厂方法月饼店抽象类1234567891011// 月饼店public abstract class MoonCakeStore &#123; public MoonCake orderMoonCake(String type) &#123; MoonCake mc; mc = createMoonCake(type); mc.kenad(); return mc; &#125; // 抽象的工厂方法 public abstract MoonCake createMoonCake(String type);&#125; 北方月饼店和南方月饼店123456789101112131415161718192021222324252627// 北方月饼店public class NorthMoonCakeStore extends MoonCakeStore&#123; @Override public MoonCake createMoonCake(String type) &#123; if (type.equals(&quot;meat&quot;)) &#123; return new NorthSytleMeatMoonCake(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new NorthSytleSugarMoonCake(); &#125; return null; &#125;&#125;// 南方月饼店public class SouthMoonCakeStroe extends MoonCakeStore&#123; @Override public MoonCake createMoonCake(String type) &#123; if (type.equals(&quot;meat&quot;)) &#123; return new SouthSytleMeatMoonCake(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new SouthSytleSugarMoonCake(); &#125; return null; &#125;&#125; 月饼父类123456789public class MoonCake &#123; public String name; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125;&#125; 北方月饼和南方月饼12345678910class SouthSytleMeatMoonCake extends MoonCake&#123; public SouthSytleMeatMoonCake() &#123; name =&quot;南方风格的肉馅月饼&quot;; &#125;&#125;class SouthSytleSugarMoonCake extends MoonCake&#123; public SouthSytleSugarMoonCake() &#123; name = &quot;南方风格的糖陷月饼&quot;; &#125;&#125; main方法实现12345678910111213public class run &#123; public static void main(String args[]) &#123; // 工厂方法模式 生产月饼 MoonCakeStore mcs = new SouthMoonCakeStroe(); MoonCakeStore smcs = new NorthMoonCakeStore(); MoonCake mc = mcs.orderMoonCake(&quot;meat&quot;); System.out.println(mc.getName()); MoonCake mc1 = smcs.orderMoonCake(&quot;meat&quot;); System.out.println(mc1.getName()); &#125;&#125; 运行结果1234揉面粉南方风格的肉馅月饼揉面粉北方风格的肉馅月饼 3.抽象工厂 创建一个抽象月饼类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 面粉基类class flour &#123; &#125;// 芝麻基类class sesame&#123; &#125;// 重构之前的抽象月饼类public abstract class MoonCake1 &#123; String name; flour flour; sesame sesame; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125; // 准备 abstract void prepare();&#125;//糖陷月饼class sugar1 extends MoonCake1&#123; MaterailFactory materailFactory; public sugar1()&#123; System.out.println(&quot;糖陷&quot;); &#125; public sugar1(MaterailFactory materailFactory) &#123; name = &quot;糖陷月饼&quot;; this.materailFactory = materailFactory; &#125; @Override void prepare() &#123; System.out.println(&quot;准备制作月饼了&quot;); flour = this.materailFactory.createFlour(); sesame = this.materailFactory.createSesame(); &#125;&#125;//肉陷月饼class meat1 extends MoonCake1 &#123; MaterailFactory materailFactory; public meat1() &#123; System.out.println(&quot;肉馅&quot;); &#125; public meat1(MaterailFactory materail) &#123; this.materailFactory = materail; &#125; @Override void prepare() &#123; flour = this.materailFactory.createFlour(); sesame = this.materailFactory.createSesame(); &#125;&#125; 抽象月饼店123456789101112// 月饼店抽象类 public abstract class MoonCakeStore1 &#123; public MoonCake1 orderMoonCake(String type) &#123; MoonCake1 mc; mc = createMoonCake(type); mc.kenad(); mc.prepare(); return mc; &#125; // 抽象的工厂方法 public abstract MoonCake1 createMoonCake(String type);&#125; 材料接口12345// 材料工厂接口public interface MaterailFactory &#123; public flour createFlour(); public sesame createSesame();&#125; 南方材料工厂实现材料接口12345678910111213141516171819202122232425// 南方材料工厂public class SouthMaterailFactory implements MaterailFactory&#123; @Override public flour createFlour() &#123; return new SouthFlour(); &#125; @Override public sesame createSesame() &#123; return new SouthSesame(); &#125;&#125;// 南方面粉class SouthFlour extends flour&#123; public SouthFlour() &#123; System.out.println(&quot;南方的独特制作的面粉&quot;); &#125;&#125;// 南方芝麻class SouthSesame extends sesame&#123; public SouthSesame() &#123; System.out.println(&quot;南方的独特制作的芝麻&quot;); &#125;&#125; 南方月饼店继承抽象月饼店1234567891011121314// 南方月饼店public class SouthMoonCakeStroe1 extends MoonCakeStore1&#123; @Override public MoonCake1 createMoonCake(String type) &#123; MaterailFactory mf = new SouthMaterailFactory(); if (type.equals(&quot;meat&quot;)) &#123; return new sugar1(mf); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new meat1(mf); &#125; return null; &#125;&#125; 运行代码12345678910public class run &#123; public static void main(String args[])&#123; MoonCakeStore1 mcs1 = new SouthMoonCakeStroe1(); MoonCake1 mc12 = mcs1.orderMoonCake(&quot;meat&quot;); System.out.println(mc12.getName()); MoonCake1 mc11 = mcs1.orderMoonCake(&quot;meat&quot;); System.out.println(mc11.getName()); &#125;&#125; 运行结果12345揉面粉准备制作月饼了南方的独特制作的面粉南方的独特制作的芝麻糖陷月饼 三、UML类图 四、笔记面向对象原则 多用组合，少用继承 针对接口编程、不针对实现编程 为交互之间的松耦合设计而努力 类应该对扩展开发、修改关闭《开闭原则》 依赖抽象、不要依赖具体类《依赖倒置原则》 工厂方法模式定义 定义了一个创建对象的接口，但由于之类子类要决定要实例化哪一个。工厂方法让类的实例推迟到子类 抽象工厂模式定义 提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 注：抽象工厂模式的代码比较复杂，只是做材料的UML类图 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－装饰者模式]]></title>
    <url>%2F201809014.html</url>
    <content type="text"><![CDATA[之前学习的是观察模式，复习观察者模式 观察者模式一般在那些地方使用：比如我们有两个对象，一个对象依赖于另一个对象的变化而变化，此时我们可以将这两个对象抽象出来，做成接口，利用观察者模式来进行解耦，又或者，当一个对象发生变化的时候，需要通知别的对象来做出改变，但又不知道这样的对象有多少个，此时利用观察者模式非常合适。 使用观察者模式的好处：第一、观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。 第二、观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知， 观察者模式有下面的缺点：第一、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。第二、如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。第三、如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。第四、虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。 一、对装饰者模式的理解可以想象为给房子装修，有英式风格的房子、中式风格的房子，英式风格有英式风格的桌子、椅子，中式风格有中式风格的桌子椅子、等等。但是我们在装修房子的时候会自己去找材料，椅子有不同的风格、不同的厂家等。最后我们用这些不同的材料来装饰自己的房子。我们可以建立一个房子的抽象类，用材料去实现房子的抽象类。中式风格的房子、英式风格的房子都去实现房子的抽象类。之后用桌子、椅子具体的实现去继承材料抽象类。这样就可以用多态（父类的引用指向自类的对象），具体的看下面的代码 二、代码实现创建房子抽象类12345678// 房子抽象类public abstract class House &#123; String description = &quot;毛坯房&quot;; // 房子的描述 public String getDescription() &#123; return this.description; &#125; public abstract double cost(); // 房子的成本成本&#125; 创建材料抽象类、继承房子类1234// 装修材料public abstract class Material extends House&#123; public abstract String getDescription(); // 重写获取房子描述的方法&#125; 中式风格的房子类、中式风格椅子类、中式风格桌子类12345678910111213141516171819202122232425262728293031323334353637// 中式风格的房子public class ChineseStyle extends House&#123; public ChineseStyle() &#123; description = &quot;中式风格的房子&quot;; &#125; @Override public double cost() &#123; return 888; &#125;&#125;// 中式风格的椅子class ChineseChair extends Material&#123; House house; public ChineseChair(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;＊＊＊中式风格的椅子&quot;; &#125; public double cost () &#123; return 20 + house.cost(); &#125;&#125;// 中式风格的桌子class ChineseDesk extends Material&#123; House house; public ChineseDesk(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;***中式风格的桌子&quot;; &#125; public double cost () &#123; return 50 + house.cost(); &#125;&#125; 英式风格的房子、英式风格的桌子、英式风格的椅子1234567891011121314151617181920212223242526272829303132333435// 英式风格public class EnglandStyle extends House&#123; public EnglandStyle() &#123; description = &quot;英式风格的房子&quot;; &#125; @Override public double cost() &#123; return 666; &#125;&#125;class EnglandChair extends Material&#123; House house; public EnglandChair(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;＊＊＊英式风格的椅子&quot;; &#125; public double cost () &#123; return 20 + house.cost(); &#125;&#125;class EnglandDesk extends Material&#123; House house; public EnglandDesk(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;***英式风格的桌子&quot;; &#125; public double cost () &#123; return 50 + house.cost(); &#125;&#125; 代码运行 123456789101112131415161718public static void main(String args[]) &#123; House house = new ChineseStyle(); System.out.println(house.getDescription() + &quot;***&quot; +house.cost()); // 英式风格的房子用 一张中式风格的桌子，和两把椅子，一把中式风格的，一把英式风格的椅子 House house1 = new EnglandStyle(); // 英式风格的房子 house1 = new ChineseDesk(house1); house1 = new ChineseChair(house1); house1 = new EnglandChair(house1); System.out.println(house1.getDescription() + &quot;***&quot; +house1.cost()); // 中式风格的房子用 一张中式风格的桌子，和两把椅子，一把中式风格的，一把英式风格的椅子 House house2 = new ChineseStyle(); // 中式风格的房子 house2 = new ChineseDesk(house2); house2 = new ChineseChair(house2); house2 = new EnglandChair(house2); System.out.println(house2.getDescription() + &quot;***&quot; +house2.cost()); // 后面就可以按照自己的喜欢装修自己的房子了 // 其它的家具也可以更加灵活的添加了 &#125; 运行结果 123中式风格的房子***888.0英式风格的房子***中式风格的桌子＊＊＊中式风格的椅子＊＊＊英式风格的椅子***756.0中式风格的房子***中式风格的桌子＊＊＊中式风格的椅子＊＊＊英式风格的椅子***978.0 三、UML类图 四、笔记面向对象原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为交互对象之间的松耦合设计而努力 对扩展开发、对修改关闭 装饰者模式的定义 动态的将责任附加到对象上。想要扩展功能，装饰折提供有别于继承的另一种选择 java 的 io流就是用装饰者模式实现的 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux+elasticsearch+logstash 自动同步mysql实现搜索引擎]]></title>
    <url>%2F20180909.html</url>
    <content type="text"><![CDATA[一、安装elasticsearch作用：将数据放到elasticsearch进行搜索 1、配置elasticsearch的yum源1234567891011vim /etc/yum.repos.d/elasticsearch.repo // 配置yum源// 在elasticsearch.repo（如果没有就新建） 中加入一下内容6.x版本以上，将6改为2即可变更为2.x版本[elasticsearch-6.x]name=Elasticsearch repository for 6.x packagesbaseurl=https://artifacts.elastic.co/packages/6.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md 2、yum安装1yum -y install elasticsearch 3、启动1service elasticsearch start // 启动命令 Starting elasticsearch (via systemctl): [ 确定 ] // 出现这个表示启动成功 二、安装logstash用于将mysql里面的数据同步到elasticsearch 123wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.1.zip // 下载到目录解压文件cd logstash-6.4.1 // 进入logstash文件夹vim mysql.conf // 新建mysql.conf文件 在mysql.conf文件中配置如下信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647input &#123; stdin &#123; &#125; jdbc &#123; # mysql数据库连接 jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost/basesdataName?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC&quot; # mysqly用户名和密码 jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;password&quot; # 驱动配置(可以自己下载mysql-connector-java-6.0.5.jar，填写路径即可) jdbc_driver_library =&gt; &quot;./lib/mysql-connector-java-6.0.5.jar&quot; # 驱动类名 jdbc_driver_class =&gt; &quot;com.mysql.cj.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; # 执行指定的sql文件 statement_filepath =&gt; &quot;./data.sql&quot; # 设置监听 各字段含义 分 时 天 月 年 ，默认全部为*代表含义：每分钟都更新 schedule =&gt; &quot;* * * * *&quot; # 索引类型 type =&gt; &quot;product&quot; &#125; &#125; filter &#123; json &#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125; &#125; output &#123; elasticsearch &#123; #es服务器 hosts =&gt; [&quot;localhost:9200&quot;] #ES索引名称 index =&gt; &quot;sl_product&quot; #自增ID document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125; ｝ 新建data.sql 1234vim data.sql // 新建写入如下内容SELECT * FROM tableName // 查询语句 启动logstash 1bin/logstash -f mysql.conf // 在logstash-6.4.1目录启动，如果其它目录，需要更改路径 三、测试是否安装成功1curl &apos;http://127.0.0.1:9200/_search?pretty&apos; // 出现数据库里面的数据表示成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&#123; &quot;took&quot;: 153, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 15, &quot;successful&quot;: 15, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 6, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;426&quot;, &quot;summary&quot;: null, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.179Z&quot;, &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;@version&quot;: &quot;1&quot;, &quot;id&quot;: 2, &quot;category_id&quot;: null, &quot;sub_image&quot;: null, &quot;status&quot;: 1, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.437Z&quot;, &#125; &#125;, &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;123&quot;, &quot;summary&quot;: &quot;1&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;sub_image&quot;: &quot;test&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.178Z&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;123&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.436Z&quot;, &quot;type&quot;: &quot;product&quot;, &quot;tag_price&quot;: null &#125; &#125;, &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;2018-09-22 12:04:14&quot;, &quot;summary&quot;: &quot;&lt;p&gt;123&lt;/p&gt;&lt;audio controls=\&quot;controls\&quot; style=\&quot;display: none;\&quot;&gt;&lt;/audio&gt;&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;status&quot;: 1, &quot;retail_price&quot;: 12, &quot;sub_image&quot;: &quot;test asdf&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.180Z&quot;, &quot;tag_price&quot;: &quot;123&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;version&quot;: 1, &quot;retail_price&quot;: 12, &quot;add_time&quot;: &quot;2018-09-22 12:04:14&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.442Z&quot; &#125; &#125; ] &#125;&#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7安装git服务器]]></title>
    <url>%2F201809015.html</url>
    <content type="text"><![CDATA[linux安装git，并配置仓库1.安装git,查看版本号yum install -y git git --version 2.创建git用户useradd git //创建用户 password git //更改密码 3.初始化git仓库，并改变仓库权限cd /home/git mkdir -p test.git //创建仓库 git init --bare test.git //初始化 chown -R git:git test.git //改变权限 4.克隆仓库到本地git clone git@119.10.15.56:/home/git/test.git 本地git与远程git交互1.本地初始化git，并上传git init //初始化 git add test.txt //增加文件到暂存区 git commit -m &apos;注释&apos; //提交文件到本地仓库 git remote rm origin //删除之前的remote git remote add origin git@119.106.185.58:/home/test.git //添加远程起源 git push origin master //通过origin原点添加master分支到远程git仓库 2.更新git pull origin master //取回origin主机的master分支，与本地当前分支合并 3.常用上传git add -A //将所有的新文件添加到暂存区 git add test.txt //增加文件到暂存区 git commit -m &apos;注释&apos; //提交文件到本地仓库 git commit -a -m &apos;注释&apos; //将所有的文件提交到本地仓库 git push origin master //通过origin原点添加master分支到远程git仓库 常用git命令git status //查看git状态 git remote -v //查看所有原点 git stash // 暂存 git push origin master --force //强制上传，将本地代码覆盖掉远程代码 分支git branch //看看分支 git chechout aaa //切换分支aaa git branck aaa //创建aaa分支 git chechout -b aaa //本地创建 aaa分支，同时切换到aaa分支。只有提交的时候才会在服务端上创建一个分支 git pull origin master //更新指定分支 git branch -vv // 查看分支跟踪的远程分支 git branch -v // 分支信息 git branch --no-merged // 查看尚未合并的工作 git merge iss53 // 将iss53合并到当前分支 更详细的解释 git钩子自动执行更新1.在初始化git仓库里面找到hooks文件夹，并在里面创建钩子文件vim post-receive //用vim创建文件 chmod 755 post-receive // 更改执行权限 2.编辑自动执行脚本#!/bin/sh PATH=/home/fileDir/ //你需要部署的项目路径。注意文件夹的权限问题 cd $PATH unset $(git rev-parse --local-env-vars) //git的hooks里面默认有一些环境变量,导致无论在哪个语句之后执行git命令都会有默认环境路径,直接unset掉默认的环境变量就好 /usr/bin/git pull //更新项目 sudo /home/sh/git_hook.sh //切换到root用户身份执行自己的脚本 注意：该命令需要在/etc/sudoers 大概91行左右的root ... 下面添加：git ALL=(ALL) NOPASSWD:/home/sh/git_hook.sh（添加是需要改变文件的写权限，否则无法添加） ####3.服务器克隆本地git仓库代码 git clone /home/test.git 注意不要通过git clone git@127.0.0.1/home/test.git导出，会出现git pull需要输入密码导致无法自动化部署。爬了很久的坑 暂时需要使用到的命令就这些。以后遇到了在增加]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux+nginx+tomcat的java项目打包war部署]]></title>
    <url>%2F201809016.html</url>
    <content type="text"><![CDATA[环境：linux centos 7 系统、jdk8+tomcat8+nginx-1.12.1+mysql-5.7.16(jdk,tomcat,mysql是通过阿里云的java环境一键部署的，非阿里云的服务器可以自己搭建环境) 1.将java代码进行war打包 eclipse打包 选择路径，点击finish即可 2.将war包移动到tomcat的webapps目录下面通过ftp或者scp可以直接将本地的代码放到linux服务器上面scp命令：scp 文件名 root@地址:/root （scp test.war root@107.1.0.1:/root） 3.启动tomcat会出现地址被占用 可以用命令：netstat -ltunp 。查看所有的端口号使用情况 如果有（tomcat默认使用8080、8009、8005）端口运行；直接用命令：kill -9 端口号 重启4.安装nginx-1.12.1 安装的sh脚本如下 #!/bin/sh yum install pcre-devel -y yum install openssl-devel -y yum install zlib-devel -y wget http://nginx.org/download/nginx-1.12.1.tar.gz tar -zvxf nginx-1.12.1.tar.gz cd nginx-1.12.1 ./configure make make install cd /usr/local/nginx/sbin/ ./nginx -t /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 详情：https://www.jianshu.com/p/73efd33b9da4 配置nginx.conf文件 server_name 自己的域名 location ^~ /自己的项目 { proxy_pass http://localhost:8080; } 5.重启nginx服务器如果使用的上面的脚本安装的可以使用一下方式停止nginx，和启动nginx 停止nginx: /usr/local/nginx/sbin/nginx -s stop 启动nginx: /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf6.开放nginx默认的80端口阿里云服务器可以直接在配置安全组里面配置 之后就可以通过域名访问啦]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－观察者模式]]></title>
    <url>%2F20180906.html</url>
    <content type="text"><![CDATA[之前学习的是策略模式，复习一下之前的策略模式 策略模式一般在哪方面使用“策略”百科中指[计策]。一般是指：1. 可以实现目标的方案集合；2. 根据形势发展而制定的行动方针和斗争方法；3. 有斗争艺术，能注意方式方法。就是用不同的策略解决不同的问题。如出门的方式有自驾、火车、飞机等。选择不同的出行方式就是不同的策略程序中就是对各个算法的封装。让客服端非常方便的可以调用。我理解为就是在一个类中属性有相同的地方。带式行为方法不同，为了以后添加类特别方便，就可以考虑使用策略模式。 使用策略模式有什么好处 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。 策略模式提供了可以替换继承关系的办法。 使用策略模式可以避免使用多重条件转移语句。 一、对观察者模式的理解： 观察者模式可以理解为很多人去观察一个事物。我打个微信公众好的比喻，就像微信的公众号一样，可以经常给用户推送信息（一周可以给每个用户推送4篇文章）。用户可以取消关注，取消之后，公众号就无法给该用户发送消息了。当用户关注该公众号之后，就可以每月接收文章了。观察者模式可以很好的实现这种功能。话不多说，代码实现功能 二、代码实现观察者模式在java中有两种实现，一种是自己实现，还有一种就是java自带的jdk中已经写好了的，我两种都实现 1、自己用代码实现观察者模式创建公众号接口，用于其他公众号实现 public interface OfficialAccounts { public void follow(User user); // 关注公众号 public void unfollow(User user); // 取消关注 public void sendMessageAll(); // 给所有的用户发送消息 } 创建一个新闻的公众号用于实现公众号接口，新增其它公众号，直接实现OfficialAccounts就好了 // 新闻公众号 public class NewsOfficialAccounts implements OfficialAccounts{ private ArrayList users; private String content; public NewsOfficialAccounts () { users = new ArrayList(); } @Override public void follow(User user) { // 关注该公众号 users.add(user); } @Override public void unfollow(User user) { // 取消关注 int i = users.indexOf(user); if(i&gt;=0) { users.remove(i); } } @Override public void sendMessageAll() { // 给所有用户发送文章 for(int i = 0; i&lt;users.size();i++) { User user = (User) users.get(i); user.acceptMessage(content); } } public void setContent(String content){// 设置消息自动给所有用户发送文章 this.content = content; sendMessageAll(); } } 创建用户类接口，用于接受公众号文章 public interface User { public void acceptMessage(String content); // 接收消息 } 创建用户实现用户接口。创建其它用户也只需要实现User接口 // 用户jason public class UserJason implements User{ private String name = &quot;jason&quot;; private String message; private OfficialAccounts os; @Override public void acceptMessage(String content) { System.out.println(name+&quot;接收到了&quot;+content); this.message = content; } public UserJason(OfficialAccounts os) { // 构造器作为关注公众号用 this.os = os; os.follow(this); } public void unfollow(){ // 取消关注 os.unfollow(this); } } // 用户tom public class UserTom implements User{ private String name = &quot;tom&quot;; private String message; private OfficialAccounts os; @Override public void acceptMessage(String content) { System.out.println(name+&quot;接收到了&quot;+content); this.message = content; } public UserTom(OfficialAccounts os) { // 构造器作为关注公众号用 this.os = os; os.follow(this); } } main方法运行 public static void main(String args[]) { // 创建一个新闻的公众号 NewsOfficialAccounts noa = new NewsOfficialAccounts(); // 创建用户 UserTom tom = new UserTom(noa); UserJason jason = new UserJason(noa); // 公众号发送消息 noa.setContent(&quot;新闻消息1&quot;); noa.setContent(&quot;新闻消息2&quot;); jason.unfollow(); // 取消关注，jason无法接收消息3 noa.setContent(&quot;新闻消息3&quot;); } 运行结果：实现类发现消息之后只要所有关注了新闻公众号的用户可以接受消息，没有关注的就没有接收到 jason接收到了新闻消息1 tom接收到了新闻消息2 jason接收到了新闻消息2 tom接收到了新闻消息3 2、用java jdk 自带的Observable、Observer实现创建公众号 public class BankOffcialAccounts extends Observable{ // 实现java自带的可观察者接口 private String content; // 接受的消息 public BankOffcialAccounts(){}; // 构造器 public void changed() { // 消息变化方法 setChanged(); notifyObservers(); // 通知所有观察者 } public void sendMessage(String content) { // 发送消息 this.content = content; changed(); } public String getContent() { return content; } public void setContent(String content) { // 写入公众号内容 this.content = content; } } 创建一个用java自带的观察者用户（同上面的UserJason、UserTom） public class UserJDK implements Observer{ // 实现java自带的观察者 Observable observable; private String name = &quot;jdk&quot;; private String content; @Override public void update(Observable o, Object arg) { if (o instanceof BankOffcialAccounts) { BankOffcialAccounts boa = (BankOffcialAccounts)o; this.content = boa.getContent(); System.out.println(name+&quot;接收到了&quot;+content); } } public UserJDK(Observable o) { this.observable = o; observable.addObserver(this); } } 和之前自己写的观察者模式一起运行 public static void main(String args[]) { // 创建一个新闻的公众号 NewsOfficialAccounts noa = new NewsOfficialAccounts(); // 创建用户 UserTom tom = new UserTom(noa); UserJason jason = new UserJason(noa); BankOffcialAccounts bank = new BankOffcialAccounts(); UserJDK jdk = new UserJDK(bank); // 发送消息 noa.setContent(&quot;新闻消息1&quot;); noa.setContent(&quot;新闻消息2&quot;); jason.unfollow(); // 取消关注，jason无法接收消息3 noa.setContent(&quot;新闻消息3&quot;); bank.sendMessage(&quot;发送消息4&quot;); } 运行结果 tom接收到了新闻消息1 jason接收到了新闻消息1 tom接收到了新闻消息2 jason接收到了新闻消息2 tom接收到了新闻消息3 jdk接收到了发送消息4 需要注意的是Observable是一个类，必须要写一个类基础他。限制类Observable的复用潜力 三、UML类图 Observable、Observer 是java jdk自带的 四、笔记1、面向对象原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为交互对象之间的松耦合而努力 2、观察模式定义在对象之间定义一对多的依赖、这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－策略模式]]></title>
    <url>%2F20181012.html</url>
    <content type="text"><![CDATA[最近在读head frist 的设计模式。之前就了解过这本书的，感觉还不错，于是就在淘宝上购买了一本。书有500多页挺厚的一本，内容都是很容易上手的，当成漫画看就可以了。本着学习的态度，我想认认真真的把设计模式好好学习一下。设计模式很多，一个一个的学，学完一个，我就在这里纪录一下自己的学习成果、自己对设计模式的理解、以及一些笔记、代码就是自己想一个显示生活中的例子模拟实现。 一、对策略模式的理解&emsp;&emsp;关于策略模式，我看完书之后回忆的起来的大概就是建立一个抽象类，抽象除类的不改变的属性，如动物的名字、年龄等这些都是每个动物都有的，不会改变的。 二、代码实现创建一个动物类1234 public abstract class animal &#123; private String name; private int age;｝ 然后多个类继承该抽象类，如小猫、小狗等。 public class Dog extends animal{} 之后就是动物有的会飞、会叫等。这些都是动物的行为。之后把动物的飞行、叫喊接口化。 public interface CallBehavior { // 叫喊行为 public void call(); } public interface FlyBehavior { // 飞行行为 public void fly(); } 会飞、会叫都可以是动物的行为。就可以将会飞、会叫的接口组合在动物类里面，当成动物的属性 public abstract class animal { private String name; private int age; FlyBehavior flyBehavior; // 让所有的动物都继承这个行为 CallBehavior callBehavior; // 添加方法，用于被继承的动物共用方法 public void performFly() { // 执行飞行 flyBehavior.fly(); } public void performCall() { // 执行叫喊 callBehavior.call(); } public void setFlyBehavior(FlyBehavior fly){ // 动态的设置飞行的实现类，可以在运行时改变动物的飞行方式 this.flyBehavior = fly; } public void setCallBehavior(CallBehavior call){ this.callBehavior = call; } ｝ 之后就用不同的实现类实现会飞、会叫的接口 // 叫喊接口实现 public class CallBig implements CallBehavior{ @Override public void call() { System.out.println(&quot;特别大声的叫&quot;); } } public class CallNoWay implements CallBehavior{ @Override public void call() { System.out.println(&quot;不会叫&quot;); } } // 飞行接口实现 public class FlyNoWay implements FlyBehavior{ @Override public void fly() { System.out.println(&quot;不会飞行&quot;); } } public class FlyWithWings implements FlyBehavior{ @Override public void fly() { System.out.println(&quot;我要飞的更高&quot;); } } 然后就可以给小狗类添加默认的构造器。 public class Dog extends animal{ public Dog() { // 小狗的构造器 callBehavior = new CallBig(); // 大声叫callBehavior 使用的是父类的变量 flyBehavior = new FlyNoWay(); } } 调用 public static void main(String args[]) { animal dw = new DogModle(); dw.performFly(); // 默认飞行 dw.performCall(); // 默认叫喊 dw.setFlyBehavior(new FlyWithWings()); //动态绑定飞行行为 dw.performFly(); // 更改之后的飞行方式 } 执行结果 不会飞行 特别大声的叫 我要飞的更高 这样就动态实现了数据的绑定，根据不同的策略，绑定不同的接口。动态的完成功能，后期添加其他动物，也不需要更改之前的代码。完全做到了，对新增开放、对修改闭合的开闭原则。 三、UML类图画的不正规的uml图 四、笔记1、学到的三个原则 将会变动的代码进行封装 针对接口编程，不针对实现编程 多用组合、少用继承 ####2、策略模式定义 定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次数据库迁移的失败经历]]></title>
    <url>%2F201809013.html</url>
    <content type="text"><![CDATA[sql数据结构 表一表二表三 目标:将表一的数据迁移到表二、表三里面，一分为二。表二里面放产品主体，表三里面放多规格 原因： 由于之前设计表的经验不足，没有考虑到产品多规格的情况，写到快完成的时候，才想到用两张表实现产品的多规格（引以为戒，以后设计表的时候，要多方面考虑）。之前用一张表的时候是用checked字段区分产品是否为多规格的，如果是单规格和多规格的主体，就存1。否则就存多规格主体的ID。最终导致现在上传了2915个产品（包括多规格）。管理很混乱，数据比较多，不可能手工重新传了的。只能做数据迁移。 实现思路有两种办法：一、通过实体类迁移数据。 1.创建originCommodity(表一),commodity（表二），commodityDetail（表三）实体类 2.通过dao获取所有的originCommodity数据（获取所有的数据）。用for循环将originCommodity里面的数据分割为两张表commodity、commodity。并通过dao的inster批量创建commodity、commodityDetail数据（需要写sql批量插入数据） 二、手动navicat软件＋少量sql 将表一里面的数据导入本地的数据库，通过navicat软件手动将不同的字段更改为表二里面的字段，不需要的字段直接删除。之后将数据直接导入到表二，完成迁移。（这是最笨的方法进行迁移。但是迁移的时候需要注意的是ID，表一的是uuid生成的ID，表二是自增ID）。 1.将表一分成两个表，commodity、commodityDetail。 commodity里面全部放checked=1的数据（主体）。commodityDetail里面存checked!=1的数据（多规格）。（创建两个表，复制表一里面的全部数据，将commodity里面的checked!=1的删除，将commodityDetail表里面的checked=1的数据删除，完成创建） 2.增加一个在commodity里面增加一个origin_id(原来的uuid),用来存放之前的ID。将commodity的ID更改为origin_id。id为自增ID 3.更改commodityDetail表里面的checked字段，需要将commodityDetail里面的checked等于commodity表里面的origin_id的数据变为commodity的自增ID。 用方法二处理数据遇到的问题： 由于想要尽快的处理这个问题，我选择了方法二，用最笨的方法处理数据。一路都很顺利的处理完成了。结束之后，我就将原来的commodity删除了。因为要将表里面的数据的ID更改为自增ID，而且开始的时候是新增了自增ID的字段的，之后将原来的uuid字段更改为了origin_id。这样方便其他表关联这张表的时候，可以通过origin_id获取更改之后的ID。但是有一张表我遗漏了，没有将表里面的ID更改，就将这个origin_id删除了。导致现在有一张表无法获取ID。因此，这种方法是一个很笨切不能从用的笨办法，如果用第一种方法，就不会出现这种问题了。还好这次更改的只是测试数据，下次重新用第一种方法试一次 数据库需要用到的命令###一、 将sql数据签出并放到本地： 123mysqldump -hlocalhost -uroot --databases 数据库名 | gzip &gt; /root/DatabaseName_$(date +%Y%m%d_%H%M%S).sql.gzscp root@ip地址:/root/sql文件名 ./Desktop // 将文件复制到本地 失败使人进步，加油。end]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现redis缓存功能]]></title>
    <url>%2F201809019.html</url>
    <content type="text"><![CDATA[一、安装redis1.mac安装，如果有安装brew 可以直接快捷安装：brew install redis 2.linux下载安装wget http://download.redis.io/releases/redis-2.8.17.tar.gz tar xzf redis-2.8.17.tar.gz cd redis-2.8.17 make 二、redis常用命令redis-cli // 进入命令行 /usr/local/bin/redis-server /usr/local/etc/redis.conf // 启动 找到你的redis-server、redis-server路径 quit // 退出 keys * // 查询所有的key set a 123 //创建字符串key（a）, value(123) get a // 查看字符串key为a的value del a //删除字符串key为a的数据 hmset key name &quot;a&quot; description &quot;123&quot; // hashmap的创建 hgetall a //hashmap通过key获取 lpush a 123 // list创建 lrange a 0 10 //list 获取 sadd a 123 // 集合set创建 smembers a // 集合set 获取 zadd a 123 // 有序集合set创建 zrange a 1 10 smembers // 集合set 获取 注：初期使用的命令，后期遇到之后在进行添加 三、spring boot集成redis1.项目基于spring boot创建的，eclipse 集成spring boot 后，可以选择redis，之后自动生成如下代码（pom.xml）:&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.配置redis，在application.propertise 的文件里面添加如下：spring.redis.database=0 spring.redis.host=localhost spring.redis.port=6379 // 端口号 spring.redis.password=redispass // 密码 spring.redis.pool.max-active=8 spring.redis.pool.max-wait=-1 spring.redis.pool.max-idle=8 spring.redis.pool.min-idle=0 spring.redis.timeout=5000 // 链接超时时间，可以设置大一些 3.创建一个service接口（redisService）：@Service public class RedisService { @Autowired private StringRedisTemplate redisTemplate; /** * 一周有多少秒 */ private static final long WEEK_SECONDS = 7 * 24 * 60 * 60; /** * 将 key，value 存放到redis数据库中，默认设置过期时间为一周 * @param key * @param value */ public void set(String key, Object value) { redisTemplate.opsForValue().set(key, JsonUtil.convertObj2String(value), WEEK_SECONDS, TimeUnit.SECONDS); } /** * 将 key，value 存放到redis数据库中，设置过期时间单位是秒 * * @param key * @param value * @param expireTime */ public void set(String key, Object value, long expireTime) { redisTemplate.opsForValue().set(key, JsonUtil.convertObj2String(value), expireTime, TimeUnit.SECONDS); } /** * 判断 key 是否在 redis 数据库中 * * @param key * @return */ public boolean exists(final String key) { return redisTemplate.hasKey(key); } /** * 获取与 key 对应的对象 * @param key * @param clazz 目标对象类型 * @param &lt;T&gt; * @return */ public &lt;T&gt; T get(String key, Class&lt;T&gt; clazz) { String s = get(key); if (s == null) { return null; } return JsonUtil.convertString2Obj(s, clazz); } /** * 获取 key 对应的字符串 * @param key * @return */ public String get(String key) { return redisTemplate.opsForValue().get(key); } /** * 删除 key 对应的 value * @param key */ public void delete(String key) { redisTemplate.delete(key); } } 4.在PifajiaOfficialApplicationTests里面进行测试@Test public void redisService(){ String str = &quot;test&quot;; String retStr = this.redisService.get(&quot;test&quot;); if(retStr == null) { this.redisService.set(&quot;test&quot;, str); retStr = str; } System.out.println(&quot;:::&quot;+retStr); } end]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用自定义注解进行切面，@Autowired装配的service一直报错空指针]]></title>
    <url>%2F201809012.html</url>
    <content type="text"><![CDATA[切面的方法是public就可以了]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Autowired</tag>
      </tags>
  </entry>
</search>
