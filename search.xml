<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[The fifth week of English learning]]></title>
    <url>%2F20181217.html</url>
    <content type="text"><![CDATA[星期一 together 一起 play 玩 lion 狮子 like 喜欢 ping-pong 兵乓 football 足球 clothes 衣服 put on 穿上 sock 袜子 swim 游泳]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>englishLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目集群，实现单个服务器操作其余服务器自动同步。]]></title>
    <url>%2F20181211.html</url>
    <content type="text"><![CDATA[原因项目是一个分布式集群的项目，一个项目运行在多个tomcat服务器上面。由于功能需要改动，如果手动管理代码，是一件很容易出现操作失误导致项目代码同步不一致的情况。 实现目标 在一个地方操作，其余服务器中的代码自动同步。 支持回滚操作，如果同步之后的代码有问题，立马回滚到之前的版本（不影响线上操作）。 实现思路方式一：同步工具 用代码同步工具rsync, 或者remote synchronize等同步工具进行同步。这种方式也是在网上看到的同步方式，我也没有测试过。 后面的方式是用代码持续集成的思路实现的。之前有单独的用过git或svn的钩子方式实现过持续集成，后面看到jenkins很不错，也就用了jenkins实现一次。最终的效果都是代码的自动化部署。 方式二：git ＋ shell（svn和git的部署方式思路一致） git是程序员常用的代码版本控制工具，比较重要的功能就是分支和版本，回退到之前的版本是一件很很容易的事情。第一种方式可以利用git的版本机制。 用一台服务器A专门管理代码，并创建git仓库。 在这台服务器A上面用maven进行代码编译生成.class文件。（非maven管理的项目，可以在本地编译成功后上传到git仓库） 在其他需要同步的服务器上面clone服务器A上面的代码。 在其他服务器上面创建同步脚本和回退脚本。 同步脚本： 拉取最新代码 关闭tomcat服务器 启动tomcat服务器 如果代码出现问题的回退脚本: 关闭tomcat服务器 代码回退 启动tomcat 用工具远程执行脚本。如果配置了ssh免密码登陆，可以用：ssh user@remoteNode “sh /home/sync.sh” 来执行远程脚本。也可以在服务器A上面写一个执行多个服务器远程命令的命令脚本。 方式三: jenkins + rsync + git/svn jenkins+svn+rsync+php_一键自动化部署可持续化集成服务器集群项目_支持回滚 这个写的比较详细，只是语言是php的，换成java的语言应该影响不大。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The first month of English learning]]></title>
    <url>%2F20181119.html</url>
    <content type="text"><![CDATA[总结句子成份 词性 名称 描述 分类 常见 简写 名词 表示人或者事物的名称 可数和不可数 toy 玩具，head 头 n 代词 代替名词、数词、形容词（人称代词） 单数、复数 I, you, it pron 形容词 用来修饰名词、表示人或事物的特征 litte 小的、big 大的 adv 副词 表示行为或状态特征的词 adv 动词 表示动作或状态 look 看，know 认识 v 数词 表示数量或者顺序的词 one、 two num 冠词 说明名词所指的范围 a、an、the art 介词 说明它与别的词之间的关系，时间介词 in， down prep 连词 逻辑关系词，表示人或事物的名称 if、but conj 感叹词 语气词，代替名词，数词，形容词等 oh、hi int 第四周 Fourthly week of English learning星期一单词 toy 玩具 n under 在…之下 prep in 在…里 prep on 在…上 prep nurse 护士 n hat 帽子 n pupil 护士 n policeman 警察 n doctor 医生 n driver 医生 n 星期二单词 nose 鼻子 touch 触摸 head 头 tree 树 fish 鱼 know 知道 bear 熊 at 在 look 看 bed 床 星期三单词 cow 奶牛 baby 宝贝 feet 脚 hand 手 leg 腿 body 身体 eye 眼睛 mouth 嘴巴 ear 耳朵 face 脸 星期四 snake 蛇 little 少的 big 大的 fat 肥胖的 thin 瘦的 egg 蛋 chicken 鸡肉 duck 鸭 farm 农场 pig 猪 星期五 cute 宝贝 tiger 老虎 tall 高大的 giraffe 长颈鹿 long 长的 zoo 动物园 go 走 elephant 大象 small 小的 short 短的 星期天主语 位置：句子开头 充当者：名词、代词、数词、短语。 描述：需要描述的事物或者对象。 例子：I^主语 will drink water. // 我要喝水的“我”就是主语 谓语 位置：主语之后 描述：描述表示主语的动作或状态。 充当者：be动词（am,is,are）、行为动词（跑、动等实际动作意义的词） 例子：I will^谓语 drink water. // 我要喝水的“要”就是谓语 表语 位置：放在be动词（与感觉有关的东西。look、smell等）和系动词（包括be动词，表示状态变化的动词）的后面。 描述：表明主语的身份或者特征。 充当者：名词、代词、数词、介词短语、副词 例子： 宾语 位置：动词后面、谓语后面。 描述：动作承受的对象就是宾语 充当者：名词、代词、数词构成。 例子：我敲打了电视。“电视”就是宾语。 宾语补足语（宾补） 位置：宾语的后面。 描述：就是对宾语的描述（有时如果没有宾语补足语，句子就不完整）。 充当者： 例子： 定语 位置：名词前。 描述：修饰名词或代词（即在汉语里的……的），一般起描述作用。 例子：优秀的人。“优秀的”就是定语 状语 位置：不定（开头，中间，末尾都可以） 描述：修饰动词，形容词或副词，有的修饰全句，用于说明地点，时间，方式，程度，原因，目的，结果，条件，让步等。 例子： 第三周 Thirdly week of English learning星期一笔记 看 123456789look // 不看内容， look at（小心）／ look out （小心）／ look after（照顾）， 不看内容whatch // 有思想的看，watch＋内容（watch TV）,有动作的。read // read book(看书)／ newspaper／mind **mind reader**see // 看到实质，会面。见到一个朋友。看到一只狗。see sb doing。see tv（想看电视）meet // 接近see meet-see-visit(参观)。 visit＋place 听 123456listen //不听内容。listen-lookhear //听见有实质的内容。 hear-watch/read。hear from sb/n-receive // 收到来信，收取sound // 声音 sounds good(听起来很棒) 拿 123456789101112take // take up (占据)，take away(带走), take off(脱掉，起飞),拿起来pick // pick up(接送某人)，pick out(挑出来)get // get up （起床）， get out(滚)，get on ， get down，get away from(离某人或某物远) ，get ingrab // grab sth（抢夺）／sbcarry //挑、抗。carry on （坚持前行），carry out(执行)hold // hold a meeting(举办)， be held in（在哪里举办什么内容） 被动语态 Be held in 1234567891011121314Be + Ved2 The woman killed a dog last night.The dog is killed by the woman last night.The school published some English books last summer.Some English books were published by the school.Be - vingshe is reading a book.Be - vedThe book is read by her. 单词 four 四 three 三 two 二 one 一 box 盒子 house 房子 monster 怪物 monkey 猴子 kite 风筝 crayon 蜡笔 星期三单词 ball 球 pink 粉色 ten 10 nine 9 eight 8 seven 7 six 6 five 5 say 说 count 计算 星期四 has 他的 friend 朋友 grandpa 爷爷 mother 妈妈 father 爸爸 but 但是 birthday 生日 happy 快乐 brown 棕色 many 许多 星期天词性分类名词(noun,n) 描述：表示人或者事物的名称 分类： 可数名词(countable noun,c)（有单数变复数的变化[plural,pl]，apple – apples） 不可数名词(uncountable noun,u)， 没有变化形式。 常见 toy 玩具 pupil 小学生 driver 驾驶员 doctor 医生 head 头 tree 树 bear 熊 baby 宝贝 feet 脚 body 身体 eye 眼睛 face 脸 hat 名词 policeman 警察 nurse 护士 nose 鼻子 fish 树 bed 床 cow 奶牛 mouth 嘴 ear 耳朵 代词 (pronoun,pron) 描述：代替名词、数词、形容词(人称代词) 常见 第一人称、我 第二人称、你 第三人称、他她它 单数 I you It 复数 we You They 形容词(adjective,adj) 描述：用来修饰名词、表示人或事物的特征 位置：放在名词前面修饰名词 常见：little 小的，fat 肥胖的，thin 瘦的，big 大的 副词(adverb,adv) 描述：表示行为或状态特征的词 位置：修饰动词或者形容词 动词(verb,v) 描述：表示动作或者状态 位置：动作或者状态的词 touch 触摸 look 看 know 认识 数词(numeral,num) 描述：表示数量或顺序的词语 冠词(article,art) 描述：帮忙说明名词名词所指的范围 位置：用在名词前 共三个 an a 不定冠词 一、一个 the 定冠词 这、这个 中文样式：我今天买了一支^不定冠词 笔，这^定冠词 支笔很好看 介词(preposition, prep) 位置：用在名词或者代词前。 描述：说明它与别的词之间的关系，时间介词，方位介词 常见： in 在…离,on 在 … 上,down,up,under 在 … 之下，at 在 连词(conjunction,conj) 描述：逻辑关系词,表示人或事物的名称。 常见：if,because,but 感叹词(interjection,int) 描述：语气词，代替代替名词，数词，形容词等。 常见：oh,hello,hi,yeah 第二周 Second week of English learning星期三单词 up 向上 panda 熊猫 stand 站立 down 向下 sit 坐 girl 女孩 boy 男孩 bird 鸟 please 请 name 名字 星期四单词 red 红色 door 门 window 窗口 colour 颜色 open 打开 point 点 yellow 黄色 desk 桌子 chair 椅子 blue 蓝色 星期五单词 school 学校 teacher 老师 orange 橘子 look 看 cat 猫 dog 狗 white 白色 black黑色 how 怎么 green 绿色 星期六 pencilcase 文具盒 eraser 橡皮擦 ruler 尺子 pencil 铅笔 pen 钢笔 book 书 schoolbag 学校 bag 包 child 孩子 classroom 教师 音标 音标分为元音、辅音。 辅音就是通过辅助的发音，就可以是音标。如：B [bi:]，读的时候就是b和i连在一起读就是B了，单独的b就是B的音标读法。 J: zh /dʒ/ ｝ 红色标记的辅音是比较特殊的辅音，读法不一样。 C: ce, cy, ci ｛ /k/ ｝ G: ge, gy, gi ｛ /g/ ｝ H: sh, ch, gh ｛ /h/ ｝ 元音就是字母除了辅音之外还有另一个读法的音标。 A , E , I , O , U 星期天 音标技巧提示 θ si ts ci ʃ sh tr chuo tʃ 吃 ð ri dz 资 ʒ 日 dr zhuo dʒ 知 第一周（2018-11-19）First week of English learning星期一单词 run out of 用完 since 从…以来 collect 收集 shell 外壳 several 几个 marathon 马拉松 skate 溜冰 pair 一对 raise 举起 russian 俄罗斯 several 若干 stamp 邮票 kite 风筝 monster 怪物 emperor 皇帝 笔记123456789101112It&apos;s pink // 它是粉红色It&apos;s red // 它是红色It&apos;s white // 它是白色It&apos;s yellow // 它是黄色It&apos;s gray // 它是灰色It&apos;s orange // 它是橘黄色It&apos;s brown // 它是棕色It&apos;s blue // 它是蓝色It&apos;s black // 它是黑色It&apos;s green // 它是绿色It&apos;s purple // 它是紫色 复习 chair椅子 eraser 橡皮擦 book 书 pen 钢笔 ruler 尺子 bag书包 desk 桌子 pencil 铅笔 星期二 particularly 特别地 capital 首都 writer 作家 extra 额外的 thousand 一千 topic 主题 jewith 犹太人 coin 硬币 european 欧洲人 globe 球体 common 通用 foreigner 外国人 by the way 顺便说一下 cake 蛋糕 anyone 任何人 难记的单词：particularly 特别地。 笔记123456They&apos;re notebook // 它们是笔记本 They&apos;re calculators // 它们是计算器They&apos;re markers // 它们是记号笔单数用It is 简写为： It&apos;s复数用They are 简写为: They&apos;re 星期三单词 clothing 衣服 bring 带来 waitress 作家 poster 海报 the Olympic Games 奥林匹克 task 任务 dish 盘子 right away 立即 yard 院 quite 相当 turn down 拒绝 not at all 一点也不 mind 头脑 miss 想念 certain 肯定的 笔记1234567who&apos;s he? // 他是谁？who&apos;s she? // 她是谁？It&apos;s he old? // 它是老的Yes, he is. // 是的，他是It&apos;s yang. // 她是年轻的 No, she is not. // 不她不是It&apos;s he short // 他是小的 星期四单词 cut 剪 line 行 door 门 perhaps 也许 polite 客气的 annoyed 愤怒的 wait the line 排队等候 annoy 烦恼的 solution 解答 笔记1234Is it a book? // 它是书？Is it a ball? Is it little? // 他是小的？Is it a doll? // 它是一个娃娃？ 星期五单词 europe 欧洲人 asian 亚洲人 behavior 行为 normal 正确的 etiquette 礼仪 term 学期 voice 语音 keep 保持 cut 剪 public 公众 笔记1234567891011Where is the bag? // 包在那里Where are the books? // 书都在那里are the cars by the bag? // 我的汽车都在包里吗？no，they are not？ // 不，它们不在Is the yo-yo on the table? // yo-yo 在桌子下面?Is the doll in the tree? // 玩偶在树下？Is the bag on the table? // 包在桌子上？Are the crayons in the bag? // 蜡笔都在包里？Are the bats by the tree? // 球拍都在树下单数is，复数are 星期六单词 criticize 批评 cigarette 香烟 put out 熄灭 smoke 烟 sneene 喷嚏 sough 咳嗽 allow 允许 impolite 不礼貌的 uncomfortable 不舒服的 in 在…里 笔记123I want fish an milk. // 我要鱼和牛奶Do you want bread? // 你想要面包 星期天 看到字母‘n’，‘m’ 发鼻音。 看到’r’ 发卷舌。看到‘v’咬嘴唇，‘w‘不咬嘴唇 发音。 自然拼读（字母、字母组合）＋音标 字母 音标 典型单词 备注 字母 音标 典型单词 备注 A a /æ/ /ei/ apple 元音 N n /n/ nice 发鼻音 B b /b/ * book O o /o/ /au/ open 元音 C c /k/ * cat P p /p/ * pencil D d /d/ dog Q q /k/ * quit E e /e/ /i/ egg 元音 R r /r/ ruler 卷舌 F f /f/ fish S s /s/ six G g /g/ good T t /t/ * time H h /h/ * head U u / ^ / /ju:/ under 元音 I i /əu/ /ɔ/ in 元音 V v /v/ van 咬嘴唇 J j /dƷ/ jeep W w /w/ want 不咬嘴唇 K k /k/ * kill X x /x/ x L l /l/ like 不发鼻音 Y y /y/ yes M m /m/ money 发鼻音 Z z /z/ zero A a ／æ／ apple ant 元音字母之一。／æ／ ／ei／ B b ／b／ book bag C c ／k／ cat cake can D d ／d／ Dad dead Dog door E e ／e／ bed egg end 五个元音字母之一／e／ ／i／ F f ／f／ fish G g ／g／ good girl game goat green go H h ／h／ hat head hand house I i ／i／ in it ink internet 五个元音字母之一 ／i／ ／e／ J j ／dj／ jam jeep jenny K k ／k／ kill kitten kind take kick kiss kill L l ／l／ like lie land look large little M m ／m／ mother mind morning money monkey mouse N n ／n／ notebook nine notice nice night O o ／o／ octopus on open orange office 备注：五个元音之一。／o／ ／au／ P p ／p／ pay paint picture paper pencil Q q ／k／ quick quit quite Question R r ／r／ [卷舌] Ruler rainy rice right rude S s ／s／ sun six some summer sunday T t ／t／ Table Tall teacher time ten U u |^| [嘴巴两边张] under hug uncle ugly 五个元音字母之一。／^／ ／ju:／ V v ／v／ ［咬嘴唇］ van violin five virus W w ／w／ ［不咬嘴唇］ window walk windy want win X x ／eks／ x Y y ／y／ yellow young yes you Yo-yo Z z ／z／ zero zoo zone zipper A E I O U 元音字母 one two three four five six seven eight nine ten eleven twenty thirteen fourteen fifteen sixteen eventeen eighteen nineteen twenty 总结： 这一周每天背了10个单词，记的单词基本忘记了，一点效果都没有，今天是第一周的最后一天。Amanda老师调整了我背单词的难度，下周从小学的星期三开始。这两天练习上面学习的自然拼读。从零开始，加油！]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>englishLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用js写了一个比较方便的表单验证器]]></title>
    <url>%2F20181114.html</url>
    <content type="text"><![CDATA[一、实现方式 导入jquery 将以下代码复制到html页面中 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt;$(function() &#123; // 调用此方法获取表单是否合法 function checkInputPostData() &#123; var list = $(&quot;.validInputs&quot;) var j = 0 for(var i = 0; i&lt;list.length; i++) &#123; j = j+inputDataValid(list[i]) &#125; if (j == 4) &#123; return false &#125; return true &#125; // 自定义表单效验 gqs function inputDataValid(then) &#123; var th, promt, value, reg th = $(then) promt = th.parent().find(&quot;.Validform_info&quot;)[0] value = th.val() if(value == null || value == &quot;&quot;) &#123; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;+th.attr(&apos;nullmsg&apos;)+&apos;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_right&apos;).addClass(&apos;Validform_wrong&apos;) return false &#125; reg = th.attr(&quot;datatype&quot;) if(!eval(reg).test(value))&#123; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;+th.attr(&apos;errormsg&apos;)+&apos;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_right&apos;).addClass(&apos;Validform_wrong&apos;) return false &#125; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_wrong&apos;).addClass(&apos;Validform_right&apos;) return true &#125;&#125;&lt;/script&gt; input框写入自定义属性 123456789&lt;input id=&quot;name&quot; onblur=&quot;inputDataValid(this)&quot; name=&quot;name&quot; type=&quot;text&quot; class=&quot;span3 validInputs&quot; &lt;!-- 必须要validInputs的class,或者和checkInputPostData函数中的validInputs一致 --&gt; datatype=&quot;/^[a-zA-Z\u4E00-\u9FA5]&#123;1,20&#125;$/&quot; &lt;!-- 正则：用于效验表单 --&gt; value=&quot;123&quot; nullmsg=&quot;此项不能为空&quot; &lt;!-- 表单为空时的提示 --&gt; errormsg=&quot;请填写字母或汉字&quot;/&gt; &lt;!-- 正则效验失败时的提示 --&gt; 在input下创建 1&lt;div class=&quot;Validform_info&quot;&gt;&lt;/div&gt; 注：需要和下面的代码层级一致，如果不一致要注意层级查找（ th.parent().find(“.Validform_info”) ）的更换 二、全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;简单的表单验证器&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/core.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .Validform_right&#123; 正确提示的css &#125; .Validform_wrong&#123; 错误提示的css &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table class=&quot;gritter-with-table&quot; cellspacing=&quot;1&quot;&gt; &lt;tbody id=&quot;tbody&quot;&gt; &lt;tr name=&quot;posts&quot;&gt; &lt;th&gt;姓名：&lt;/th&gt; &lt;td&gt; &lt;input id=&quot;name&quot; onblur=&quot;inputDataValid(this)&quot; name=&quot;name&quot; type=&quot;text&quot; class=&quot;span3 validInputs&quot; datatype=&quot;/^[a-zA-Z\u4E00-\u9FA5]&#123;1,20&#125;$/&quot; value=&quot;123&quot; nullmsg=&quot;此项不能为空&quot; errormsg=&quot;请填写字母或汉字&quot;/&gt; &lt;div class=&quot;Validform_info&quot;&gt;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr name=&quot;posts&quot;&gt; &lt;th&gt;电话：&lt;/th&gt; &lt;td&gt; &lt;input onblur=&quot;inputDataValid(this)&quot; nullmsg=&quot;此项不能为空&quot; value=&quot;1234&quot; datatype=&quot;/^[a-zA-Z\u4E00-\u9FA5]&#123;1,40&#125;$/&quot; placeholder=&quot;例：*********&quot; class=&quot;span3 validInputs&quot; id=&quot;phone&quot; type=&quot;text&quot; name=&quot;phone&quot; &gt; &lt;div class=&quot;Validform_info&quot;&gt;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;script&gt;$(function() &#123; // 调用此方法获取表单是否合法 function checkInputPostData() &#123; var list = $(&quot;.validInputs&quot;) var j = 0 for(var i = 0; i&lt;list.length; i++) &#123; j = j+inputDataValid(list[i]) &#125; if (j == 4) &#123; return false &#125; return true &#125; // 自定义表单效验 gqs function inputDataValid(then) &#123; var th, promt, value, reg th = $(then) promt = th.parent().find(&quot;.Validform_info&quot;)[0] value = th.val() if(value == null || value == &quot;&quot;) &#123; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;+th.attr(&apos;nullmsg&apos;)+&apos;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_right&apos;).addClass(&apos;Validform_wrong&apos;) return false &#125; reg = th.attr(&quot;datatype&quot;) if(!eval(reg).test(value))&#123; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&apos;+th.attr(&apos;errormsg&apos;)+&apos;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_right&apos;).addClass(&apos;Validform_wrong&apos;) return false &#125; $(promt).html(&apos;&lt;span style=&quot;color:red&quot;&gt;&lt;/span&gt;&apos;) $(promt).removeClass(&apos;Validform_wrong&apos;).addClass(&apos;Validform_right&apos;) return true &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript jquery form</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看《码农翻身》的一些收获]]></title>
    <url>%2F20181111.html</url>
    <content type="text"><![CDATA[今天是双十一，哪里也没去，早晨10点多就出门了，在新华书店里面呆了一天，在书架中找到了这本书，很容易的就看了进去，这本书用故事的方式描述生涩的代码以及程序。前段时间看的head frist也是比较很容易理解的书籍，自己购买的java并发编程实战看了几页总是无法集中精力看下去，内容很充实，可能一直在家里躺在床上太安逸的看书，导致看着看着就放弃了，希望坚持下去。 这本书学会了一个很重要的做事方式&lt;凡事必先骑上虎背&gt;，在自己做一件事情犹豫不决的时候，想想这句话,在做事情的时候，需要先骑在老虎的背上。和明知山有虎，偏上虎山行差不多。在这种状态下，经常会出现骑虎难下的尴尬情况。只要不恐惧这种情况，那么在这种状态下学习就收获更多的东西。 一、大概的内容书籍用第一人称描述计算机的各个组成如：内存、进程等，和日本的《工作细胞》动漫差不多。从底层描述描述进程、线程、cpu、内存、硬盘等。整本书籍阅读起来相当的有趣，看的时候完全当成一本小说在读，但是读到最后，确实学到很多知识，虽然很多东西都是之前学习过的，但是很多也是自己理解不够透彻的。还是推荐大家可以阅读以下，一方面可以巩固自己的知识，一方面也可以学习一些自己没接触过的东西。 计算机的世界 进程：比如QQ运行，QQ音乐运行，微信运行，都需要一个进程去处理，一个计算机可以有多个进程。进程之间的切换实现了多个程序同时运行的效果。（理解不够透彻，需要完善） 线程：一个进程可以拥有多个线程 cpu：由寄存器和运算器组成，寄存器用来存储数据，运算器负责运算，速度特别快 内存：内存负责把硬盘的数据加载到内存里面，并且各种指令，执行速度一半 硬盘：负责把数据持久化，存储数据，防止断电，执行速度特别慢 汇编语言：比较难理解的语言，负责和底层的二进制（机器语言）打交道 高级语言： 如c、c++、java、python等。用人类方便理解的语言和汇编语言打交道 tcp/ip：只要解决的就是网络传输数据的问题，通过没次发送少量数据拆包，并进行失败重发的功能解决发送大量数据的问题。发送的过程中由多个路由器进行转发到目的地完成。 java帝国 java class : java类主要由java的类加载调用，每个线程都会有一个函数栈（栈祯），用来进行方法调用 JDBC ： 由一个工厂方法实现，封装了各种实现，用于和各种数据库对接，便于数据的持久化，代替的文件存储方法，提高效率。 jsp : java的模版套用mvc的view。用于将html和数据组合生成html页面。freemarker也是类似的，但是freemarker静态的页面也是可以浏览的。 JTA : 在多个数据库之间传送数据，保证数据的事务性。由一个全局事务管理器实现，统一准备和统一提交。失败案例（全局事务管理器出现问题，将无法保存数据的一致性） 消息队列（JMS - java message service）：为了实现分布式项目的数据传递问题。如订单服务器给物流服务器发送订单，物流服务器出现问题，暂时无法接受订单。就可以由一个消息队列处理，有订单了，由订单服务器发送订单到消息队列排队，物流服务器可以随时接收订单，就是物流服务器有事情，也不会影响到订单服务器。 动态代理：可以实现给一个类动态的添加新的行为。动态代理可以实现aop的切面功能。 java注解：注解相当于加强的注释。注解有元注解^(注解的注解)，通过注解可以减少xml文件的编写，只好的方式就是xml和注解配合一起使用。 泛形：泛形就是可以限制一组数据的数据类型。&lt;? extends Object&gt; 的意思就是可以传入继承了对象类的任意对象。 序列化：把java对象编程二进制字节流存储在硬盘上，当然还有一种办法就是把二进制字节流反序列化为java对象。 java程序的锁：在java中synchronized就是同步锁，每个线程需要访问锁里面的内容必须要拿到锁，没有拿到的就需要在线程池里面等待。这个是一个重量级的悲观锁（觉得线程随时都会更改数据）。另一种办法就是乐观锁（认为大部分情况多线程的情况都比较少），可以给数据添加一个版本号，每次更改数据后版本变化。在实现功能的时候，可以把数据获取出来更改之后，在修改的时候对比版本号是否一致，如果不一致则继续重新获取，直到版本号一致为止。这样就减少了同步锁导致的线程在线程里面等待所消耗的资源。 spring DI和IOC、AOP: 在一个大型的项目中日志、事务、登录等功能都会涉及到程序的各个层面，如果统一管理，就回出现大量冗余的代码，而去大量的代码会导致代码的臃肿。想这些经常会出现的代码，可以用模版方法和装饰者模式区封装常用的代码，但是这样很多类都需要实现接口。为了避免这种情况，于是出现了控制反转ioc，和依赖注入di（把类的依赖情况转交给spring容器）。aop利用的java动态代理实现的面向切面编程。 web冲浪 hyperText Transfer Protocol (HTTP) : 超文本传输协议,这里的超文本就是HyperText Markup Language (HTML，一种文本的标记形语言) HTTPS : 在使用HTTP在网上传输HTML的时候是使用的明文，如果中途被截取了，隐私就会被泄露。HTTPS解决了安全性问题，用对称数据加密和非对称数据加密结合解决了网络传输HTML的安全性问题。对称加密利用一个公匙和私匙，公匙加密（所有人都可以知道公私），私匙解密（对应的公私加密的文件只有对应的私匙解密）。解密的私匙是需要双方都持有的，因为双方都需要加密解密，所以在保证安全的情况下把私匙传给对方就需要非对称加密了。非对称加密需要第三方的证书＋签名，才可以完成（非对称加密还需要理解一下）。 SSO : 一个由很多子系统组合在一起的大型项目就需要实现在一个小的项目中登录之后，进入相关的项目就不用再次登录的单点登录功能。实现原理就是利用一个认证中心实现登录，用户首次登录时会获取到认证中心的一个cookie用于存放在浏览器端，浏览器上面存两个cookie，一个是认证中心的cookie一个是当前访问应用的cookie。用户访问另一个应用时，只需要将之前的cookie携带访问应用，后端通过应用验证cookie是否有效即可判断用户是否已经登录。 授权 ： 比如QQ、微信、微博第三方登录等，都是使用的授权登录方法。应用可以通过自己申请的第三方的appid和密匙，获取授权的code，授权code会有超时时间等，通过code可以获得token，最后通过token就可以实现登录逻辑。 负载均衡 ： 多台服务器运行相同的应用，nginx在进行接口转发时均衡的转化，不出现有的服务器严重负载，有的服务器轻松自在。 高可用 ： 当服务器出现故障之后，有备用的服务器顶上去，不会出现无法访问的情况。 tomcat集群：通过多台tomcat服务器实现高可用，由nginx来进行服务转发（实现负载均衡）。 redis集群：通过jedis负责分发tomcat的请求（redis cluster）。 数据库读写分离：由多台数据库实现，一个master数据库可读可写已写为准，多个slave数据库进行只读操作（读时需将数据同步至slave数据库，master出现故障由slave数据库顶替） 代码管理 VCS(Version Controller System): 版本控制系统，svn采取的就是这种方式管理的代码！采用更新，提交的方式进行。 分支，多版本并行: 通过分支实现多版本并行，在代码开发的时候可以有多个版本并行开发，每个人在本地都有一个私有库，每个人都可以有选择性的提交不同版本的代码，最后只需进行合并即可。git就是采用的这种方式。 build: 代码的自动化构建。manven的pom.xml就是可以用build脚本进行自动化构建的一个工具（自动打包、编译、部署）。 其他 声明式编程： SQL语句就是命令式编程（只提供声明，具体实现有系统负责） 命令式编程： 大多数程序员使用的语言都是命令式编程（通过指令告诉计算机怎么做）。 end]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>java code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《java 并发编程实战》笔记]]></title>
    <url>%2F20181109.html</url>
    <content type="text"><![CDATA[最近干了些什么从上个月离职到现在，已经10多天了。这段时间里面，自己都没怎么看书。感觉换了个环境，就变懒散一些了，看书也没能集中精力。最近在研究新的项目，有很多都是之前没有接触过的，这几天下来，收获还是特别多的。希望在以后的工作中学习到更多的东西，多看书，多学习。]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－总结]]></title>
    <url>%2F20181009.html</url>
    <content type="text"><![CDATA[已经将head first一书看完了，应该总结一下这本书学到了些什么，下面就将自己学习的设计模式整理一下，方便自己后期复习，以及简短的描述各个设计模式的定义，以及在哪些方面需要使用到设计模式。 什么是设计模式设计模式就是很多面向对象的开发者，根据自己开发的经验，想出来的一些模式，经过时间的认证和大多数程序员的认同后形成的一种比较好的开发模式。利用这些模式，程序员之间可以有自己的方言，程序之间沟通也更加便捷。也很利于代码的维护和扩展。是一套反复使用、多人知晓、分类遍目的代码设计经验的总结。 模式词汇(23个) 创建型 5个 singleton 单例 builder 生成器（建造者） prototype 原型 abstract factory 抽象工厂 factory method 工厂方法 行为型 11个 template method 模版方法 command 命令 observer 观察者 state 状态 mediator 中介 iterator 迭代器 strategy 策略 interpreter 解释器 chain of responsibility 责任链 memento 备忘录 visitor 访问者 结构型 7个 proxy 代理 decorator 装饰 composite 复合 facade 外观 adapter 适配器 flyweight 享元 bridge 桥接 模式何时用创建型模式 模式名称 何时用 备注 单例 singleton 创建的类只需要一个实例的时候 确保一个类只有一个实例 建造者 builder 需要创建一个复杂对象的时候 由多个简单对象构建为一个复杂对象 原型 prototpye 需要创建许多重复且互不干扰的对象时 通过复制对象实现 抽象工厂 abstract factory 创建一系列产品族时 提供一个创建一系列相互依赖对象的接口 工厂方法 factory method 当一个类的实例需要延迟到子类时 通过简单工厂模式的抽象和推广 行为型模式 模式名称 何时用 备注 模版方法 template method 定义操作算法，可以将一些步骤延迟到子类 可以用钩子实现不改变算法结构的时候改变步骤 命令 command 多个回退操作，宏纪录 通过把请求或操作封装到类中，支持撤销、恢复操作 观察者 observer 在对象之间定义一对多的关系时 依赖它的对象都会收到通知并自动更新，就像微信订阅号 迭代器 iterator 遍历不同类型集合的一种方式 通过访问迭代器接口实现‘下一个’、和’有下一个方法‘ 策略 strategy 客服端可以根据自己的需求进行相应的选择 把一系列的算法分别封装到对应的类中，实现相同接口之后可以相互替换 解释器模式 interpreter 当需要使用一个简单的语言时 将每一个语法规则表示为一个类 访问者 visitor 在封装不是很重要，需要给类添加新的能力时 封装某些结构元素的操作，在不改变数据结构的情况下新增新的操作 中介者 mediator 利用中介者改善类与类之间的过多耦合 利用星型结构改善 备忘录 在需要纪录操作备忘时，捕获类的内部状态 将被记录的状态记录在外部，帮助维护类聚 责任链 chain of responsibility 一个请求需要多个对象处理，形成链条 让对个对象都可以接受请求，就像请假一样 状态 state 在内部状态改变时，进行不同的行为操作 一个状态一个类，改变状态时，对象看这向修改了类 结构型模式 模式名称 何时用 备注 代理 proxy 需要隐藏真实身份时 通过类似黄牛的代理角色去处理 装饰者 decorator 动态的给类添加职责，有别于继承的另外一种选择 通过动态运行时选择不同的具体装饰类，从而实现不同的行为。常见的就是io流 复合 composite 大杂烩，多种模式混合使用 常见的有经典的mvc模式，mvvm模式等 外观模式 facade 接口特别多，比较混乱，需要统一调用时 将各个接口统一在一个类中，调用时只需要调用一次 适配器 adapter 将一个对象转化为另一个对象 就想转换插头，适配不同的插座一样 享元模式 flyweight 共享之前的元对象，减少实例化次数 在相同的对象特别多的时候，通过map存储对象。每次需要新对象时，就去map里面查找，没有则创建 桥接模式 bridge 当出现了两个以上的类别需要组合时 就像多种颜色和多种形状组合一样，两种类别都需要扩展 模式定义与用途创建型模式单例模式 定义：确保一个类只有一个实例，并提供全局访问点 用途：当只需要一个实例的时候 建造者模式 定义：将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 用途：经常被用来创建组合结构 原型模式 定义：通过‘复制’一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们称之为的‘原型’，这个原型是可定制的。 用途：在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象的时候，可以考虑使用原型。 抽象工厂模式 定义：提供一个创建一系列相关或相互依赖对象的接口。 用途：系统中有多个的产品族，而每次只使用一个产品族。用来创建一系列相关或相互依赖对象的接口 工厂方法模式 定义：由子类决定要创建的具体类是那一个 用途：由工厂生产产品，如果用简单工厂模式生产新的产品，就要更改工厂类，违背了开闭原则。工厂方法模式就是将类更工厂化，让扩展更简单。 行为型模式模版方法 定义：在一个方法中定义一个算法的骨架,而将一些步骤延伸到之类中，模版方法使得之类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 用途：一个可共用的模版，在共用的方法中子类可以利用钩子重新定义算法步骤。 命令模式 定义：将请求封装成对象，这可以让你使用不同的请求、队列或者日志请求来参数化其他对象。命令模式也支持撤销操作 用途：将单个的请求封装为对象。 观察者模式 定义：让对象在状态改变时被通知 用途：观察者模式就是相当于公众号一样，你关注公众号就会受到消息，取消就收不到消息，一对多的关系。 迭代器 定义：提供一种方法，顺序访问一个聚合对象中的各个元素，而又不暴露内部的实现。 用途：用来遍历集合中有不同对象的一种统一方式。 策略模式 定义：封装可以交互的行为，并使用委托来决定要使用那一个 用途：策略模式就是通过不同的策略可以给对象组装不同的行为，比如给小猫小狗添加不同的行为等。 解释器模式 定义：提供了评估语言的语法或表达式的方式，这种模式实现了一个表达式接口，该接口解释一个特定的上下文。 用途: 当需要实现一个简单的语言时，可以使用解释器。 访问者模式 定义：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的情况下定义作用于这些元素的新的操作。 用途：当你想要为一个对象的组合增加新的能力，且封装并不重要时，可以使用访问者模式。 中介者模式 定义：用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而时耦合松散，而且可以独立地改变它们之间的交互。 用途：使用中介者模式来集中相关对象之间复杂的沟通和控制方式。常常用来协调相关的GUI组件。 备忘录模式 定义：在不破坏封装的情况下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。 用途：当你需要让对象返回之前的状态，如你的用户请求‘撤销’，就可以使用备忘录模式。常常用来存储状态。 责任链模式 定义：使多个对象都有机会处理请求，从而避免了请求的发送者与接收者之间的耦合关系。将这些对象连成一条链，并沿着一条链传递这请求，直到有对象处理它为止。 用途：当你想让一个以上的对象能有机会处理某个请求的时候，就可以使用责任链模式。 状态模式 定义：允许一个对象在其内部状态发生改变时改变它的行为，对象看起来似乎修改了它的类。又叫状态对象。 用途：在工作流和游戏等类型的软件中经常使用，经常处理一批状态。比如请假流程（主管批准、经理批准、总经理批准） 结构型模式代理模式 定义：为另一个对象提供一个替身或占位符以访问这个对象。 用途：代理常常用来保护目标对象的作用，协调调用者和被调用者，降低了系统的耦合度。 装饰者模式 定义：包装一个对象，并提供新的行为 用途：就像装修房子一样，选择不同的厂商，不同的材料装饰房子。java io流就是使用的装饰模式 复合模式 定义：结合两个或两个以上的模式，组成一个解决方案，解决一再发生的一般性问题。 用途：通过多个模式去解决复杂的问题，实现不同的功能。常见的就是mvc模式 外观模式 定义：提供了一个统一的接口。用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。 用途: 封装一个统一的接口，就像很多插头插在一个大擦板上面，每次使用的时候，只需要按大插板的开关。 适配器模式 定义：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 用途: 就像转换插头一样，转换接口。 享元模式 定义：运用共享技术有效地支持大量细粒度对象的复用，系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次反复使用，由于享元模式对象需要是细粒度对象，所以又叫轻量模式、蝇量模式。 用途：如果想让某个实例能提供很多的虚拟实例，就可以使用享元模式，也叫蝇量模式。 桥接模式 定义：将抽象部分与它的实现部分分离，使它们可以独立的变化 用途：不只改变你的实现，也改变你的抽象，适合使用在跨越多个平台的图形和窗口系统上。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－访问者模式]]></title>
    <url>%2F20181027.html</url>
    <content type="text"><![CDATA[一、理解访问者模式访问者模式定义:封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 个人理解访问者模式就是让不同的访问者可以访问不同的操作。访问者模式在实现过程中可以在不改变数据结构的情况下，添加新的操作，实现开闭原则。 二、代码实现创建电脑访问者 12345678910111213141516171819// 电脑组件访问者public interface ComputerPartVisitor &#123; public void visit(Keyboard k); // 访问键盘 public void visit(Mouse mouse); // 访问鼠标&#125;class ComputerPartDisplayVisitor implements ComputerPartVisitor&#123; @Override public void visit(Keyboard k) &#123; System.out.println(&quot;键盘&quot;); &#125; @Override public void visit(Mouse mouse) &#123; System.out.println(&quot;鼠标&quot;); &#125; &#125; 创建电脑 123456789101112131415161718192021222324252627282930313233// 电脑组件public interface ComputerPart &#123; public void accept(ComputerPartVisitor cpv); // 接受方法&#125;// 键盘class Keyboard implements ComputerPart&#123; @Override public void accept(ComputerPartVisitor cpv) &#123; cpv.visit(this); &#125;&#125;// 鼠标class Mouse implements ComputerPart&#123; @Override public void accept(ComputerPartVisitor cpv) &#123; cpv.visit(this); &#125;&#125;// 电脑class Computer implements ComputerPart&#123; ComputerPart[] parts; public Computer() &#123; // 构造器给parts赋值 parts = new ComputerPart[]&#123;new Mouse(), new Keyboard()&#125;; &#125; @Override public void accept(ComputerPartVisitor cpv) &#123; for(ComputerPart cp : parts) &#123; cp.accept(cpv); &#125; &#125;&#125; main 方法实现 1234public static void main(String[] args) &#123; ComputerPart cp = new Computer(); cp.accept(new ComputerPartDisplayVisitor()); &#125; 运行结果 12鼠标键盘 三、UML类图 四、笔记当你想要为一个对象的组合添加新的能力的时候，而且感觉封装不是很重要的时候，就可以使用访问者模式。 访问者模式的优点： 允许你对组合结构加入新的操作，而无需改变结构本身。 想要加入新的操作，相对容易 访问者所进行的操作，其代码是集中在一起的。 访问者的用途和缺点 在使用访问者模式的时候，会打破组合类的封装。 因为经常性的新增操作，所以对组合结构的改变就更加困难]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－原型模式]]></title>
    <url>%2F20181026.html</url>
    <content type="text"><![CDATA[一、对原型模式的理解原型模式是创建模式的一种，主要通过复制一个实例来创建一个实例，而不是通过新建一个实例。被复制的实例，我们称之为原型，这个原型是可定制的。 二、代码实现创建原型类，实现原型接口 1234567891011121314151617181920// 原型public abstract class Prototype implements Cloneable&#123; public Object clone() throws CloneNotSupportedException&#123; return super.clone(); &#125;&#125;class ConcretePrototype1 extends Prototype&#123; public static int classFlay = 1; // 克隆自身方法 public Object clone() throws CloneNotSupportedException&#123; return (ConcretePrototype1)super.clone(); &#125;&#125;class ConcretePrototype2 extends Prototype&#123; public static int classFlay = 2; // 克隆自身方法 public Object clone() throws CloneNotSupportedException&#123; return (ConcretePrototype2)super.clone(); &#125;&#125; main方法实现 12345678public static void main(String[] args) throws CloneNotSupportedException&#123; Prototype pro = new ConcretePrototype1(); ConcretePrototype1 cp = (ConcretePrototype1)pro.clone(); System.out.println(&quot;标记：&quot;+ cp.classFlay); Prototype pro2 = new ConcretePrototype2(); ConcretePrototype2 cps = (ConcretePrototype2)pro2.clone(); System.out.println(&quot;标记：&quot;+ cps.classFlay); 运行结果 12标记：1标记：2 三、UML类图 四、笔记原型的优点: 性能提高 避免构造函数的约束 让客户隐藏制造新实例的复杂性 提供然客户能够产生未知类型对象的选项 在有些时候，复制对象比创建对象更有效 原型的用途和缺点 在一个复杂类层次中，当系统需要许多类型创建新对象的时候，可以考虑使用原型模式 对象复制的时候，有些时候特别的复杂]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－备忘录模式]]></title>
    <url>%2F20181025.html</url>
    <content type="text"><![CDATA[一、对备忘录模式的理解 备忘录就是备忘的意思，就像git一样，每个状态都记得，如果代码写错了，还可以回到历史版本。而且对现有版本不回产生影响，如果还需要回到现有版本也是可以的。可以实现撤销功能。实现的时候主要需要一个发起人、守护人、和一个备忘录类。 二、代码实现创建备忘录类，用于存放数据 1234567891011 // 备忘录public class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return this.state; &#125;&#125; 创建发起人类、用来设置状态，获取备忘录、设置备忘录等功能。 1234567891011121314151617181920// 发起人public class Originator &#123; private String state; public void setState(String state)&#123; this.state = state; &#125; public String getState() &#123; return this.state; &#125; // 保存状态到备忘录 public Memento saveStateToMemento()&#123; return new Memento(state); &#125; // 通过备忘录获取状态 public void getStateFromMemento(Memento m) &#123; state = m.getState(); &#125;&#125; 创建守护者类、用于存放历史备忘录、增加历史版本备忘录，通过下标获取备忘录等 1234567891011// 守护者public class CareTaker &#123; private List&lt;Memento&gt; list = new ArrayList&lt;Memento&gt;(); public void add(Memento m) &#123; list.add(m); &#125; public Memento getMemento(int i) &#123; return list.get(i); &#125;&#125; main 方法实现 1234567891011121314151617public static void main(String[] args) &#123; Originator origin = new Originator(); CareTaker ct = new CareTaker(); origin.setState(&quot;状态1&quot;); origin.setState(&quot;状态2&quot;); ct.add(origin.saveStateToMemento()); origin.setState(&quot;状态3&quot;); ct.add(origin.saveStateToMemento()); origin.setState(&quot;状态4&quot;); System.out.println(&quot;当前状态为:&quot;+ origin.getState()); origin.getStateFromMemento(ct.getMemento(0)); System.out.println(&quot;回到第一个状态为:&quot;+ origin.getState()); origin.getStateFromMemento(ct.getMemento(1)); System.out.println(&quot;回到第二个状态为:&quot;+ origin.getState()); &#125; 运行结果 123当前状态为:状态4回到第一个状态为:状态2回到第二个状态为:状态3 三、UML类图 四、笔记定义：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 备忘录的优点： 将被存储的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。 保持关键对象的数据封装 提供了容易实现的恢复能力 备忘录的用途和缺点： 备忘录用于存储状态 存储和恢复状态可能比较费时间 java中可以考虑使用序列化机制存储系统的状态。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java memento</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－中介者模式]]></title>
    <url>%2F20181024.html</url>
    <content type="text"><![CDATA[一、对中介者模式的理解中介者就是处理很多类与类之前耦合太多的的一种方式。比如5个类都互相耦合，改动一个类都会动到其他的类，中介者模式利用星形结构改善这种情况。 二、 代码实现中介类 12345678910111213141516171819202122232425262728293031// 抽象中介者public abstract class AbstractMediator &#123; public AbstractColleague A; public AbstractColleague B; public AbstractMediator(AbstractColleague A, AbstractColleague B)&#123; this.A = A; this.B =B; &#125; public abstract void AaffectB(); // a转b public abstract void BaffectA(); // b转a&#125;// 中介者class Mediator extends AbstractMediator&#123; public Mediator(AbstractColleague A, AbstractColleague B) &#123; super(A, B); &#125; @Override public void AaffectB() &#123; int i = A.getNumber(); B.setNumber(i*1000); &#125; @Override public void BaffectA() &#123; int i = B.getNumber(); A.setNumber(i/1000); &#125; &#125; 同事类 12345678910111213141516171819202122232425262728293031// 抽象中介者public abstract class AbstractMediator &#123; public AbstractColleague A; public AbstractColleague B; public AbstractMediator(AbstractColleague A, AbstractColleague B)&#123; this.A = A; this.B =B; &#125; public abstract void AaffectB(); // a转b public abstract void BaffectA(); // b转a&#125;// 中介者class Mediator extends AbstractMediator&#123; public Mediator(AbstractColleague A, AbstractColleague B) &#123; super(A, B); &#125; @Override public void AaffectB() &#123; int i = A.getNumber(); B.setNumber(i*1000); &#125; @Override public void BaffectA() &#123; int i = B.getNumber(); A.setNumber(i/1000); &#125; &#125; main方法运行 1234567891011121314public static void main(String[] args) &#123; AbstractColleague collA = new ColleagueA(); AbstractColleague collB = new ColleagueB(); AbstractMediator am = new Mediator(collA, collB); collA.setNumber(1000, am); System.out.println(&quot;collA:&quot;+collA.getNumber()); System.out.println(&quot;collB:&quot;+collB.getNumber()); System.out.println(&quot;-------&quot;); collB.setNumber(1000, am); System.out.println(&quot;collA:&quot;+collA.getNumber()); System.out.println(&quot;collB:&quot;+collB.getNumber()); &#125; 运行结果 12345collA:1000collB:1000000----collA:1collB:1000 三、UML类图 四、笔记中介者模式定义: 用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示的相互作用，从而使耦合松散，而且可以独立的改变它们之间的交互。 中介者模式的优点： 将对象解耦之后，可以增加对象的互用 通过将控制逻辑集中，可以简化系统维护 可以让对象之间传递的消息变的简单，而且大幅度减少 中介者模式用途和缺点 中介者模式常常被用来协调相关的GUI组件 如果设计不当，中介者对象本身会变的过于复杂]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java mediator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－解释器模式]]></title>
    <url>%2F201810231.html</url>
    <content type="text"><![CDATA[一、对解释器的理解解释器就像翻译一样，将我们不认识的语言（简化的语言如o2o）翻译为我们认识的普通的语言。如果事物频繁的出现，但是比较复杂，不容易看懂。我们就可以把它表述为一个简单的事物，最用用一个解释器去解释简单的事物就可以了。 二、代码实现创建表达式接口 1234// 创建一个表达式接口public interface Expression &#123; public boolean interpret(String content); // 解释&#125; 终端表达式 1234567891011121314// 终端表达式public class TerminalExpression implements Expression&#123; private String data; public TerminalExpression(String data)&#123; this.data = data; &#125; @Override public boolean interpret(String content) &#123; if (content.contains(data)) &#123; // 包含 return true; &#125; return false; &#125;&#125; 与表达式 12345678910111213// 与表达式public class OrExpression implements Expression&#123; private Expression ex1; private Expression ex2; public OrExpression (Expression ex1, Expression ex2) &#123; this.ex1 = ex1; this.ex2 = ex2; &#125; @Override public boolean interpret(String content) &#123; return this.ex1.interpret(content) || this.ex2.interpret(content); &#125;&#125; 和表达式 12345678910111213// 和表达式public class AndExpression implements Expression&#123; private Expression ex1; private Expression ex2; public AndExpression(Expression ex1, Expression ex2) &#123; this.ex1 = ex1; this.ex2 = ex2; &#125; @Override public boolean interpret(String content) &#123; return ex1.interpret(content) &amp;&amp; ex2.interpret(content); &#125;&#125; 解析器 123456789101112131415// 解析器public class Interpreter &#123; // 获取男性表达式 public static Expression getMaleExpression()&#123; Expression wang = new TerminalExpression(&quot;小王&quot;); Expression zhang = new TerminalExpression(&quot;小张&quot;); return new OrExpression(wang,zhang); &#125; // 获取女性表达式 public static Expression getWomanExpression() &#123; Expression wu = new TerminalExpression(&quot;小吴&quot;); Expression li = new TerminalExpression(&quot;小李&quot;); return new OrExpression(wu,li); &#125;&#125; main方法实现 1234567public static void main(String[] args) &#123; Expression isMale = Interpreter.getMaleExpression(); Expression isWoman = Interpreter.getWomanExpression(); System.out.println(&quot;小李是女的&quot;+ isWoman.interpret(&quot;小李&quot;)); System.out.println(&quot;小王是男的&quot;+ isMale.interpret(&quot;小王&quot;)); System.out.println(&quot;小王是男的&quot;+ isMale.interpret(&quot;小李&quot;)); &#125; 运行结果 123小李是女的true小王是男的true小王是男的false 三、UML类图 四、笔记解释器模式的优点: 将每一个语法规则表示成一个类，方便与实现语言. 因为语法由多个类组成，因此你可以轻易的扩张语言. 可以在新的类中增加新的方法，可以在解释的同时增加新的行为。 解释器的用途和缺点: 当需要实现一个简单的语言的时候，可以使用解释器。 当有一个简单的语法，简单比效率更重要是，使用解释器。 可以处理脚本语言和编程语言 如果语法规则数量太多，使用解释器模式可能会很复杂。这个时候可以使用解析器／编译器的产生器更合适。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java interpreter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[translation spring]]></title>
    <url>%2F20181023.html</url>
    <content type="text"><![CDATA[home 导航：projects^(项目)、guides^(指南)、blog^(博客) spring cloud Edgware released^(发布) spring framework5.0 the right^(正确) stack^(堆栈) for the right job^(工作) 谷歌翻译：适合正确工作的正确堆栈 join^(加入) us in austin , texas 谷歌翻译:加入我们在 austin， texas automate ops for spring cloud on cloud foundry 谷歌翻译:自动化Spring的Ops Cloud Foundry上的云 pivotal^(关键的) web service 有道翻译: 关键web服务 spring: the source^(来源) for modern^(现代) java spring: 来源现代java源代码 your app : spring &gt; spring boot &gt; spring cloud &gt; spring cloud data flow projects whatever^(无论什么) you’re building , these guides are designed^(计划) to get you productive^(生产的) as quickly^(快速的) as possible^(可能性) - using the latest^(最新) spring project releases^(释放) and techniques^(技术) as recommended^(推荐) by the spring team. 无论你正在构建什么，这些指南都尽可能快的提高你的工作效率－spring 团队推荐你使用最新项目版本和技术 have a suggestion^(建议) for a new guide ? let^(允许) us know at @springcentra 有新指南的建议吗? 请告诉我们@springcentra getting started guides 入门指南 designed to be completed^(完成) in 15-30 minutes , these guides provide^(提供) quick^(核心)，hands-on^(动手) instructions^(指令) for building the “hello world” of any development^(开发) task^(任务) with spring.in most^(大多数) cases^(情况), the only^(仅仅) prerequisites^(先决条件) are a JDK and a text editor^(编辑). 计划15-30分钟完成，这些指南提供快速，简单的操作指令用spring可以构建任何的“helle world” 开发任务。在大多数情况，它的先决条件仅仅是JDK和文本编辑器。 building a RESTful Web Service 构建一个RESTful web 服务 learn how to create a RESTful web service with spring 学习怎样用spring创建一个RESTful web 服务 scheduling^(行程安排) tasks^(任务) 计划任务 learn how to schedule tasks with spring 学习怎样用spring 去计划任务 consuming^(消耗) a RESTful Web Service 使用RESTful web 服务 learn how to retrieve^(检索) web page data with spring’s RestTemplate 学习怎样用spring的RestTemplate检索网页数据 building java projects with grable 用grable构建java项目 learn how to build a java projects with grable 学习怎样用grable构建一个java项目 building java projects with maven 用maven构建java项目 learn how to build a java projects with maven 学习怎样用maven构建一个java项目 accessing relational data using jdbc with spring 用spring使用jdbc访问关系形数据 learn how access relational data with spring 学习怎样访问关系形数据用spring uploading files 上传文件 learn how build a spring application that accepts multi-part^(多部分) file uploads. 学习怎样创建一个多文件上传的spring应用 authenticating a user with LDAP 用LDAP认证用户 learn how to secure an application with LDAP 学习怎样用LDAP保护一个应用程序 messaging with Redis 用redis消息传递 learn how to use redis as a message broker^(经纪人) 学习怎样使用redis消息代理 messaging with rabbitMQ 用rabbitMQ发送消息 learn how to create a simple publish-and-subscribe application with spring and rebbitMQ 学习怎样用spring和rebbitMQ去创建一个简单的发布订阅应用]]></content>
      <categories>
        <category>translation</category>
      </categories>
      <tags>
        <tag>translation spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－蝇量模式]]></title>
    <url>%2F201810221.html</url>
    <content type="text"><![CDATA[一、对蝇量模式（享元模式）的理解蝇量模式的作用就是减少对象的创建次数，比如相同的对象，总是需要实例化，而且量比较大这个时候就可以考虑使用蝇量模式了。它的实现方式就是创建Map去存储对象，每次需要新创建对象的时候，就可以在map中去判断是否存在，如果不存在则新创建，否则共享之前的对象。所有也称之为享元模式。 二、代码实现创建汽车类 1234567891011public class Car &#123; private String brand; public Car(String brand)&#123; System.out.println(&quot;___创建&quot;+brand+&quot;汽车&quot;); this.brand = brand; &#125; public void drive() &#123; System.out.println(&quot;开&quot;+ brand + &quot;车&quot;); &#125;&#125; 创建汽车管理者 12345678910111213public class CarKeeper &#123; private Map&lt;String, Car&gt; map = new HashMap&lt;String, Car&gt;(); public Car getCar(String name) &#123; Car car = this.map.get(name); if (car == null) &#123; car = new Car(name); this.map.put(name, car); return car; &#125; return car; &#125;&#125; main方法实现 123456789101112131415public static void main(String[] args) &#123; CarKeeper ck = new CarKeeper(); Car car1 = ck.getCar(&quot;奥迪&quot;); car1.drive(); Car car2 = ck.getCar(&quot;宝马&quot;); car2.drive(); Car car3 = ck.getCar(&quot;雷克萨斯&quot;); car3.drive(); Car car4 = ck.getCar(&quot;雷克萨斯&quot;); car4.drive(); Car car5 = ck.getCar(&quot;宝马&quot;); car5.drive(); Car car6 = ck.getCar(&quot;奥迪&quot;); car6.drive(); &#125; 运行结果 123456789___创建奥迪汽车开奥迪车___创建宝马汽车开宝马车___创建雷克萨斯汽车开雷克萨斯车开雷克萨斯车开宝马车开奥迪车 三、UML类图 四、笔记感觉这个模式的UML图是最简单的，和单例模式差不多。 蝇量模式的优点： 减少运行时对象实例的个数，节省内存。 将许多“虚拟”对象的状态集中管理 蝇量模式的用途和缺点: 当一个类有许多的实例，而这些实例能被同一个方法控制的时候，就可以使用蝇量模式 一旦实现了蝇量模式，那么单个的逻辑实例将无法独立的实现不同的行为。]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java chainOfResponsibility</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在2018结束之前的目标]]></title>
    <url>%2F20181021.html</url>
    <content type="text"><![CDATA[2018年还有最多四个月就结束了，从写第一行代码到现在已经有两年多了。在这两年多的时间里，学习的很多的知识，总是在马不停蹄的学习，但是总是感觉学习的不够，也总是很浮躁，总想学习更多的东西，总是想贪多。但是如果一直这样下去的话，自己只会变的越来越浮躁。必须逼自己一下，要让自己沉淀下来，深入学习底层原理，这样才能走的更远。 一、设计模式 最近买了head first的书，已经看完了，总共23个设计模式。距离实现全部的模式我还差6个。学习的方式，就是先看一遍书籍，然后想一个相同案例,之后源码实现，画UML类图，通过自己的总结之后在纪录到自己的博客里面。在写博客的时候，全部手打，不能容忍自己command c 之后 command v 。当然只是这样还是不够的，需要在以后的代码中灵活的使用这些设计模式，这才是最重要的。 目标总的目标就是实现完所有的设计模式，并理解每个设计模式的原理。并大量的在代码中实现。 二、英语对于我的垃圾英语，我已经无力吐槽了。总是想好好的学习，但是自己总是给了自己种种的借口，这种借口我也不知道要持续到什么时候。我想要尽快的结束这种借口，能让自己可以在看English的文档的时候能游刃有余。今天看到了有大牛写的关于学习English的博客，自我感觉最重要的就是坚持，只要在学习的道路上坚持下去就会有所沉淀。对于English的学习也就是听、说、读、写。我现在写English文档那是还有很大一段的路要走的。听和说，对于不想讲话的我也是比较遥远的。所以只剩下了读，这也是对我最重要的，也是最迫切需要的。对许学习读的方法对我比较好的就是看各种美剧的剧本（很喜欢看美剧），或者技术文档（很大文档都是需要看的）。于是我选择的就是看技术文档。 目标 每天看技术文档，目前想要学习的技术就是spring,spring boot,spring cloud，就从这个开始，尽量多的抽时间看技术文档。让自己的技术和英语一起进步，让自己泡在English的spring里面。 如果看的实在费劲，就写博客，一边翻译spring的技术，一边学习English. 三、spring, spring boot, spring cloud现在公司写的项目就是基于spring boot实现的，虽然功能实现了，但是感觉很多的技术，自己都没有摸透。需要花大量的时间，去好好的琢磨。spring 也是只会基础的。底层原理自己也没有去梳理一遍。spring cloud更是才了解一点。 目标看spring源码，了解spring底层实现。了解spring boot原理，学习spring cloud搭建以及实现。 总结总的来说，事情还是很多的，首先先看spring的英文文档。通过文档学习技术和英语。如果技术无法增长，就购买最近很想买的spring 三剑客。好好学习。 在就是自己的娱乐时间，感觉需要缩短一些。现在看新闻、看短视频、看朋友圈，总是会花很多的时间。希望自己能合理安排时间，多一些学习的时间，加油。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life 2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记]]></title>
    <url>%2F20181022.html</url>
    <content type="text"><![CDATA[java方法中参数的传递(java中只有值传递)： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型)(方法中改变基本类型数据，不会影响到之前的数据。相当于拷贝数据) 一个方法可以改变一个对象参数的状态。(对象: 方法中改变对象的数据，原始的对象的值会跟着改变。) 一个方法不能让对象参数引用一个新的对象 ==与equals的区别== 判断的是是否是对象的地址，即判断连个对象是不是同一个地址。（基本数据类型对比的是值，引用数据类型对比的是对象地址） equals 判断的是值是否相同（对象没有覆盖equals方法相当于== ，否则通过覆盖的equals判断对象的值是否相等） 如果对象需要用equals对比，需要重写equals方法。 String 对象是重写过equals方法的，所有string的equals对比的是值。 当创建string类型对象的时候，虚拟机会在常量池中找是否有相同的对象，如果有就把它赋给当前引用，否则就新创建对象 hashCode与equals hashCode的作用就是获取哈西码。它实际返回的是一个int整数。这个哈西码的作用就是确定索引的位置（可以快速找到所需要的对象）。 hashCode在map中的作用就是为了减少equals的执行次数,相应就提高了执行速度。 如果不同的对象拥有相同的hashCode值，他们也不一定是相等的。如果相同的情况下，就像HashSet一样，会使用equals去对比值是否相同。 java iojava jvm多线程集合]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－责任链模式]]></title>
    <url>%2F20181019.html</url>
    <content type="text"><![CDATA[一、对责任链模式的理解一个请求需要由多个对象处理，这些对象可以链接成为一条链。具体由那个类处理，由判断条件决定，如果该对象不能处理，则传给下一个对象处理。责任链将请求和处理分开。责任链比较好的例子就向请假一样，你需要请假10天，需要由你的主管确认，经理确认，总经理确认，全部通过才可以休假。但是如果请假5天，可能总经理就不用审核了，经理直接就可以处理这件事情。还有Logger的异常处理也是这种方式。下面的代码就是基于日志实现的。 二、代码实现创建一个抽象日志类 1234567891011121314151617181920212223// 抽象日志public abstract class AbstractLogger &#123; public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; public int level; public AbstractLogger nextLogger; // 下一个链条 public void setNextLogger(AbstractLogger al) &#123; this.nextLogger = al; &#125; public void logMessage(int le, String message) &#123; if (this.level&lt;=le) &#123; write(message); &#125; if (this.nextLogger != null) &#123; this.nextLogger.logMessage(le, message); &#125; &#125; abstract public void write(String message);&#125; 创建其他类继承抽象日志类 123456789101112131415161718192021222324252627282930// 打印日志public class ConsoleLogger extends AbstractLogger&#123; public ConsoleLogger(int le) &#123; this.level = le; &#125; @Override public void write(String message) &#123; System.out.println(&quot;打印日志:&quot;+message); &#125;&#125;class ErrorLogger extends AbstractLogger&#123; public ErrorLogger(int le) &#123; this.level = le; &#125; @Override public void write(String message) &#123; System.out.println(&quot;异常日志:&quot;+message); &#125;&#125;// 文件日志class FileLogger extends AbstractLogger&#123; public FileLogger(int le) &#123; this.level = le; &#125; @Override public void write(String message) &#123; System.out.println(&quot;文件日志:&quot; + message); &#125;&#125; 创建责任链链条 12345678910public class Chain &#123; public static AbstractLogger getChainOfLogger() &#123; AbstractLogger el = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fl = new FileLogger(AbstractLogger.DEBUG); AbstractLogger cl = new ConsoleLogger(AbstractLogger.INFO); el.setNextLogger(fl); fl.setNextLogger(cl); return el; &#125;&#125; main方法实现 1234567public static void main(String[] args) &#123; AbstractLogger al = Chain.getChainOfLogger(); al.logMessage(AbstractLogger.INFO, &quot;文件信息&quot;); al.logMessage(AbstractLogger.DEBUG, &quot;debug信息&quot;); al.logMessage(AbstractLogger.ERROR, &quot;异常信息&quot;); &#125; 执行结果 打印日志:文件信息 文件日志:debug信息 打印日志:debug信息 异常日志:异常信息 文件日志:异常信息 打印日志:异常信息 三、UML类图 四、笔记 责任链定义: 避免请求发送者和接收者耦合到一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。责任链模式是一种对象行为行模式。 责任链优点 将请求的发送者和接收者解耦。 简化对象，它不需要知道链的结构。 通过改变或调用链内成员的次序，允许动态新增和删除责任 责任链的用途和缺点 经常用到窗口系统中，处理鼠标键盘等事件。 并不保证请求一定会被执行，如果没有处理类去处理请求的话，可以会落到链尾之外。有好有坏 不较不容易观察运行特征，不好排除错误。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java chainOfResponsibility</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－桥接模式]]></title>
    <url>%2F201809011.html</url>
    <content type="text"><![CDATA[一、对桥接模式的理解在很多个网站都看到了桥接模式的定义，最直观的理解就是要画正方形、圆形、长方形，画笔有红色、蓝色、紫色。当出现了两个以上的类别(形状、颜色。一个类出现了两个独立的变化的维度，且这两个维度都需要进行扩展)的时候，就可以考虑使用桥接模式了。 桥接模式定义:将抽象部分与实现部分分离，使他们都可以独立的变化。它是一种对象结构型模式，又称为柄体模式或接口模式。 二、 代码实现创建颜色和形状的api接口，并创建红色、绿色、圆形、正方形等实现各自的接口。 12345678910111213141516171819202122232425262728293031323334353637383940// 颜色apipublic interface ColorAPI &#123; // 画 public void Draw();&#125;// 红色class Red implements ColorAPI&#123; @Override public void Draw() &#123; System.out.println(&quot;用红色的笔&quot; ); &#125;&#125;// 绿色class Green implements ColorAPI&#123; @Override public void Draw() &#123; System.out.println(&quot;用绿色的笔&quot;); &#125; &#125;// 形状apiinterface ShapeAPI &#123; // 画 public void Draw();&#125;// 圆形class Circle implements ShapeAPI&#123; @Override public void Draw() &#123; System.out.println(&quot;画圆形&quot;); &#125; &#125;class Square implements ShapeAPI&#123; @Override public void Draw() &#123; System.out.println(&quot;画正方形&quot;); &#125; &#125; 创建形状的抽象类，与抽象类的实现类 123456789101112131415161718192021222324// 形状抽象类public abstract class Shape &#123; ColorAPI colorAPI; ShapeAPI shapeAPI; Shape(ColorAPI ca ,ShapeAPI sa) &#123; this.colorAPI = ca; this.shapeAPI = sa; &#125; // 画的抽象方法 public abstract void draw();&#125;// 形状实现class ShapeImpl extends Shape&#123; ShapeImpl(ColorAPI ca, ShapeAPI sa) &#123; super(ca, sa); // TODO Auto-generated constructor stub &#125; @Override public void draw() &#123; this.colorAPI.Draw(); this.shapeAPI.Draw(); &#125;&#125; main方法运行 12345678public static void main(String[] args) &#123; Shape redCircle = new ShapeImpl(new Red(), new Circle()); Shape greenSquare = new ShapeImpl(new Green(), new Square()); Shape greenCircle = new ShapeImpl(new Green(), new Circle()); redCircle.draw(); greenSquare.draw(); greenCircle.draw(); &#125; 运行结果 123456用红色的笔画圆形用绿色的笔画正方形用绿色的笔画圆形 三、UML类图 四、 笔记 桥接模式定义: 将抽象个部分与它的实现部分分离，使他们可以独立的变化。它是一种对象结构型模式。 00原则 封装变化 针对接口编程，不针对实现编程 对增加开放，对修改关闭 不要来找我，我来找你 只对朋友交谈 为交互对象之间的松耦合设计而努力 多用组合，少用继承 类应该只有一个被改变的理由 依赖抽象，不依赖具体实现类 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－建造者模式]]></title>
    <url>%2F201810182.html</url>
    <content type="text"><![CDATA[一、对建造者模式的理解就是将多个简单的对象一步一步构建为一个复杂的对象。主要解决软件开发中的一个复杂对象的创建。代码就实现汉堡和饮料的点餐功能。我们创建包装接口，由瓶子装饮料，包装纸包装汉堡的实现类去实现包装接口。在创建一个项目接口，由汉堡和冷饮的抽象类去实现，之后创建各自的实现类去实现，汉堡有蔬菜汉堡和鸡肉汉堡，冷饮后百事可乐和可口可乐。在然后创建用餐的类采用list存放项目。最后创建一个用餐建造类来建造蔬菜餐和非蔬菜餐。 二、代码实现创建包装接口和各自的实现类 123456789101112131415161718192021package study.builder;// 装食物的填料接口public interface Packing &#123; public String pack(); // 大包&#125;// 包装纸材料class Wrapper implements Packing&#123; @Override public String pack() &#123; return &quot;包装材料&quot;; &#125;&#125;// 瓶子包装class Bottle implements Packing&#123; @Override public String pack() &#123; return &quot;瓶子包装&quot;; &#125; &#125; 创建项目接口，汉堡、冷饮接口以及各自的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 项目接口public interface Item &#123; public String name(); public Packing packing(); public float price();&#125;// 汉堡使用包装纸包装抽象类abstract class Burger implements Item&#123; public Packing packing()&#123; return new Wrapper(); &#125;; public abstract float price(); &#125;// 冷饮抽象类abstract class ColdDrink implements Item&#123; public Packing packing() &#123; return new Bottle(); &#125; public abstract float price();&#125;// 蔬菜汉堡class VegBurger extends Burger&#123; @Override public String name() &#123; return &quot;蔬菜汉堡&quot;; &#125; @Override public float price() &#123; return 18.8f; &#125;&#125;// 鸡肉汉堡class ChickenBurger extends Burger&#123; @Override public String name() &#123; return &quot;鸡肉汉堡&quot;; &#125; @Override public float price() &#123; return 28.8f; &#125;&#125;// 可口可乐class Coke extends ColdDrink&#123; @Override public String name() &#123; return &quot;可口可乐&quot;; &#125; @Override public float price() &#123; return 5.5f; &#125;&#125;// 百事可乐class Pepsi extends ColdDrink&#123; @Override public String name() &#123; return &quot;百事可乐&quot;; &#125; @Override public float price() &#123; return 5.6f; &#125;&#125; 创建用餐类 123456789101112131415161718192021// 餐public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void add(Item it )&#123; this.items.add(it); &#125; public float getCost() &#123; float cost = 0.0f; for(Item it : items) &#123; cost += it.price(); &#125; return cost; &#125; public void showItem()&#123; for(Item it : items) &#123; System.out.print(&quot;项目：&quot;+it.name()); System.out.print(&quot;, &quot; +it.packing().pack()); System.out.println(&quot;, 价格&quot; + it.price()); &#125; &#125;&#125; 创建构造餐类 12345678910111213141516// 建造餐public class MealBuilder &#123; // 准备蔬菜餐 public Meal prepareVegMeal() &#123; Meal meal = new Meal(); meal.add(new VegBurger()); meal.add(new Coke()); return meal; &#125; public Meal prepareNonVegMeal() &#123; Meal meal = new Meal(); meal.add(new ChickenBurger()); meal.add(new Pepsi()); return meal; &#125;&#125; main方法实现 12345678910public static void main(String[] args) &#123; MealBuilder mb = new MealBuilder(); Meal vegMeal = mb.prepareVegMeal(); vegMeal.showItem(); System.out.println(&quot;蔬菜餐的总价：&quot;+ vegMeal.getCost()); Meal nonvegMeal = mb.prepareNonVegMeal(); nonvegMeal.showItem(); System.out.println(&quot;肉类餐的总价：&quot;+ nonvegMeal.getCost()); &#125; 运行结果 123456项目：蔬菜汉堡, 包装材料, 价格18.8项目：可口可乐, 瓶子包装, 价格5.5蔬菜餐的总价：24.3项目：鸡肉汉堡, 包装材料, 价格28.8项目：百事可乐, 瓶子包装, 价格5.6肉类餐的总价：34.399998 三、 UML类图 四、 笔记 定义: 将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java builder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 API在线文档管理系统]]></title>
    <url>%2F20181018.html</url>
    <content type="text"><![CDATA[前言： 由于是前后端分离的项目，API是前后端最重要的沟通工具，用一个好的在线文档管理系统代替FTP等文本传输API是一个很不错的选择。在线文档比较好的开源文档系统就是wiki。MediaWiki是基于wiki用PHP开发的，配置起来比较复杂。后来发现一个MinDoc使用go语言开发的，特别方便。我将两种配置方式都记录一下。两种方式都需要安装mysql，CentOS7 的yum里面没有mysql，需要手动下载。 需要准备的就是配置外网可以访问的端口号，mindoc默认8181，可以先去配置好，阿里云的ECS服务器可以直接在安全组里面配置。 没有安装mysql的可以先安装mysql 123456789101112131415161718wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm //下载mysql的repo源sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm // 安装mysql-community-release-el7-5.noarch.rpm包sudo yum install mysql-server // 安装mysqlmysql -u root // 重置mysql密码// 出现ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)sudo chown -R root:root /var/lib/mysqlservice mysqld restart // 重启mysqlmysql //直接回车进入mysql控制台mysql &gt; use mysql; // 使用mysql数据库mysql &gt; update user set password=password(&apos;123456&apos;) where user=&apos;root&apos;; // 更改密码 一、MinDoc1. 下载MinDoc12345mkdir mindoc &amp;&amp; cd mindoc //创建一个目录wget https://github.com/lifei6671/mindoc/releases/download/v0.9/mindoc_linux_amd64.zip //下载二进制包unzip mindoc_linux_amd64.zip // 解压 2. 修改conf/app.conf 文件，打开文件注释123456789db_adapter=mysqldb_host=127.0.0.1db_port=3306db_database=mindoc_dbdb_username=rootdb_password=123456adb_adapter=sqlite3db_database=./database/mindoc.db 3. 当前目录进行安装1./mindoc_linux_amd64 install 4. 出现Install Successfully! 之后就可以运行并访问123./mindoc_linux_amd64 // 在线运行，不能退出nohup ./mindoc_linux_amd64 &amp; // 后台运行 访问http://IP:8181 即可，帐号admin 密码123456 end 二、mediawiki1. 安装需要的一些配置1yum install httpd php php-mysql php-gd php-xml mysql-server mysql libxml2 2. 在mysql启动的状态下配置mysql1mysql_secure_installation 3. 在mysql里面配置项目1234567create database wikidb; grant all on wikidb.* to root; grant all on wikidb.* to root@localhost; grant all on wikidb.* to wikiuser; grant all on wikidb.* to wikiuser@localhost; set password for wikiuser@localhost=password(&apos;wikipw&apos;); 4.修改httpd配置123456789vim /etc/httpd/conf/httpd.conf#ServerName www.example.com:80 // 前面的#去掉(去掉注释)vim /etc/hosts 127.0.0.1 localhost localhost.localadmin xxhost // 添加hostnameservice httpd restart // 启动网络服务 5.Mediawiki的手动安装12345678wget http://releases.wikimedia.org/mediawiki/1.22/mediawiki-1.22.5.tar.gztar -xvf mediawiki-1.22.5.tar.gz // 解压mv mediawiki-1.22.5 /var/www/html/w // 将解压后的文件夹移动到httpd.conf中DocumentRoot指定的文件夹中，默认是&quot;var/www/html&quot;chown -R 777 /var/www/html/w/chmod 777 /var/www/html/w/mw-config // 改变权限 通过http://ip/w/index.php访问，出现下面标志表示成功 两种方式都实现了，最后就需要自己去配置个性化的设置。这两个都有自己不同的展示方式，个人偏好与第一种页面风格很友好。功能也更加完善，编辑器也是基于Markdown的。]]></content>
      <categories>
        <category>utils</category>
      </categories>
      <tags>
        <tag>MinDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－复合模式]]></title>
    <url>%2F20181016.html</url>
    <content type="text"><![CDATA[一、对于复合模式的理解复合模式就是很多模式一起乱炖。工厂模式、抽象工厂模式、迭代器模式、组合模式、装饰模式、适配器模式、观察者模式，在一起使用。但是每次使用的时候都是在需要的时候使用。每个模式都有各自的作用，使用在一起就是会觉得代码非常的拥挤，很混乱。这个模式我是照搬书上的代码实现的。下面的代码就比较多了，书上面是循序渐进的讲解的，我是直接粘贴自己写的代码，不是很容易理解。可以先看看下面的类图。 二、代码实现创建鸭叫观察者，用于统计鸭子 123456789101112131415161718192021222324252627282930// 鸭叫观察者接口public interface QuackObservable &#123; public void registerObserver(Observer observer); public void notifyObservers();&#125;interface Observer &#123; public void update(QuackObservable duck);&#125;// 观察者辅助类class Observable implements QuackObservable&#123; ArrayList observers = new ArrayList(); QuackObservable duck; public Observable(QuackObservable q)&#123; this.duck = q; &#125; @Override public void registerObserver(Observer observer) &#123; this.observers.add(observer); &#125; @Override public void notifyObservers() &#123; Iterator it = this.observers.iterator(); while (it.hasNext()) &#123; Observer ob = (Observer)it.next(); ob.update(duck); &#125; &#125; &#125; 创建鸭叫能力接口以及各种鸭子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// 鸭叫能力接口public interface Quackable extends QuackObservable&#123; public void quack(); // 呱呱叫&#125;// 绿头鸭实现鸭叫能力接口class MallardDurk implements Quackable&#123; Observable ob; @Override public void quack() &#123; System.out.println(&quot;绿头鸭嘎嘎叫&quot;); this.ob = new Observable(this); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;// 红头鸭也实现鸭叫能力接口class RedheadDuck implements Quackable&#123; Observable ob; @Override public void quack() &#123; System.out.println(&quot;红头鸭嘎嘎叫&quot;); this.ob = new Observable(this); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;//鸭鸣器也实现了鸭叫能力接口class DuckCall implements Quackable&#123; Observable ob; @Override public void quack() &#123; System.out.println(&quot;鸭鸣器嘎嘎叫&quot;); this.ob = new Observable(this); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;// 橡皮鸭也实现了鸭叫能力接口class RubberDuck implements Quackable&#123; Observable ob; @Override public void quack() &#123; System.out.println(&quot;橡皮鸭嘎嘎叫&quot;); this.ob = new Observable(this); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;// 鹅class Goose&#123; public void honk() &#123; System.out.println(&quot;鹅咯咯叫&quot;); &#125;&#125;// 用适配器模式将鹅适配为鸭子class GooseAdapter implements Quackable&#123; Observable ob; Goose goose; public GooseAdapter(Goose goose) &#123; this.ob = new Observable(this); this.goose = goose; &#125; @Override public void quack() &#123; this.goose.honk(); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125;// 利用装饰者模式，在不改变原来鸭子类的情况下给鸭子添加计数功能class QuackCounter implements Quackable&#123; Observable ob; Quackable duck; static int num; public QuackCounter (Quackable quack) &#123; this.ob = new Observable(quack); this.duck = quack; &#125; @Override public void quack() &#123; this.duck.quack(); num++; &#125; public static int getNum() &#123; return num; &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125; 创建鸭叫的各种工厂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 鸭叫抽象工厂public abstract class AbstractDuckFactory &#123; public abstract Quackable createMallardDuck(); public abstract Quackable createRedheadDuck(); public abstract Quackable createDuckCall(); public abstract Quackable createRubberDuck();&#125;// 鸭叫工厂实现鸭叫抽象工厂class DuckFactory extends AbstractDuckFactory&#123; @Override public Quackable createMallardDuck() &#123; return new MallardDurk(); &#125; @Override public Quackable createRedheadDuck() &#123; return new RedheadDuck(); &#125; @Override public Quackable createDuckCall() &#123; return new DuckCall(); &#125; @Override public Quackable createRubberDuck() &#123; return new RubberDuck(); &#125;&#125;// 统计鸭子工厂继承鸭子抽象工厂class CountingDuckFactory extends AbstractDuckFactory&#123; @Override public Quackable createMallardDuck() &#123; // 先用叫声计数装饰着将quackable装饰起来 return new QuackCounter(new MallardDurk()); &#125; @Override public Quackable createRedheadDuck() &#123; return new QuackCounter(new RedheadDuck()); &#125; @Override public Quackable createDuckCall() &#123; return new QuackCounter(new DuckCall()); &#125; @Override public Quackable createRubberDuck() &#123; return new QuackCounter(new RubberDuck()); &#125;&#125; 创建一群鸭子 123456789101112131415161718192021222324252627// 用组合模式实现一群鸭子public class Flock implements Quackable&#123; Observable ob; ArrayList list = new ArrayList(); public Flock() &#123; this.ob = new Observable(this); &#125; @Override public void quack() &#123; Iterator it = list.iterator(); // 迭代器模式 while(it.hasNext()) &#123; Quackable q = (Quackable)it.next(); q.quack(); &#125; &#125; public void add(Quackable q) &#123; list.add(q); &#125; @Override public void registerObserver(Observer observer) &#123; this.ob.registerObserver(observer); &#125; @Override public void notifyObservers() &#123; this.ob.notifyObservers(); &#125;&#125; 创建呱呱叫学家 12345678public class Quackologist implements Observer&#123; @Override public void update(QuackObservable duck) &#123; System.out.println(&quot;呱呱叫学家：&quot;+duck); &#125;&#125; 创建鸭子模拟器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 鸭子模拟器public class DuckSimulator &#123; public void simulate() &#123; // 模拟 Quackable mallardDuck =new QuackCounter( new MallardDurk()); Quackable redheadDuck = new QuackCounter(new RedheadDuck()); Quackable duckCall = new QuackCounter(new DuckCall()); Quackable rubberDuck = new QuackCounter(new RubberDuck()); Quackable goose = new GooseAdapter(new Goose()); // 一只鹅 sumulate(mallardDuck); sumulate(redheadDuck); sumulate(duckCall); sumulate(rubberDuck); sumulate(goose); System.out.println(&quot;鸭子的数量为:&quot;+QuackCounter.getNum()); &#125; private void sumulate(Quackable qa) &#123; qa.quack(); &#125; // 重写构造方法 public void simulate(AbstractDuckFactory adf) &#123; Quackable mallardDuck =adf.createMallardDuck(); Quackable redheadDuck = adf.createRedheadDuck(); Quackable duckCall = adf.createDuckCall(); Quackable rubberDuck = adf.createRubberDuck(); Quackable goose = new GooseAdapter(new Goose()); // 一只鹅 Flock fock = new Flock(); // 一群乱七八糟的鸭子 fock.add(redheadDuck); fock.add(rubberDuck); fock.add(duckCall); fock.add(mallardDuck); Flock focks = new Flock(); Quackable redheadDuck1 = adf.createRedheadDuck(); //一群红头鸭子 Quackable redheadDuck2 = adf.createRedheadDuck(); Quackable redheadDuck3 = adf.createRedheadDuck(); Quackable redheadDuck4 = adf.createRedheadDuck(); focks.add(redheadDuck4); focks.add(redheadDuck3); focks.add(redheadDuck2); focks.add(redheadDuck1); System.out.println(&quot;红头鸭子打头&quot;); sumulate(focks); System.out.println(&quot;乱七八糟的鸭子来了&quot;); sumulate(fock); System.out.println(&quot;鸭子的数量为:&quot;+QuackCounter.getNum()); Quackologist ql = new Quackologist(); fock.registerObserver(ql); sumulate(fock); System.out.println(&quot;鸭子的数量为:&quot;+QuackCounter.getNum()); &#125;&#125; main方法运行 12345678public static void main(String[] args) &#123; DuckSimulator ds1 = new DuckSimulator(); ds1.simulate(); DuckSimulator ds = new DuckSimulator(); AbstractDuckFactory adf = new CountingDuckFactory(); ds.simulate(adf); &#125; 实现结果 12345678910111213141516红头鸭子打头红头鸭嘎嘎叫红头鸭嘎嘎叫红头鸭嘎嘎叫红头鸭嘎嘎叫乱七八糟的鸭子来了红头鸭嘎嘎叫橡皮鸭嘎嘎叫鸭鸣器嘎嘎叫绿头鸭嘎嘎叫鸭子的数量为:8红头鸭嘎嘎叫橡皮鸭嘎嘎叫鸭鸣器嘎嘎叫绿头鸭嘎嘎叫鸭子的数量为:12 三、UML类图 这个复合模式很复杂，需要掌握的技巧特别多，需要反复学习。后面就要学习mvc模式了，也是属于复合模式。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－mvc模式]]></title>
    <url>%2F20180901.html</url>
    <content type="text"><![CDATA[时间过的很快，什么都没学习到。就已经过去了大半的时间。这次是需要好好理解一下复合模式mvc。在java web开发中经常会用到mvc模式，总是大概的了解，没有弄懂最重要的东西。这次好好的学习一下mvc模式，用表格归纳一下常见的mvc模式。 模型 视图 控制器 mvc model view controller java中常见的mvc java bean jsp servlet mvc复合模式 观察者模式 组合模式 策略模式 一、对MVC模式的理解]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 代理模式]]></title>
    <url>%2F201809010.html</url>
    <content type="text"><![CDATA[昨天将组合模式完成了，组合模式可以遍历树状的集合。迭代器模式可以遍历不同类型的集合。如果有树状结构的集合，可以优先考虑使用组合模式。 一、对于代理模式的理解定义：给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。就想黄牛一样，委托代买票业务给黄牛，黄牛收钱买票，我不知道黄牛是如何买票的，卖票的人不知道是谁买票的，便于保护真实用户。代理模式也经常用于远程代理，和虚拟代理等 二、代码实现创建一个主题，用于黄牛和真实的我继承。12345// 创建主题接口public interface Subject &#123; // 买票 public void buyTicket();&#125; 创建一个真的我，买票.实现主题 1234567// 真实主题（我）public class RealSubject implements Subject&#123; @Override public void buyTicket() &#123; System.out.println(&quot;我要买票回家&quot;); &#125;&#125; 创建代理类，实现主题 1234567891011121314// 代理买票（黄牛）public class Proxy implements Subject&#123; @Override public void buyTicket() &#123; RealSubject rs = new RealSubject(); rs.buyTicket(); this.compterTicket(); &#125; // 不公开的买票方式，通过电脑买票 private void compterTicket() &#123; System.out.println(&quot;黄牛进行买票&quot;); &#125;&#125; mian方法运行 12345public static void main(String[] args) &#123; // 调用者完全不知道是谁买票，只知道是一个黄牛保护目标 Subject sb =new Proxy(); sb.buyTicket(); &#125; 运行结果 12我要买票回家黄牛进行买票 三、UML类图 四、笔记 封装变化 针对接口编程，不针对实现编程 对修改关闭，对扩展开放 多用组合，少用继承 为交互对象之间的松耦合设计而努力 依赖抽象，不依赖具体类 只和朋友交谈 别找我，我会找你 类应该只有一个改变的理由 定义: 为另一个对象提供一个替身或占位符以访问这个对象 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 使用jenkins+maven+git实现自动化部署java项目]]></title>
    <url>%2F20181011.html</url>
    <content type="text"><![CDATA[要将项目发布到通过外网访问，就需要将jar或者war通过scp传到服务器，在启动项目。如果项目中更改了一行代码，那么就需要进行一下步骤： 本地将项目打包为war或者jar包 将打包后的文件传到服务器 将之前项目kill掉 将新项目移动到指定位置启动 但有了jenkins后我们就可以只需要将代码提交到git或者svn上面就可以了，其它的事情全部交给jenkins去完成。要实现这个功能大概的思路如下： 1、安装jenkins（自动化配置）2、安装git（管理项目）3、安装maven(编译项目)4、配置jenkins如下 安装插件 （jenkins集成tomcat、svn、git等的插件） 全局工具配置（让jenkins找到jdk,maven,git的环境变量等） 创建任务一、安装jenkins由于yum的repo里面没有jenkins,先配置yum12sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key yum安装1yum -y install jenkins 更改jenkins配置 1vi /etc/sysconfig/jenkins 将JENKINS_NAME改为root,JENKINS_PORT改为8081 启动jenkins1service jenkins start 开通8081的端口号之后，通过在外网用http://ip地址:8081 访问出现如下页面即可： 根据提示，在/var/lib/jenkins/secrets/initialAdminPassword中找到密码复制进去点击继续，不要着急稍微等待一会之后即可看到如下页面 之后点击第一个默认配置，右边的是自定义配置，不熟悉的可以选择第一个（左边的那个）之后就是漫长的等待，等jenkins下载基础插件 安装完成之后就创建自己的账号和密码吧！ 之后点击继续后出现下面这个页面就安装完成了 二、安装maven配置yum1wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo yum安装1yum -y install apache-maven 查看是否安装成功 1mvn -v 三、安装git12yum -y install gitgit --version // 查看git版本号 四、配置jenkins1、安装插件maven integration 插件：用于maven集成jenkins，如果不安装就不会有“构建一个maven”项目选项 2、全局工具配置（让jenkins找到jdk,maven,git等）3、新建任务遇到的坑：1、配置git出现如下错误 因为此仓库为我的私有仓库，需要配置Credentials，点开add， Add Credentials的 Kind选择SSH Username with private key，Username选择之前在github上传的公钥用户的用户名，此次为root，Private Key为jenkins服务器登录github的本地私钥，查看私钥cat /root/.ssh/id_rsa （如果没有这个文件则生成命令为：ssh-keygen -t rsa）复制粘贴到Key区域，完成添加。此时可以发现报错已经消失。构建的时候可能会遇到git超时可以安装这个处理[https://www.jianshu.com/p/264772bb9264](https://www.jianshu.com/p/264772bb9264)要这个页面将超时时间设置长一些，我设置的是260分钟。默认是10分钟，由于项目比较大，通过git将项目迁到服务器总是超时。设置这个就好了 2、构建触发器，就是设置何时开始启动build，运行程序。选这里选默认3、其它的先不动将build改为如下： 4.在写sh脚本的时候要加 BUILD_ID=dontKillMe 否则项目不会启动 1234567891011121314151617#!/bin/bashport=8098echo &quot;check $port&quot;grep_port=`netstat -tlpn | grep &quot;\b$port\b&quot;`echo &quot;grep port is $grep_port&quot;if [ -n &quot;$grep_port&quot; ]then echo &quot;端口 $port 在使用&quot; netstat -nlp |grep :8098 |grep -v grep|awk &apos;&#123;print $7&#125;&apos; |awk -F &apos;/&apos; &apos;&#123;print $1&#125;&apos; |xargs kill -9 echo &quot;kill 掉$port 端口&quot;else echo &quot;端口没有被使用&quot;fiecho &quot;开始重启&quot;# 此处要注意加BUILD_ID=dontKillMe 否则jenkins不会将项目启动下去BUILD_ID=dontKillMe nohup java -jar /var/lib/jenkins/workspace/projectName/target/projectName-0.0.1-SNAPSHOT.jar &amp;echo &quot;jenkins 自动化部署成功&quot; 最后在控制台查看jenkins部署日志，项目需要用maven可以编译通过 五、配置git钩子触发jenkins构建]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装mysql]]></title>
    <url>%2F20181013.html</url>
    <content type="text"><![CDATA[下载mysql的repo源 1wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 安装mysql-community-release-el7-5.noarch.rpm包 1sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 3.安装mysql 1sudo yum install mysql-server 4.进入mysql 1mysql 5.报错ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户： 1sudo chown -R root:root /var/lib/mysql 6.重启mysql 1service mysqld restart 7.更改密码 1update user set password=password(&apos;123456&apos;) where user=&apos;root&apos;;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 组合模式]]></title>
    <url>%2F20180903.html</url>
    <content type="text"><![CDATA[已经有一段时间没有写模式了，在把迭代器模式写了之后，本应该是写组合模式的，但是组合模式涉及到递归，感觉很麻烦，于是就跳跃了，没有及时写下来，之后看了代理模式，复合模式等。都没有记录下来。现在是时候好好理一下这些模式了，昨天复习了下之前的模式，特别感觉工厂方法和抽象工厂都有些模糊了。看来要努力了，加油！ 一、对组合模式的理解组合模式定义：允许你将对象组合成树形结构来表现“整体／部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象集合。 个人理解就是处理树形结构集合的一种模式就想树一样，是有根，有无数的树枝，无数的叶子，一成一层的，就像电脑文件夹一样 二、代码实现实现抽象类12345678// 抽象组合类public abstract class Component &#123; String name; public Component(String name) &#123; this.name = name; &#125; public abstract void operation(int index); // 操作&#125; 实现叶子类,继承抽象组合类 1234567891011121314151617// 叶子public class Leaf extends Component&#123; public Leaf(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; @Override public void operation(int index) &#123; String str = &quot;&quot;; for (int i=0; i&lt;index; i++) &#123; str = str+ &quot; &quot;; &#125; System.out.println(str + name); &#125;&#125; 实现树枝类，继承抽象组合类 123456789101112131415161718192021222324252627282930public class Composite extends Component&#123; private LinkedList&lt;Component&gt; childer; public Composite(String name) &#123; super(name); this.childer = new LinkedList&lt;&gt;(); &#125; @Override public void operation(int index) &#123; String str = &quot;&quot;; for (int i=0; i&lt;index; i++) &#123; str = str+ &quot; &quot;; &#125; LinkedList&lt;Component&gt; list = this.getChilder(); System.out.println(str + name); for (Component c : list) &#123; c.operation(index+1); &#125; &#125; public void add(Component com) &#123; this.childer.add(com); &#125; public void remove(Component com) &#123; this.childer.remove(com); &#125; public LinkedList&lt;Component&gt; getChilder()&#123; return this.childer; &#125; &#125; main方法实现 123456789101112131415161718192021222324public static void main(String[] args) &#123; Composite root = new Composite(&quot;root&quot;); Composite branch = new Composite(&quot;branch&quot;); Composite branch1 = new Composite(&quot;branch1&quot;); Composite branch2 = new Composite(&quot;branch2&quot;); Composite branch3 = new Composite(&quot;branch3&quot;); branch.add(new Leaf(&quot;leaf1&quot;)); branch.add(new Leaf(&quot;leaf2&quot;)); branch1.add(new Leaf(&quot;leaf3&quot;)); branch2.add(new Leaf(&quot;leaf4&quot;)); branch1.add(branch2); branch2.add(new Leaf(&quot;leaf5&quot;)); branch2.add(new Leaf(&quot;leaf6&quot;)); branch3.add(new Leaf(&quot;leaf7&quot;)); branch3.add(new Leaf(&quot;leaf8&quot;)); branch2.add(branch3); root.add(branch); root.add(branch1); root.operation(0); &#125; 运行结果 12345678910111213root branch leaf1 leaf2 branch1 leaf3 branch2 leaf4 leaf5 leaf6 branch3 leaf7 leaf8 三、UML类图 四、笔记oo原则 封装变化 多用组合，少用继承 针对接口编程，不针对实现编程 为交互对象之间的松耦合设计而努力 类应该对扩展开放，对修改关闭 依赖抽象，不依赖具体类 只和朋友交谈 别找我，我会找你 类应该只有一个改变的理由 组合模式：允许你将对象组成树形结构来表现“整体／部分”的层次结构，组合能让客户以一致的方式处理个别对象和对象组合。 组合也可以和迭代器一起使用 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 - 状态模式]]></title>
    <url>%2F20180908.html</url>
    <content type="text"><![CDATA[之前学习的是组合模式和迭代器模式，迭代器模式已经实现了，但是组合模式，涉及到递归，没怎么理解透彻，因此准备最后攻克难关 一、对于状态模式的理解状态就像初中学习的物理一样（水），水是液态的、加热之后就变成了蒸汽就是雾态、结冰了就是固态。我们就可以描述水的不同状态。例如经常在公共场所会遇到自动售货机，没有用户投币的时候就可以理解为一种状态，投币之后是一种投币状态、用户选择产品就是一种选择状态、售货机从货架推出产品就是一种出售状态、产品卖空了就是一种售罄状态。如果我们只写一个类用if else去实现这种功能，就会有很多重复的代码。后期添加新的功能也特别不方便，需要改动的源代码也特别多。但是用状态模式去管理这些状态的话，后期添加新的功能，就会是一件很轻松的事情。而且对于后期的维护，也会大有裨益。状态模式就是将所有不同的状态都封装成类，最后通过一个展示的类去调用这些状态类，当然所有的状态类都实现了一个状态接口，方便利用多态在展示的类中去调用。最后实现，通过同一种调用方式，可以改变不同的状态。在不同的状态下，同一个方法，可以实现不同的业务逻辑。状态模式的定义：允许对象在内部状态改变时改变它的行为，对象看起来像是修改了它的类 二、代码实现创建状态接口，并创建通用的投币、退币、选择产品、出货等方法 1234567// 状态接口public interface State &#123; public void insertMoney(); // 投币 public void exitMoney(); // 退币 public void selectProduct(); // 选择产品 public void dispense(); // 发放产品&#125; 创建自动售货机类 123456public class AutoSales &#123; State soldOutState; State noMoneyState; State hasMoneyState; State soldState;&#125; 创建售罄类实现状态接口 1234567891011121314151617181920212223242526272829303132// 售謦状态public class SoldOutState implements State&#123; AutoSales autoSales; public SoldOutState() &#123; super(); &#125; public SoldOutState(AutoSales as) &#123; this.autoSales = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;以售罄，请不要投币&quot;); this.autoSales.setState(this.autoSales.getSoldOutState()); // 将状态改为售罄 &#125; @Override public void exitMoney() &#123; System.out.println(&quot;以售罄，无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;以售罄，无法选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;以售罄，无法获得产品&quot;); &#125;&#125; 待投币状态实现状态接口 1234567891011121314151617181920212223242526272829303132// 没有投币的状态public class NoMoneyState implements State&#123; AutoSales as; public NoMoneyState() &#123; super(); &#125; public NoMoneyState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;投币了&quot;); this.as.setState(this.as.getHasMoneyState()); // 将状态改为以投币 &#125; @Override public void exitMoney() &#123; System.out.println(&quot;没有投币，无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;没有投币，无法选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;没有投币，无法出货&quot;); &#125; &#125; 已投币状态也实现状态接口 123456789101112131415161718192021222324252627282930313233// 已投币public class HasMoneyState implements State&#123; AutoSales as; public HasMoneyState() &#123; super(); &#125; public HasMoneyState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;又投币了&quot;); &#125; @Override public void exitMoney() &#123; System.out.println(&quot;开始退币了&quot;); this.as.setState(this.as.getNoMoneyState()); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;发放产品&quot;); this.as.setState(this.as.getSoldState()); &#125; &#125; 已售出状态实现状态接口 1234567891011121314151617181920212223242526272829303132333435// 售出状态public class SoldState implements State&#123; AutoSales as; public SoldState(AutoSales as) &#123; this.as = as; &#125; @Override public void insertMoney() &#123; System.out.println(&quot;又投币了&quot;); &#125; @Override public void exitMoney() &#123; System.out.println(&quot;产品已售出,无法退币&quot;); &#125; @Override public void selectProduct() &#123; System.out.println(&quot;选择产品&quot;); &#125; @Override public void dispense() &#123; System.out.println(&quot;出货&quot;); if (this.as.getCount() &gt;0 ) &#123; this.as.setState(as.getNoMoneyState()); // 将状态变为没投币之前 &#125; else &#123; System.out.println(&quot;产品卖完了&quot;); this.as.setState(as.getSoldOutState()); // 将状态变为售罄 &#125; &#125;&#125; 完善自动售货机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 自动售货机public class AutoSales &#123; State soldOutState; State noMoneyState; State hasMoneyState; State soldState; State state = soldState; int count = 0; public AutoSales(int num) &#123; this.count = num; soldOutState = new SoldOutState(this); noMoneyState = new NoMoneyState(this); hasMoneyState = new HasMoneyState(this); soldState = new SoldState(this); if (num&gt;0) &#123; state = noMoneyState; &#125; &#125; // 投币 public void insertMoney()&#123; state.insertMoney(); &#125;; // 退币 public void exitMoney()&#123; this.state.exitMoney(); &#125;; // 选择产品 public void selectProduct()&#123; this.state.selectProduct(); &#125;; // 发放产品 public void dispense()&#123; this.state.dispense(); &#125;; public void setState(State state) &#123; this.state = state; &#125; public State getSoldOutState() &#123; return soldOutState; &#125; public State getNoMoneyState() &#123; return noMoneyState; &#125; public State getHasMoneyState() &#123; return hasMoneyState; &#125; public State getSoldState() &#123; return soldState; &#125; public State getState() &#123; return state; &#125; public int getCount() &#123; return count; &#125; @Override public String toString() &#123; return &quot;AutoSales [售罄=&quot; + soldOutState.getClass() + &quot;, 待投币=&quot; + noMoneyState.getClass() + &quot;, 已投币=&quot; + hasMoneyState.getClass() + &quot;, 出售=&quot; + soldState.getClass() + &quot;, state状态=&quot; + state.getClass() + &quot;, count=&quot; + count + &quot;]&quot;; &#125;&#125; main方法运行 1234567891011121314151617181920public static void main(String args[]) &#123; // 给自动售货机装5个产品 AutoSales as = new AutoSales(5); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.insertMoney(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.selectProduct(); as.dispense(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.exitMoney(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); as.insertMoney(); as.selectProduct(); as.insertMoney(); as.selectProduct(); as.dispense(); System.out.println(&quot;--当前状态：&quot; +as.getState().getClass()); &#125; 运行结果 1234567891011121314--当前状态：class study.state.NoMoneyState投币了--当前状态：class study.state.HasMoneyState选择产品发放产品--当前状态：class study.state.SoldState产品已售出,无法退币--当前状态：class study.state.SoldState又投币了选择产品又投币了选择产品出货--当前状态：class study.state.NoMoneyState 三、UML类图 四、笔记oo原则 封装变化 多用组合、少用继承 针对接口编程，不针对实现编程 对修改关闭，对增加开放 你不要来找我，我来找你 为交互之间的松耦合设计而努力 依赖抽象，不依赖具体类 只和朋友交谈 类应该只有一个被改变的理由 状态模式定义： 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信朋友圈python爬虫]]></title>
    <url>%2F20180907.html</url>
    <content type="text"><![CDATA[安装环境 virtualenv vir // 安装虚拟环境 pip install itchat // 安装微信插件 报错No matching distribution found for itchat之后通过https://www.jianshu.com/p/832245fc7276解决了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－单例模式]]></title>
    <url>%2F20180905.html</url>
    <content type="text"><![CDATA[之前学习是简单工厂模式、工厂方法模式、抽象工厂模式，复习一下 简单工厂模式简单工厂模式大概就是创建一个简单工厂类，由工厂类实例化对象。由参数决定实例化那个类 工厂方法模式创建一个抽象工厂类，里面包含一个抽象方法。由这个工厂去生产产品，具体的就是实现类实现工厂，并完成抽象方法的功能实现（如月饼抽象生产类，南方月饼类实现月饼抽象生产类，北方月饼实现月饼抽象生产类，等等）。调用不是由参数决定，是由创建者决定 抽象工厂模式创建抽象工厂类生产工厂，创建抽象产品类生产产品，并各自实现。形成产品族（一个大的家族）对于之前的理解模糊可以看这个：https://www.zhihu.com/question/20367734 一、 对单例模式的理解单例模式就像太阳一样，只有一个。在使用的时候，只能实例化一次。不能多次实例化。二、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 单例模式 太阳（synchronized，重量级）public class sun &#123; private static sun s = null; private sun() &#123;&#125; // 单例模式 这种方式多线程时会出现混乱的情况，不建议使用 public static sun getSun() &#123; if (s == null) &#123; s = new sun(); &#125; return s; &#125; // (同步方法)添加同步锁，在不考虑性能的时候可以使用该方法 public static synchronized sun getSunSyn() &#123; if (s == null) &#123; s = new sun(); &#125; return s; &#125;&#125;// 月亮（双重检查加锁）class moon &#123; // volatile 当moon初始化为实例时，能保证多个线程正确的处理moon变量 private volatile static moon m; private moon() &#123;&#125;; // 减少synchronized的使用 public static moon getMoon() &#123; if (m == null) &#123; synchronized (moon.class) &#123; if (m == null) &#123; m = new moon(); &#125; &#125; &#125; return m; &#125;&#125;// 地球（急切）class earth&#123; // 在静态初始化器中创建单件，这段代码保证了线程安全 private static earth e = new earth(); private earth()&#123;&#125;; // 在jvm 加载这个类的时候创建此唯一的单例模式。 public static earth getEarth() &#123; return e; &#125;&#125; 三、UML类图 四、笔记oo设计原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为对象之间的松耦合设计而努力 类应该对扩展开发、修改关闭 依赖抽象、不要依赖具体类单例模式定义：确保一个类只有一个实例，并提供全局访问点 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－命令模式]]></title>
    <url>%2F201809018.html</url>
    <content type="text"><![CDATA[之前学习的是单例模式。但里模式就是只有一个对象被实例化，如注册表等。单例模式有几种实现方式一是用同步锁创建一个私有的构造器，和一个同步的公开的方法。这种方式简便，但是性能不是很好，使用的是同步锁（重量级的）。二是创建一个静态产量直接new一个对象。也是有私有的构造器不让对象创建。通过公开的方法返回静态常量new的对象，保证对象只有一个。这种方法在jvm创建的时候就会产生对象，如果不使用该对象，则会产生浪费三是用volatile创建静态属性。用私有构造器不让对象创建，通过公开的get方法获取对象，获取的时候判断对象是否存在，如果不存在则用同步锁防止多线程出现错误。最后返回对象。这种是常用的方法。 一、对于命令模式的理解一个命令执行一个操作。每个命令都是一个操作。不用去关心对象是怎么做的，只需要发送命令即可。就像传菜员一样。 二、 代码实现创建一个命令接口 12345// 命令接口public interface Command &#123; public void execute(); // 执行 public void undo(); // 撤销&#125; 在创建一个电视 123456789// 电视public class TV &#123; public void on() &#123; System.out.println(&quot;开电视&quot;); &#125; public void off() &#123; System.out.println(&quot;关电视&quot;); &#125;&#125; 创建一个开电视命令 123456789101112131415161718// 开电视public class TVOnCommand implements Command&#123; TV tv; public TVOnCommand(TV tv) &#123; this.tv = tv; &#125; @Override public void execute() &#123; tv.on(); &#125; @Override public void undo() &#123; System.out.println(&quot;开电视撤销准备。。。&quot;); tv.off(); &#125;&#125; 创建一个关电视命令 1234567891011121314151617public class TVOffCommand implements Command&#123; TV tv; public TVOffCommand(TV tv) &#123; this.tv = tv; &#125; @Override public void execute() &#123; tv.off(); &#125; @Override public void undo() &#123; System.out.println(&quot;关电视撤销准备。。。&quot;); tv.on(); &#125;&#125; 创建一个简单的远程控制器（遥控器） 1234567891011121314151617// 简单远程控制public class SimpleRemoteController &#123; Command command; Command undoCommand; public SimpleRemoteController()&#123;&#125;; // 利用有参构造器初始化命令 public void setCommand(Command command) &#123; this.command = command; &#125; public void start() &#123; command.execute(); this.undoCommand = this.command; &#125; public void undo() &#123; this.undoCommand.undo(); &#125;&#125; main方法实现 123456789101112131415public static void main(String args[]) &#123; // 创建远程控制器 SimpleRemoteController simpleRemoteController = new SimpleRemoteController(); TV tv = new TV(); // 创建电视 TVOnCommand tvon = new TVOnCommand(tv); // 创建关电视命令 simpleRemoteController.setCommand(tvon); // 通过远程控制器设置关电视的命令 simpleRemoteController.start(); // 按开始按钮 simpleRemoteController.undo(); TVOffCommand tvoff = new TVOffCommand(tv); // 创建关电视命令 simpleRemoteController.setCommand(tvoff); // 通过远程控制器设置关电视的命令 simpleRemoteController.start(); // 按开始按钮 simpleRemoteController.undo();&#125; 运行结果 123456开电视开电视撤销准备。。。关电视关电视关电视撤销准备。。。开电视 实现宏命令（实现一组命令）创建宏命令 123456789101112131415161718192021// 宏命令public class MacroCommand implements Command&#123; Command[] commands; public MacroCommand(Command[] command)&#123; this.commands = command; &#125; @Override public void execute() &#123; for(Command c : this.commands )&#123; c.execute(); &#125; &#125; @Override public void undo() &#123; for(Command c : this.commands )&#123; c.undo(); &#125; &#125;&#125; 创建宏的远程控制 12345678910111213141516171819// 遥控器public class RemoteController &#123; Command[] onCommands; Command[] offCommands; public RemoteController () &#123; this.onCommands = new Command[2]; this.offCommands = new Command[2]; &#125; public void setCommand(int index, Command on,Command off) &#123; this.onCommands[index] = on; this.offCommands[index] = off; &#125; public void on(int index) &#123; this.onCommands[index].execute(); &#125; public void off(int index) &#123; this.offCommands[index].execute(); &#125;&#125; 创建一个电脑操作类 12345678public class Computer &#123; public void on() &#123; System.out.println(&quot;开电脑&quot;); &#125; public void off() &#123; System.out.println(&quot;关电脑&quot;); &#125;&#125; 关电脑命令 1234567891011121314151617public class ComputerOffCommand implements Command&#123; Computer computer; public ComputerOffCommand(Computer com) &#123; this.computer = com; &#125; @Override public void execute() &#123; this.computer.off(); &#125; @Override public void undo() &#123; System.out.println(&quot;关电脑撤销准备。。。&quot;); this.computer.on(); &#125;&#125; 开电脑命令 1234567891011121314151617public class ComputerOnCommand implements Command&#123; Computer computer; public ComputerOnCommand(Computer computer) &#123; this.computer = computer; &#125; @Override public void execute() &#123; this.computer.on(); &#125; @Override public void undo() &#123; System.out.println(&quot;开电脑撤销准备。。。&quot;); this.computer.off(); &#125;&#125; main方法运行 1234567891011121314Computer computer = new Computer();RemoteController remoteController = new RemoteController();ComputerOffCommand coffc = new ComputerOffCommand(computer);ComputerOnCommand conc = new ComputerOnCommand(computer);// 实现宏命令Command[] on = &#123;tvon, conc&#125;;Command[] off = &#123;tvoff,coffc&#125;;MacroCommand onmc = new MacroCommand(on);MacroCommand offmc = new MacroCommand(off);remoteController.setCommand(0, onmc, offmc);System.out.println(&quot;宏命令结束&quot;);remoteController.on(0);System.out.println(&quot;单独执行&quot;);remoteController.off(0); 运行结果 123456宏命令结束开电视开电脑单独执行关电视关电脑 三、UML类图 四、笔记 封装变化 多用组合少用继承 针对接口编程，不针对实现编程 为交互对象之间的松耦合设计而努力 对扩展开放、对修改关闭 依赖抽象，不依赖具体类 命令模式定义： 将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其它对象。命令模式也可以支持撤销操作。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－模版方法模式]]></title>
    <url>%2F201809020.html</url>
    <content type="text"><![CDATA[之前学习的是适配器模式与外观模式。 对外观模式与适配器模式的理解适配器模式的意思就是适配，将三孔插座转换为二孔插座的转换头。通过适配器可以将两个不一样的接口（有共同点）适配在一起。外观模式就是统一接口，将很多方法，统一在一个类里面实现。让使用者不会感觉方法太多杂乱。就像一个开关控制所有电器，和每个电器单独使用的一样。如果使用一个开关控制所有，就会特别方便。但是之前的开关也存在，如果需要单独使用，也是可以的。 先看下定义 模版方法：在一个方法中定义一个算法的骨架，而将一些步骤延伸到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 一、 对模版方法的理解模版方法就是将重复的方法封装在一个类中，变动的方法就用抽象方法抽象出来。将方法模版化，其它子类使用的时候，公用的方法就不用再次实现类，只需要实现抽象方法。大大的降低类代码的重复。比较好玩的就是钩子方法，可以通过子类控制父类的通用方法，很方便。我用炒大白菜和炒生菜举了个例子。 二、 代码实现创建烹饪抽象类123456789101112131415161718192021222324252627282930public abstract class Cooking &#123; // 准备烹饪 public void prepareCooking() &#123; WashingVegetables(); addVegetables(); addSalt(); // 根据菜的样式判断是否加辣椒 if (isChiliHooks()) &#123; addChili(); &#125; &#125; // 洗菜 public void WashingVegetables() &#123; System.out.println(&quot;洗菜&quot;); &#125; // 加盐 public void addSalt()&#123; System.out.println(&quot;加盐&quot;); &#125; // 加辣椒 public void addChili() &#123; System.out.println(&quot;加辣椒&quot;); &#125; // 是否加辣椒钩子 public boolean isChiliHooks() &#123; return true; &#125; // 放菜进锅炒，根据不同的实现，炒不同的菜 abstract void addVegetables();&#125; 创建大白菜类，大白菜重构类模版方法的抽象方法，放入类大白菜123456789// 大白菜public class ChineseCabbage extends Cooking&#123; @Override void addVegetables() &#123; System.out.println(&quot;放入大白菜&quot;); &#125;&#125; 创建生菜类，也实现类抽象方法。最后重写类父类的钩子，实现类不加辣椒 123456789101112// 炒生菜public class lettuce extends Cooking&#123; @Override void addVegetables() &#123; System.out.println(&quot;放入生菜&quot;); &#125; // 不放辣椒 public boolean isChiliHooks() &#123; return false; &#125;&#125; main方法实现 1234567public static void main(String agrs[]) &#123; ChineseCabbage cc = new ChineseCabbage(); cc.prepareCooking(); System.out.println(&quot;+++++++++&quot;); lettuce lt = new lettuce(); lt.prepareCooking(); &#125; 运行结果 12345678洗菜放入大白菜加盐加辣椒+++++++++洗菜放入生菜加盐 三、UML类图 四、笔记 封装变化 多用组合、少用继承 面向接口编程、不面向实现编程 只和朋友交谈 对修改关闭、对扩展开放 为交互对象之间的松耦合设计而努力 别找我、我会找你（好莱坞原则） 依赖抽象、不要依赖具体类 巩固模版方法定义: 在一个方法中定义一个算法的骨架，而将一些步骤延伸到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－适配器与外观模式]]></title>
    <url>%2F20180904.html</url>
    <content type="text"><![CDATA[之前学习的是命令模式 对于命令模式的理解命令模式就是将操作封装为一个类（一个命令）。在通过一个控制器把命令封装进去，就像一个遥控器，最后通过不同的命令就可以实现不同的操作 一、 对适配器模式和观察者模式的理解适配器模式就是改变一个接口，实现不同的操作。就像插座转换头一样，将三孔插座转换为二孔插座。外观模式字面上就是好的形象的意识。将一些操作集合在一起，统一调用，简单又方便。就像家里面的插头到处都是。我们可以把所有的插头都插在一个大插板上面。每次使用的时候，就可以只用开、关大插板就可以。不用每次都插很多插头。 二、代码实现适配器模式三孔插座1234567891011// 三孔插座public interface SocketThree &#123; public void chargeThree();&#125;class SocketThreeImpl implements SocketThree&#123; @Override public void chargeThree() &#123; System.out.println(&quot;三孔插座&quot;); &#125;&#125; 两孔插座123456789101112// 两孔插座public interface SocketTwo &#123; public void chargeTwo();&#125;class SocketTwoImpl implements SocketTwo&#123; @Override public void chargeTwo() &#123; System.out.println(&quot;两孔插座&quot;); &#125; &#125; 插座适配器123456789101112// 插座适配器 将三孔插座转换为二孔插座， 看着像二孔，但是实际上还是三孔public class SocketAdapter implements SocketTwo&#123; SocketThree socketThree; public SocketAdapter(SocketThree socketThree) &#123; this.socketThree = socketThree; &#125; @Override public void chargeTwo() &#123; System.out.println(&quot;转换后的两孔插座&quot;); this.socketThree.chargeThree(); &#125;&#125; main方法运行 123456// 适配器模式 SocketThree st = new SocketThreeImpl(); st.chargeThree(); // 通过转换器将三孔插座转换为两孔插座 SocketTwo stwo = new SocketAdapter(st); stwo.chargeTwo(); 运行结果123三孔插座转换后的两孔插座三孔插座 外观模式新建电视、电灯、烤火炉类12345678910111213141516171819202122232425public class TV &#123; public void on() &#123; System.out.println(&quot;开电视&quot;); &#125; public void off() &#123; System.out.println(&quot;关电视&quot;); &#125;&#125;class Light&#123; public void on() &#123; System.out.println(&quot;开电灯&quot;); &#125; public void off() &#123; System.out.println(&quot;关电灯&quot;); &#125;&#125;class Stove&#123; public void on() &#123; System.out.println(&quot;开火炉&quot;); &#125; public void off() &#123; System.out.println(&quot;关火炉&quot;); &#125;&#125; 大插板（不让插头凌乱，外观好看）12345678910111213141516171819202122// 买了一个大插板，将电视、烤火炉、电灯的插头都插在这个大插板上面public class FacadeSocket &#123; TV tv; Light light; Stove stove; public FacadeSocket(TV tv,Light light,Stove stove) &#123; this.tv = tv; this.light = light; this.stove = stove; &#125; // 通过外观模式统一处理 public void on() &#123; this.tv.on(); this.light.on(); this.stove.on(); &#125; public void off() &#123; this.tv.off(); this.light.off(); this.stove.off(); &#125;&#125; main方法实现12345678910public static void main(String srgs[])&#123; // 外观模式 TV tv = new TV(); Light light = new Light(); Stove stove = new Stove(); // 创建大插板， 统一开关 FacadeSocket fs = new FacadeSocket(tv, light,stove); fs.on(); fs.off();&#125; 运行结果123456开电视开电灯开火炉关电视关电灯关火炉 三、UML类图 四、笔记oo设计原则 封装变化 依赖接口编程，不依赖实现编程 为交互对象之间的松耦合设计而努力 对修改关闭、对扩展开放 多用组合，少用继承 依赖抽象、不依赖具体类 只和朋友交谈 适配器模式定义： 将一个类的接口，转移成为可以期望的另一个接口。适配器让原本不兼容的两个类可以合作无间 外观模式定义： 提供类一个统一的接口，用来访问子系统中的一群接口。外观定义类一个高层接口，让子系统更容易使用。 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－迭代器模式]]></title>
    <url>%2F20180902.html</url>
    <content type="text"><![CDATA[昨天学习的是模版方法模式复习一下 对于模版方法的理解：模版方法模式就是创建一个模版类，并创建一个抽象方法，和调用方法。该方法（一般是静态方法，不能修改的）调用复用的模版类方法（实现通用的业务逻辑）和抽象方法。子类继承模版类之后，重写抽象方法（不同的业务逻辑）。模版类中可以设置钩子方法，用于控制模版类的通用方法是否调用。这样做的好处就是可以子类可以调用很多通用的方法，减少大量的重复代码。抽象方法也可以实现子类独有的方法。钩子还可以控制通用方法。使方法调用更加的灵活。模版方法就是为类的方法创建特别灵活的模版。 一、对于迭代器的理解通过看书之后，我觉得迭代器就是一个可以遍历所有不同集合类型对象的的一种方式。如用ArrayList, new [], HashMap等集合存储对象数据。如果要遍历就需要写三个for循环才可以完成遍历。但是有迭代器之后，就可以用一个迭代器完成三种不同类型的集合的遍历。总结出来就是：迭代器可以遍历所有实现了迭代器接口的不同类型的集合 二、代码实现实现思路：创建一个宠物类，有动物的名字、年龄、简介等。动物生病了就会找医生。每个医生都有自己的笼子，张医生的笼子使用ArrayList制作的。李医生的笼子使用Animal[]制作的。两个医生都在同一个宠物店里面上班。医生太忙了，领导来医院视察的时候，需要服务员小花去给领导报告两位医生的宠物都叫什么名字，年龄多少、宠物具体的情况等。如果没有迭代器，小花就需要拿张医生的ArrayList笼子的钥匙去看，李医生的钥匙和张医生的钥匙又不一样，每次都要拿不同的钥匙看不同的笼子，特别麻烦。而且还要去每个医生的工作区域才可以。但是有了迭代器，小花就不用拿这个多钥匙了，只要一种钥匙，而且不用去两个工作区域查看，就感觉像迭代器将宠物汇总了。小花只要拿一种钥匙，不用知道医生使用什么笼子关宠物的，只需要在一个地方查看在记录好报告领导就可以了。下面看代码。 1、 自己创建一个迭代器实现创建一个动物类 1234567891011121314151617181920// 动物类public class Animal &#123; String name; int age; String description; public Animal(String name, int age, String des) &#123; this.name = name; this.age = age; this.description = des; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getDescription() &#123; return description; &#125;&#125; 创建张医生和李医生，用不同的笼子关动物 123456789101112131415161718192021222324252627282930313233343536373839404142// 张医生用ArrayList笼子关动物public class DoctorZhang &#123; ArrayList ans; public DoctorZhang() &#123; ans = new ArrayList(); addAnimal(&quot;小狗&quot;,8, &quot;黄色的小狗&quot;); addAnimal(&quot;小猫&quot;,4, &quot;黑色的小猫&quot;); addAnimal(&quot;小猪&quot;,4, &quot;白色的小猪&quot;); &#125; // 增加动物方法 public void addAnimal(String name, int age, String des)&#123; Animal an = new Animal(name, age, des); this.ans.add(an); &#125; public Iterator createIterator() &#123; return new DoctorZhangIterator(this.ans); &#125;&#125;// 李医生用［］笼子关动物class DoctorLi&#123; static final int MAX=5; int number = 0; Animal[] animal; public DoctorLi() &#123; animal =new Animal[MAX]; addAnimal(&quot;小乌龟&quot;,8, &quot;黄色的小乌龟&quot;); addAnimal(&quot;小猴&quot;,4, &quot;黑色的小猴&quot;); addAnimal(&quot;大猪&quot;,4, &quot;黄色的大猪&quot;); &#125; // 增加动物方法 public void addAnimal(String name, int age, String des)&#123; if (number&gt;=MAX)&#123; return; &#125; Animal an = new Animal(name, age, des); this.animal[number] = an; this.number++; &#125; public Iterator createIterator() &#123; return new DoctorLiIterator(this.animal); &#125;&#125; 创建一个迭代器，并用张医生李医生去实现迭代器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 迭代器接口public interface Iterator &#123; boolean hasNext(); Object next();&#125;// 李医生迭代器实现迭代器接口class DoctorZhangIterator implements Iterator&#123; ArrayList ans; int index = 0; public DoctorZhangIterator(ArrayList ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.size() || ans.get(index) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans.get(index); index ++; return animal; &#125; &#125;//张医生迭代器实现迭代器接口class DoctorLiIterator implements Iterator&#123; Animal[] animal; int index = 0; public DoctorLiIterator(Animal[] animal) &#123; this.animal = animal; &#125; @Override public boolean hasNext() &#123; if (index &gt;= animal.length || animal[index] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal an = animal[index]; index ++; return an; &#125; &#125; 创建一个宠物店类 12345678910111213141516171819202122232425// 宠物店public class PetShop &#123; DoctorZhang zhang; DoctorLi li; public PetShop(DoctorZhang zhang,DoctorLi li) &#123; this.zhang = zhang; this.li = li; &#125; // 小花就用这个方法统计宠物 public void printAnimal() &#123; Iterator it = zhang.createIterator(); Iterator its = li.createIterator(); System.out.println(&quot;张医生的宠物&quot;); printAnimal(it); System.out.println(&quot;李医生的宠物&quot;); printAnimal(its); &#125; private void printAnimal(Iterator it) &#123; while(it.hasNext()) &#123; Animal an = (Animal)it.next(); System.out.println(&quot;名字为：&quot;+an.getName()+&quot; 年龄为：&quot;+an.getAge() + &quot; 介绍：&quot;+an.getDescription()); &#125; &#125;&#125; main方法实现－－ 领导来视察了，小花就去统计 123456public static void main(String args[]) &#123; DoctorZhang zhang =new DoctorZhang(); DoctorLi li = new DoctorLi(); PetShop ps =new PetShop(zhang, li); ps.printAnimal();&#125; 运行结果 12345678张医生的宠物名字为：小狗 年龄为：8 介绍：黄色的小狗名字为：小猫 年龄为：4 介绍：黑色的小猫名字为：小猪 年龄为：4 介绍：白色的小猪李医生的宠物名字为：小乌龟 年龄为：8 介绍：黄色的小乌龟名字为：小猴 年龄为：4 介绍：黑色的小猴名字为：大猪 年龄为：4 介绍：黄色的大猪 2、用上面的代码重构为java util 类里面的迭代器实现动物类不变动，改动两个医生的代码迭代器为。注意迭代器换为了import java.util.Iterator; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 张医生实现java util里面的迭代器public class DoctorZhangIteratorJavaUtil implements Iterator&#123; Animal[] ans; int index = 0; public DoctorZhangIteratorJavaUtil(Animal[] ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.length || ans[index] == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans[index]; index ++; return animal; &#125; public void remove() &#123; if (index &lt;=0) &#123; throw new IllegalStateException(&quot;没有可以删除的了&quot;); &#125; if(ans[index-1] !=null) &#123; for(int i = index-1; i&lt;(ans.length -1); i++) &#123; ans[i] = ans[i+1]; &#125; ans[ans.length - 1] = null; &#125; &#125;&#125;class DoctorLiIteratorJavaUtil implements Iterator&#123; ArrayList ans; int index = 0; public DoctorLiIteratorJavaUtil(ArrayList ans) &#123; this.ans = ans; &#125; @Override public boolean hasNext() &#123; if (index &gt;= ans.size() || ans.get(index) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; @Override public Object next() &#123; Animal animal = (Animal) ans.get(index); index ++; return animal; &#125;&#125; 改动两个医生的代码为。注意迭代器换为了import java.util.Iterator; ｀// 张医生用ArrayList区分动物public class DoctorLiJavaUtil implements Doctor{ ArrayList ans; public DoctorLiJavaUtil() { ans = new ArrayList(); addAnimal(“小狗”,8, “黄色的小狗”); addAnimal(“小猫”,4, “黑色的小猫”); addAnimal(“小猪”,4, “白色的小猪”); } // 增加动物方法 public void addAnimal(String name, int age, String des){ Animal an = new Animal(name, age, des); this.ans.add(an); } public Iterator createIterator() { // 直接使用ArrayList的迭代器 return this.ans.iterator(); }}// 李医生用［］区分动物class DoctorZhangJavaUtil implements Doctor{ static final int MAX=5; int number = 0; Animal[] animal; public DoctorZhangJavaUtil() { animal =new Animal[MAX]; addAnimal(“小乌龟”,8, “黄色的小乌龟”); addAnimal(“小猴”,4, “黑色的小猴”); addAnimal(“大猪”,4, “黄色的大猪”); } // 增加动物方法 public void addAnimal(String name, int age, String des){ if (number&gt;=MAX){ return; } Animal an = new Animal(name, age, des); this.animal[number] = an; this.number++; } public Iterator createIterator() { return new DoctorZhangIteratorJavaUtil(this.animal); }}// 新增的医生接口interface Doctor { public Iterator createIterator();}1更改宠物店的代码 // 宠物店import java.util.Iterator;public class PetShopJavaUtil { Doctor zhang; Doctor li; public PetShopJavaUtil(Doctor zhang,Doctor li) { this.zhang = zhang; this.li = li; } public void printAnimal() { Iterator it = zhang.createIterator(); Iterator its = li.createIterator(); System.out.println(&quot;张医生的宠物&quot;); printAnimal(it); System.out.println(&quot;李医生的宠物&quot;); printAnimal(its); } private void printAnimal(Iterator it) { if (it == null) { return; } while(it.hasNext()) { Animal an = (Animal)it.next(); System.out.println(&quot;名字为：&quot;+an.getName()+&quot; 年龄为：&quot;+an.getAge() + &quot; 介绍：&quot;+an.getDescription()); } } } 1main方法运行 public static void main(String args[]) { // java.util 迭代器使用 System.out.println(&quot;++++++++++++++++java.util 迭代器 &quot;); DoctorZhangJavaUtil zhangJavaUtil =new DoctorZhangJavaUtil(); DoctorLiJavaUtil liJavaUtil = new DoctorLiJavaUtil(); PetShopJavaUtil psJavaUtil =new PetShopJavaUtil(zhangJavaUtil, liJavaUtil); psJavaUtil.printAnimal(); } 12运行结果 ++++++++++++++++java.util 迭代器张医生的宠物名字为：小乌龟 年龄为：8 介绍：黄色的小乌龟名字为：小猴 年龄为：4 介绍：黑色的小猴名字为：大猪 年龄为：4 介绍：黄色的大猪李医生的宠物名字为：小狗 年龄为：8 介绍：黄色的小狗名字为：小猫 年龄为：4 介绍：黑色的小猫名字为：小猪 年龄为：4 介绍：白色的小猪` 三、UML类图 四、笔记 封装变化 多用组合,少用继承 面向接口编程，不面向实现编程 为交互对象之间的松耦合设计而努力 对扩展开放，对修改关闭 只跟朋友交谈 依赖抽象不要依赖具体类 别找我，我会找你 类应该只有一个被改变的理由 迭代器模式定义： 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴其露内部的表示 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－工厂模式]]></title>
    <url>%2F201809017.html</url>
    <content type="text"><![CDATA[之前学的是装饰者模式 装饰者模式的优点动态地为对象增加新的功能或者撤销功能（继承就不能做到这一点） 装饰者模式的缺点会产生过多的相似的对象！ 一、对工厂模式的理解简单工厂：通过工厂类生成不同的类。工厂类返回一个父类型的类，通过if或者switch判断用户给的数据，通过不同的数据返回不同的类。工厂方法：比较重要的就是抽象类里面的一个抽象方法，所有继承了抽象类的类都必须实现该方法，之后在调用的时候利用多态动态的调用实现类的方法。抽象的方法里面就可以用简单工厂模式实现不同的类 二、代码实现(简单工厂、工厂方法、抽象工厂)1、简单工厂 创建月饼类123456789101112131415161718192021public class MoonCake &#123; public String name; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125;&#125;// 糖陷月饼class sugar extends MoonCake&#123; public sugar()&#123; System.out.println(&quot;糖陷&quot;); &#125;&#125;// 肉陷月饼class meat extends MoonCake &#123; public meat() &#123; System.out.println(&quot;肉馅&quot;); &#125;&#125; 创建简单月饼工厂1234567891011public class SimpleFactory &#123; public MoonCake createProduct(String type) &#123; MoonCake product = null; if (type.equals(&quot;meat&quot;))&#123; product = new meat(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; product = new sugar(); &#125; return product; &#125;&#125; 创建月饼工厂12345678910public class MoonCakeFactory &#123; SimpleFactory factory; public MoonCakeFactory(SimpleFactory factory) &#123; this.factory = factory; &#125; public MoonCake orderMoonCake(String type) &#123; MoonCake product = factory.createProduct(type); return product; &#125;&#125; main方法实现1234567public class run &#123; public static void main(String args[]) &#123; // 简单工厂模式 生产月饼 SimpleFactory simpleFactory = new SimpleFactory(); new MoonCakeFactory(simpleFactory).orderMoonCake(&quot;meat&quot;); &#125;&#125; 运行结果1肉馅 2、工厂方法月饼店抽象类1234567891011// 月饼店public abstract class MoonCakeStore &#123; public MoonCake orderMoonCake(String type) &#123; MoonCake mc; mc = createMoonCake(type); mc.kenad(); return mc; &#125; // 抽象的工厂方法 public abstract MoonCake createMoonCake(String type);&#125; 北方月饼店和南方月饼店123456789101112131415161718192021222324252627// 北方月饼店public class NorthMoonCakeStore extends MoonCakeStore&#123; @Override public MoonCake createMoonCake(String type) &#123; if (type.equals(&quot;meat&quot;)) &#123; return new NorthSytleMeatMoonCake(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new NorthSytleSugarMoonCake(); &#125; return null; &#125;&#125;// 南方月饼店public class SouthMoonCakeStroe extends MoonCakeStore&#123; @Override public MoonCake createMoonCake(String type) &#123; if (type.equals(&quot;meat&quot;)) &#123; return new SouthSytleMeatMoonCake(); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new SouthSytleSugarMoonCake(); &#125; return null; &#125;&#125; 月饼父类123456789public class MoonCake &#123; public String name; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125;&#125; 北方月饼和南方月饼12345678910class SouthSytleMeatMoonCake extends MoonCake&#123; public SouthSytleMeatMoonCake() &#123; name =&quot;南方风格的肉馅月饼&quot;; &#125;&#125;class SouthSytleSugarMoonCake extends MoonCake&#123; public SouthSytleSugarMoonCake() &#123; name = &quot;南方风格的糖陷月饼&quot;; &#125;&#125; main方法实现12345678910111213public class run &#123; public static void main(String args[]) &#123; // 工厂方法模式 生产月饼 MoonCakeStore mcs = new SouthMoonCakeStroe(); MoonCakeStore smcs = new NorthMoonCakeStore(); MoonCake mc = mcs.orderMoonCake(&quot;meat&quot;); System.out.println(mc.getName()); MoonCake mc1 = smcs.orderMoonCake(&quot;meat&quot;); System.out.println(mc1.getName()); &#125;&#125; 运行结果1234揉面粉南方风格的肉馅月饼揉面粉北方风格的肉馅月饼 3.抽象工厂 创建一个抽象月饼类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 面粉基类class flour &#123; &#125;// 芝麻基类class sesame&#123; &#125;// 重构之前的抽象月饼类public abstract class MoonCake1 &#123; String name; flour flour; sesame sesame; public void kenad() &#123; System.out.println(&quot;揉面粉&quot;); &#125; public String getName() &#123; return name; &#125; // 准备 abstract void prepare();&#125;//糖陷月饼class sugar1 extends MoonCake1&#123; MaterailFactory materailFactory; public sugar1()&#123; System.out.println(&quot;糖陷&quot;); &#125; public sugar1(MaterailFactory materailFactory) &#123; name = &quot;糖陷月饼&quot;; this.materailFactory = materailFactory; &#125; @Override void prepare() &#123; System.out.println(&quot;准备制作月饼了&quot;); flour = this.materailFactory.createFlour(); sesame = this.materailFactory.createSesame(); &#125;&#125;//肉陷月饼class meat1 extends MoonCake1 &#123; MaterailFactory materailFactory; public meat1() &#123; System.out.println(&quot;肉馅&quot;); &#125; public meat1(MaterailFactory materail) &#123; this.materailFactory = materail; &#125; @Override void prepare() &#123; flour = this.materailFactory.createFlour(); sesame = this.materailFactory.createSesame(); &#125;&#125; 抽象月饼店123456789101112// 月饼店抽象类 public abstract class MoonCakeStore1 &#123; public MoonCake1 orderMoonCake(String type) &#123; MoonCake1 mc; mc = createMoonCake(type); mc.kenad(); mc.prepare(); return mc; &#125; // 抽象的工厂方法 public abstract MoonCake1 createMoonCake(String type);&#125; 材料接口12345// 材料工厂接口public interface MaterailFactory &#123; public flour createFlour(); public sesame createSesame();&#125; 南方材料工厂实现材料接口12345678910111213141516171819202122232425// 南方材料工厂public class SouthMaterailFactory implements MaterailFactory&#123; @Override public flour createFlour() &#123; return new SouthFlour(); &#125; @Override public sesame createSesame() &#123; return new SouthSesame(); &#125;&#125;// 南方面粉class SouthFlour extends flour&#123; public SouthFlour() &#123; System.out.println(&quot;南方的独特制作的面粉&quot;); &#125;&#125;// 南方芝麻class SouthSesame extends sesame&#123; public SouthSesame() &#123; System.out.println(&quot;南方的独特制作的芝麻&quot;); &#125;&#125; 南方月饼店继承抽象月饼店1234567891011121314// 南方月饼店public class SouthMoonCakeStroe1 extends MoonCakeStore1&#123; @Override public MoonCake1 createMoonCake(String type) &#123; MaterailFactory mf = new SouthMaterailFactory(); if (type.equals(&quot;meat&quot;)) &#123; return new sugar1(mf); &#125; else if (type.equals(&quot;sugar&quot;)) &#123; return new meat1(mf); &#125; return null; &#125;&#125; 运行代码12345678910public class run &#123; public static void main(String args[])&#123; MoonCakeStore1 mcs1 = new SouthMoonCakeStroe1(); MoonCake1 mc12 = mcs1.orderMoonCake(&quot;meat&quot;); System.out.println(mc12.getName()); MoonCake1 mc11 = mcs1.orderMoonCake(&quot;meat&quot;); System.out.println(mc11.getName()); &#125;&#125; 运行结果12345揉面粉准备制作月饼了南方的独特制作的面粉南方的独特制作的芝麻糖陷月饼 三、UML类图 四、笔记面向对象原则 多用组合，少用继承 针对接口编程、不针对实现编程 为交互之间的松耦合设计而努力 类应该对扩展开发、修改关闭《开闭原则》 依赖抽象、不要依赖具体类《依赖倒置原则》 工厂方法模式定义 定义了一个创建对象的接口，但由于之类子类要决定要实例化哪一个。工厂方法让类的实例推迟到子类 抽象工厂模式定义 提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 注：抽象工厂模式的代码比较复杂，只是做材料的UML类图 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－装饰者模式]]></title>
    <url>%2F201809014.html</url>
    <content type="text"><![CDATA[之前学习的是观察模式，复习观察者模式 观察者模式一般在那些地方使用：比如我们有两个对象，一个对象依赖于另一个对象的变化而变化，此时我们可以将这两个对象抽象出来，做成接口，利用观察者模式来进行解耦，又或者，当一个对象发生变化的时候，需要通知别的对象来做出改变，但又不知道这样的对象有多少个，此时利用观察者模式非常合适。 使用观察者模式的好处：第一、观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。 第二、观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知， 观察者模式有下面的缺点：第一、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。第二、如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。第三、如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。第四、虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。 一、对装饰者模式的理解可以想象为给房子装修，有英式风格的房子、中式风格的房子，英式风格有英式风格的桌子、椅子，中式风格有中式风格的桌子椅子、等等。但是我们在装修房子的时候会自己去找材料，椅子有不同的风格、不同的厂家等。最后我们用这些不同的材料来装饰自己的房子。我们可以建立一个房子的抽象类，用材料去实现房子的抽象类。中式风格的房子、英式风格的房子都去实现房子的抽象类。之后用桌子、椅子具体的实现去继承材料抽象类。这样就可以用多态（父类的引用指向自类的对象），具体的看下面的代码 二、代码实现创建房子抽象类12345678// 房子抽象类public abstract class House &#123; String description = &quot;毛坯房&quot;; // 房子的描述 public String getDescription() &#123; return this.description; &#125; public abstract double cost(); // 房子的成本成本&#125; 创建材料抽象类、继承房子类1234// 装修材料public abstract class Material extends House&#123; public abstract String getDescription(); // 重写获取房子描述的方法&#125; 中式风格的房子类、中式风格椅子类、中式风格桌子类12345678910111213141516171819202122232425262728293031323334353637// 中式风格的房子public class ChineseStyle extends House&#123; public ChineseStyle() &#123; description = &quot;中式风格的房子&quot;; &#125; @Override public double cost() &#123; return 888; &#125;&#125;// 中式风格的椅子class ChineseChair extends Material&#123; House house; public ChineseChair(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;＊＊＊中式风格的椅子&quot;; &#125; public double cost () &#123; return 20 + house.cost(); &#125;&#125;// 中式风格的桌子class ChineseDesk extends Material&#123; House house; public ChineseDesk(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;***中式风格的桌子&quot;; &#125; public double cost () &#123; return 50 + house.cost(); &#125;&#125; 英式风格的房子、英式风格的桌子、英式风格的椅子1234567891011121314151617181920212223242526272829303132333435// 英式风格public class EnglandStyle extends House&#123; public EnglandStyle() &#123; description = &quot;英式风格的房子&quot;; &#125; @Override public double cost() &#123; return 666; &#125;&#125;class EnglandChair extends Material&#123; House house; public EnglandChair(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;＊＊＊英式风格的椅子&quot;; &#125; public double cost () &#123; return 20 + house.cost(); &#125;&#125;class EnglandDesk extends Material&#123; House house; public EnglandDesk(House house)&#123; this.house = house; &#125; public String getDescription() &#123; return house.getDescription() + &quot;***英式风格的桌子&quot;; &#125; public double cost () &#123; return 50 + house.cost(); &#125;&#125; 代码运行 123456789101112131415161718public static void main(String args[]) &#123; House house = new ChineseStyle(); System.out.println(house.getDescription() + &quot;***&quot; +house.cost()); // 英式风格的房子用 一张中式风格的桌子，和两把椅子，一把中式风格的，一把英式风格的椅子 House house1 = new EnglandStyle(); // 英式风格的房子 house1 = new ChineseDesk(house1); house1 = new ChineseChair(house1); house1 = new EnglandChair(house1); System.out.println(house1.getDescription() + &quot;***&quot; +house1.cost()); // 中式风格的房子用 一张中式风格的桌子，和两把椅子，一把中式风格的，一把英式风格的椅子 House house2 = new ChineseStyle(); // 中式风格的房子 house2 = new ChineseDesk(house2); house2 = new ChineseChair(house2); house2 = new EnglandChair(house2); System.out.println(house2.getDescription() + &quot;***&quot; +house2.cost()); // 后面就可以按照自己的喜欢装修自己的房子了 // 其它的家具也可以更加灵活的添加了 &#125; 运行结果 123中式风格的房子***888.0英式风格的房子***中式风格的桌子＊＊＊中式风格的椅子＊＊＊英式风格的椅子***756.0中式风格的房子***中式风格的桌子＊＊＊中式风格的椅子＊＊＊英式风格的椅子***978.0 三、UML类图 四、笔记面向对象原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为交互对象之间的松耦合设计而努力 对扩展开发、对修改关闭 装饰者模式的定义 动态的将责任附加到对象上。想要扩展功能，装饰折提供有别于继承的另一种选择 java 的 io流就是用装饰者模式实现的 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux+elasticsearch+logstash 自动同步mysql实现搜索引擎]]></title>
    <url>%2F20180909.html</url>
    <content type="text"><![CDATA[一、安装elasticsearch作用：将数据放到elasticsearch进行搜索 1、配置elasticsearch的yum源1234567891011vim /etc/yum.repos.d/elasticsearch.repo // 配置yum源// 在elasticsearch.repo（如果没有就新建） 中加入一下内容6.x版本以上，将6改为2即可变更为2.x版本[elasticsearch-6.x]name=Elasticsearch repository for 6.x packagesbaseurl=https://artifacts.elastic.co/packages/6.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md 2、yum安装1yum -y install elasticsearch 3、启动1service elasticsearch start // 启动命令 Starting elasticsearch (via systemctl): [ 确定 ] // 出现这个表示启动成功 二、安装logstash用于将mysql里面的数据同步到elasticsearch 123wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.1.zip // 下载到目录解压文件cd logstash-6.4.1 // 进入logstash文件夹vim mysql.conf // 新建mysql.conf文件 在mysql.conf文件中配置如下信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647input &#123; stdin &#123; &#125; jdbc &#123; # mysql数据库连接 jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost/basesdataName?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC&quot; # mysqly用户名和密码 jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;password&quot; # 驱动配置(可以自己下载mysql-connector-java-6.0.5.jar，填写路径即可) jdbc_driver_library =&gt; &quot;./lib/mysql-connector-java-6.0.5.jar&quot; # 驱动类名 jdbc_driver_class =&gt; &quot;com.mysql.cj.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; # 执行指定的sql文件 statement_filepath =&gt; &quot;./data.sql&quot; # 设置监听 各字段含义 分 时 天 月 年 ，默认全部为*代表含义：每分钟都更新 schedule =&gt; &quot;* * * * *&quot; # 索引类型 type =&gt; &quot;product&quot; &#125; &#125; filter &#123; json &#123; source =&gt; &quot;message&quot; remove_field =&gt; [&quot;message&quot;] &#125; &#125; output &#123; elasticsearch &#123; #es服务器 hosts =&gt; [&quot;localhost:9200&quot;] #ES索引名称 index =&gt; &quot;sl_product&quot; #自增ID document_id =&gt; &quot;%&#123;id&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125; ｝ 新建data.sql 1234vim data.sql // 新建写入如下内容SELECT * FROM tableName // 查询语句 启动logstash 1bin/logstash -f mysql.conf // 在logstash-6.4.1目录启动，如果其它目录，需要更改路径 三、测试是否安装成功1curl &apos;http://127.0.0.1:9200/_search?pretty&apos; // 出现数据库里面的数据表示成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&#123; &quot;took&quot;: 153, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 15, &quot;successful&quot;: 15, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 6, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;426&quot;, &quot;summary&quot;: null, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.179Z&quot;, &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;2&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;@version&quot;: &quot;1&quot;, &quot;id&quot;: 2, &quot;category_id&quot;: null, &quot;sub_image&quot;: null, &quot;status&quot;: 1, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.437Z&quot;, &#125; &#125;, &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;123&quot;, &quot;summary&quot;: &quot;1&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;sub_image&quot;: &quot;test&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.178Z&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;123&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.436Z&quot;, &quot;type&quot;: &quot;product&quot;, &quot;tag_price&quot;: null &#125; &#125;, &#123; &quot;_index&quot;: &quot;product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;add_time&quot;: &quot;2018-09-22 12:04:14&quot;, &quot;summary&quot;: &quot;&lt;p&gt;123&lt;/p&gt;&lt;audio controls=\&quot;controls\&quot; style=\&quot;display: none;\&quot;&gt;&lt;/audio&gt;&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;status&quot;: 1, &quot;retail_price&quot;: 12, &quot;sub_image&quot;: &quot;test asdf&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T05:41:00.180Z&quot;, &quot;tag_price&quot;: &quot;123&quot; &#125; &#125;, &#123; &quot;_index&quot;: &quot;sl_product&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;version&quot;: 1, &quot;retail_price&quot;: 12, &quot;add_time&quot;: &quot;2018-09-22 12:04:14&quot;, &quot;@version&quot;: &quot;1&quot;, &quot;@timestamp&quot;: &quot;2018-09-26T07:56:00.442Z&quot; &#125; &#125; ] &#125;&#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7安装git服务器]]></title>
    <url>%2F201809015.html</url>
    <content type="text"><![CDATA[linux安装git，并配置仓库1.安装git,查看版本号yum install -y git git --version 2.创建git用户useradd git //创建用户 password git //更改密码 3.初始化git仓库，并改变仓库权限cd /home/git mkdir -p test.git //创建仓库 git init --bare test.git //初始化 chown -R git:git test.git //改变权限 4.克隆仓库到本地git clone git@119.10.15.56:/home/git/test.git 本地git与远程git交互1.本地初始化git，并上传git init //初始化 git add test.txt //增加文件到暂存区 git commit -m &apos;注释&apos; //提交文件到本地仓库 git remote rm origin //删除之前的remote git remote add origin git@119.106.185.58:/home/test.git //添加远程起源 git push origin master //通过origin原点添加master分支到远程git仓库 2.更新git pull origin master //取回origin主机的master分支，与本地当前分支合并 3.常用上传git add -A //将所有的新文件添加到暂存区 git add test.txt //增加文件到暂存区 git commit -m &apos;注释&apos; //提交文件到本地仓库 git commit -a -m &apos;注释&apos; //将所有的文件提交到本地仓库 git push origin master //通过origin原点添加master分支到远程git仓库 常用git命令git status //查看git状态 git remote -v //查看所有原点 git stash // 暂存 git push origin master --force //强制上传，将本地代码覆盖掉远程代码 分支git branch //看看分支 git chechout aaa //切换分支aaa git branck aaa //创建aaa分支 git chechout -b aaa //本地创建 aaa分支，同时切换到aaa分支。只有提交的时候才会在服务端上创建一个分支 git pull origin master //更新指定分支 git branch -vv // 查看分支跟踪的远程分支 git branch -v // 分支信息 git branch --no-merged // 查看尚未合并的工作 git merge iss53 // 将iss53合并到当前分支 更详细的解释 git钩子自动执行更新1.在初始化git仓库里面找到hooks文件夹，并在里面创建钩子文件vim post-receive //用vim创建文件 chmod 755 post-receive // 更改执行权限 2.编辑自动执行脚本#!/bin/sh PATH=/home/fileDir/ //你需要部署的项目路径。注意文件夹的权限问题 cd $PATH unset $(git rev-parse --local-env-vars) //git的hooks里面默认有一些环境变量,导致无论在哪个语句之后执行git命令都会有默认环境路径,直接unset掉默认的环境变量就好 /usr/bin/git pull //更新项目 sudo /home/sh/git_hook.sh //切换到root用户身份执行自己的脚本 注意：该命令需要在/etc/sudoers 大概91行左右的root ... 下面添加：git ALL=(ALL) NOPASSWD:/home/sh/git_hook.sh（添加是需要改变文件的写权限，否则无法添加） ####3.服务器克隆本地git仓库代码 git clone /home/test.git 注意不要通过git clone git@127.0.0.1/home/test.git导出，会出现git pull需要输入密码导致无法自动化部署。爬了很久的坑 暂时需要使用到的命令就这些。以后遇到了在增加]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux+nginx+tomcat的java项目打包war部署]]></title>
    <url>%2F201809016.html</url>
    <content type="text"><![CDATA[环境：linux centos 7 系统、jdk8+tomcat8+nginx-1.12.1+mysql-5.7.16(jdk,tomcat,mysql是通过阿里云的java环境一键部署的，非阿里云的服务器可以自己搭建环境) 1.将java代码进行war打包 eclipse打包 选择路径，点击finish即可 2.将war包移动到tomcat的webapps目录下面通过ftp或者scp可以直接将本地的代码放到linux服务器上面scp命令：scp 文件名 root@地址:/root （scp test.war root@107.1.0.1:/root） 3.启动tomcat会出现地址被占用 可以用命令：netstat -ltunp 。查看所有的端口号使用情况 如果有（tomcat默认使用8080、8009、8005）端口运行；直接用命令：kill -9 端口号 重启4.安装nginx-1.12.1 安装的sh脚本如下 #!/bin/sh yum install pcre-devel -y yum install openssl-devel -y yum install zlib-devel -y wget http://nginx.org/download/nginx-1.12.1.tar.gz tar -zvxf nginx-1.12.1.tar.gz cd nginx-1.12.1 ./configure make make install cd /usr/local/nginx/sbin/ ./nginx -t /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 详情：https://www.jianshu.com/p/73efd33b9da4 配置nginx.conf文件 server_name 自己的域名 location ^~ /自己的项目 { proxy_pass http://localhost:8080; } 5.重启nginx服务器如果使用的上面的脚本安装的可以使用一下方式停止nginx，和启动nginx 停止nginx: /usr/local/nginx/sbin/nginx -s stop 启动nginx: /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf6.开放nginx默认的80端口阿里云服务器可以直接在配置安全组里面配置 之后就可以通过域名访问啦]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－观察者模式]]></title>
    <url>%2F20180906.html</url>
    <content type="text"><![CDATA[之前学习的是策略模式，复习一下之前的策略模式 策略模式一般在哪方面使用“策略”百科中指[计策]。一般是指：1. 可以实现目标的方案集合；2. 根据形势发展而制定的行动方针和斗争方法；3. 有斗争艺术，能注意方式方法。就是用不同的策略解决不同的问题。如出门的方式有自驾、火车、飞机等。选择不同的出行方式就是不同的策略程序中就是对各个算法的封装。让客服端非常方便的可以调用。我理解为就是在一个类中属性有相同的地方。带式行为方法不同，为了以后添加类特别方便，就可以考虑使用策略模式。 使用策略模式有什么好处 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。 策略模式提供了可以替换继承关系的办法。 使用策略模式可以避免使用多重条件转移语句。 一、对观察者模式的理解： 观察者模式可以理解为很多人去观察一个事物。我打个微信公众好的比喻，就像微信的公众号一样，可以经常给用户推送信息（一周可以给每个用户推送4篇文章）。用户可以取消关注，取消之后，公众号就无法给该用户发送消息了。当用户关注该公众号之后，就可以每月接收文章了。观察者模式可以很好的实现这种功能。话不多说，代码实现功能 二、代码实现观察者模式在java中有两种实现，一种是自己实现，还有一种就是java自带的jdk中已经写好了的，我两种都实现 1、自己用代码实现观察者模式创建公众号接口，用于其他公众号实现 public interface OfficialAccounts { public void follow(User user); // 关注公众号 public void unfollow(User user); // 取消关注 public void sendMessageAll(); // 给所有的用户发送消息 } 创建一个新闻的公众号用于实现公众号接口，新增其它公众号，直接实现OfficialAccounts就好了 // 新闻公众号 public class NewsOfficialAccounts implements OfficialAccounts{ private ArrayList users; private String content; public NewsOfficialAccounts () { users = new ArrayList(); } @Override public void follow(User user) { // 关注该公众号 users.add(user); } @Override public void unfollow(User user) { // 取消关注 int i = users.indexOf(user); if(i&gt;=0) { users.remove(i); } } @Override public void sendMessageAll() { // 给所有用户发送文章 for(int i = 0; i&lt;users.size();i++) { User user = (User) users.get(i); user.acceptMessage(content); } } public void setContent(String content){// 设置消息自动给所有用户发送文章 this.content = content; sendMessageAll(); } } 创建用户类接口，用于接受公众号文章 public interface User { public void acceptMessage(String content); // 接收消息 } 创建用户实现用户接口。创建其它用户也只需要实现User接口 // 用户jason public class UserJason implements User{ private String name = &quot;jason&quot;; private String message; private OfficialAccounts os; @Override public void acceptMessage(String content) { System.out.println(name+&quot;接收到了&quot;+content); this.message = content; } public UserJason(OfficialAccounts os) { // 构造器作为关注公众号用 this.os = os; os.follow(this); } public void unfollow(){ // 取消关注 os.unfollow(this); } } // 用户tom public class UserTom implements User{ private String name = &quot;tom&quot;; private String message; private OfficialAccounts os; @Override public void acceptMessage(String content) { System.out.println(name+&quot;接收到了&quot;+content); this.message = content; } public UserTom(OfficialAccounts os) { // 构造器作为关注公众号用 this.os = os; os.follow(this); } } main方法运行 public static void main(String args[]) { // 创建一个新闻的公众号 NewsOfficialAccounts noa = new NewsOfficialAccounts(); // 创建用户 UserTom tom = new UserTom(noa); UserJason jason = new UserJason(noa); // 公众号发送消息 noa.setContent(&quot;新闻消息1&quot;); noa.setContent(&quot;新闻消息2&quot;); jason.unfollow(); // 取消关注，jason无法接收消息3 noa.setContent(&quot;新闻消息3&quot;); } 运行结果：实现类发现消息之后只要所有关注了新闻公众号的用户可以接受消息，没有关注的就没有接收到 jason接收到了新闻消息1 tom接收到了新闻消息2 jason接收到了新闻消息2 tom接收到了新闻消息3 2、用java jdk 自带的Observable、Observer实现创建公众号 public class BankOffcialAccounts extends Observable{ // 实现java自带的可观察者接口 private String content; // 接受的消息 public BankOffcialAccounts(){}; // 构造器 public void changed() { // 消息变化方法 setChanged(); notifyObservers(); // 通知所有观察者 } public void sendMessage(String content) { // 发送消息 this.content = content; changed(); } public String getContent() { return content; } public void setContent(String content) { // 写入公众号内容 this.content = content; } } 创建一个用java自带的观察者用户（同上面的UserJason、UserTom） public class UserJDK implements Observer{ // 实现java自带的观察者 Observable observable; private String name = &quot;jdk&quot;; private String content; @Override public void update(Observable o, Object arg) { if (o instanceof BankOffcialAccounts) { BankOffcialAccounts boa = (BankOffcialAccounts)o; this.content = boa.getContent(); System.out.println(name+&quot;接收到了&quot;+content); } } public UserJDK(Observable o) { this.observable = o; observable.addObserver(this); } } 和之前自己写的观察者模式一起运行 public static void main(String args[]) { // 创建一个新闻的公众号 NewsOfficialAccounts noa = new NewsOfficialAccounts(); // 创建用户 UserTom tom = new UserTom(noa); UserJason jason = new UserJason(noa); BankOffcialAccounts bank = new BankOffcialAccounts(); UserJDK jdk = new UserJDK(bank); // 发送消息 noa.setContent(&quot;新闻消息1&quot;); noa.setContent(&quot;新闻消息2&quot;); jason.unfollow(); // 取消关注，jason无法接收消息3 noa.setContent(&quot;新闻消息3&quot;); bank.sendMessage(&quot;发送消息4&quot;); } 运行结果 tom接收到了新闻消息1 jason接收到了新闻消息1 tom接收到了新闻消息2 jason接收到了新闻消息2 tom接收到了新闻消息3 jdk接收到了发送消息4 需要注意的是Observable是一个类，必须要写一个类基础他。限制类Observable的复用潜力 三、UML类图 Observable、Observer 是java jdk自带的 四、笔记1、面向对象原则 封装变化 多用组合、少用继承 针对接口编程、不针对实现编程 为交互对象之间的松耦合而努力 2、观察模式定义在对象之间定义一对多的依赖、这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次数据库迁移的失败经历]]></title>
    <url>%2F201809013.html</url>
    <content type="text"><![CDATA[sql数据结构 表一表二表三 目标:将表一的数据迁移到表二、表三里面，一分为二。表二里面放产品主体，表三里面放多规格 原因： 由于之前设计表的经验不足，没有考虑到产品多规格的情况，写到快完成的时候，才想到用两张表实现产品的多规格（引以为戒，以后设计表的时候，要多方面考虑）。之前用一张表的时候是用checked字段区分产品是否为多规格的，如果是单规格和多规格的主体，就存1。否则就存多规格主体的ID。最终导致现在上传了2915个产品（包括多规格）。管理很混乱，数据比较多，不可能手工重新传了的。只能做数据迁移。 实现思路有两种办法：一、通过实体类迁移数据。 1.创建originCommodity(表一),commodity（表二），commodityDetail（表三）实体类 2.通过dao获取所有的originCommodity数据（获取所有的数据）。用for循环将originCommodity里面的数据分割为两张表commodity、commodity。并通过dao的inster批量创建commodity、commodityDetail数据（需要写sql批量插入数据） 二、手动navicat软件＋少量sql 将表一里面的数据导入本地的数据库，通过navicat软件手动将不同的字段更改为表二里面的字段，不需要的字段直接删除。之后将数据直接导入到表二，完成迁移。（这是最笨的方法进行迁移。但是迁移的时候需要注意的是ID，表一的是uuid生成的ID，表二是自增ID）。 1.将表一分成两个表，commodity、commodityDetail。 commodity里面全部放checked=1的数据（主体）。commodityDetail里面存checked!=1的数据（多规格）。（创建两个表，复制表一里面的全部数据，将commodity里面的checked!=1的删除，将commodityDetail表里面的checked=1的数据删除，完成创建） 2.增加一个在commodity里面增加一个origin_id(原来的uuid),用来存放之前的ID。将commodity的ID更改为origin_id。id为自增ID 3.更改commodityDetail表里面的checked字段，需要将commodityDetail里面的checked等于commodity表里面的origin_id的数据变为commodity的自增ID。 用方法二处理数据遇到的问题： 由于想要尽快的处理这个问题，我选择了方法二，用最笨的方法处理数据。一路都很顺利的处理完成了。结束之后，我就将原来的commodity删除了。因为要将表里面的数据的ID更改为自增ID，而且开始的时候是新增了自增ID的字段的，之后将原来的uuid字段更改为了origin_id。这样方便其他表关联这张表的时候，可以通过origin_id获取更改之后的ID。但是有一张表我遗漏了，没有将表里面的ID更改，就将这个origin_id删除了。导致现在有一张表无法获取ID。因此，这种方法是一个很笨切不能从用的笨办法，如果用第一种方法，就不会出现这种问题了。还好这次更改的只是测试数据，下次重新用第一种方法试一次 数据库需要用到的命令###一、 将sql数据签出并放到本地： 123mysqldump -hlocalhost -uroot --databases 数据库名 | gzip &gt; /root/DatabaseName_$(date +%Y%m%d_%H%M%S).sql.gzscp root@ip地址:/root/sql文件名 ./Desktop // 将文件复制到本地 失败使人进步，加油。end]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式－策略模式]]></title>
    <url>%2F20181012.html</url>
    <content type="text"><![CDATA[最近在读head frist 的设计模式。之前就了解过这本书的，感觉还不错，于是就在淘宝上购买了一本。书有500多页挺厚的一本，内容都是很容易上手的，当成漫画看就可以了。本着学习的态度，我想认认真真的把设计模式好好学习一下。设计模式很多，一个一个的学，学完一个，我就在这里纪录一下自己的学习成果、自己对设计模式的理解、以及一些笔记、代码就是自己想一个显示生活中的例子模拟实现。 一、对策略模式的理解&emsp;&emsp;关于策略模式，我看完书之后回忆的起来的大概就是建立一个抽象类，抽象除类的不改变的属性，如动物的名字、年龄等这些都是每个动物都有的，不会改变的。 二、代码实现创建一个动物类1234 public abstract class animal &#123; private String name; private int age;｝ 然后多个类继承该抽象类，如小猫、小狗等。 public class Dog extends animal{} 之后就是动物有的会飞、会叫等。这些都是动物的行为。之后把动物的飞行、叫喊接口化。 public interface CallBehavior { // 叫喊行为 public void call(); } public interface FlyBehavior { // 飞行行为 public void fly(); } 会飞、会叫都可以是动物的行为。就可以将会飞、会叫的接口组合在动物类里面，当成动物的属性 public abstract class animal { private String name; private int age; FlyBehavior flyBehavior; // 让所有的动物都继承这个行为 CallBehavior callBehavior; // 添加方法，用于被继承的动物共用方法 public void performFly() { // 执行飞行 flyBehavior.fly(); } public void performCall() { // 执行叫喊 callBehavior.call(); } public void setFlyBehavior(FlyBehavior fly){ // 动态的设置飞行的实现类，可以在运行时改变动物的飞行方式 this.flyBehavior = fly; } public void setCallBehavior(CallBehavior call){ this.callBehavior = call; } ｝ 之后就用不同的实现类实现会飞、会叫的接口 // 叫喊接口实现 public class CallBig implements CallBehavior{ @Override public void call() { System.out.println(&quot;特别大声的叫&quot;); } } public class CallNoWay implements CallBehavior{ @Override public void call() { System.out.println(&quot;不会叫&quot;); } } // 飞行接口实现 public class FlyNoWay implements FlyBehavior{ @Override public void fly() { System.out.println(&quot;不会飞行&quot;); } } public class FlyWithWings implements FlyBehavior{ @Override public void fly() { System.out.println(&quot;我要飞的更高&quot;); } } 然后就可以给小狗类添加默认的构造器。 public class Dog extends animal{ public Dog() { // 小狗的构造器 callBehavior = new CallBig(); // 大声叫callBehavior 使用的是父类的变量 flyBehavior = new FlyNoWay(); } } 调用 public static void main(String args[]) { animal dw = new DogModle(); dw.performFly(); // 默认飞行 dw.performCall(); // 默认叫喊 dw.setFlyBehavior(new FlyWithWings()); //动态绑定飞行行为 dw.performFly(); // 更改之后的飞行方式 } 执行结果 不会飞行 特别大声的叫 我要飞的更高 这样就动态实现了数据的绑定，根据不同的策略，绑定不同的接口。动态的完成功能，后期添加其他动物，也不需要更改之前的代码。完全做到了，对新增开放、对修改闭合的开闭原则。 三、UML类图画的不正规的uml图 四、笔记1、学到的三个原则 将会变动的代码进行封装 针对接口编程，不针对实现编程 多用组合、少用继承 ####2、策略模式定义 定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户 github源码：https://github.com/gaoqisen/java-pattern]]></content>
      <categories>
        <category>patterm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现redis缓存功能]]></title>
    <url>%2F201809019.html</url>
    <content type="text"><![CDATA[一、安装redis1.mac安装，如果有安装brew 可以直接快捷安装：brew install redis 2.linux下载安装wget http://download.redis.io/releases/redis-2.8.17.tar.gz tar xzf redis-2.8.17.tar.gz cd redis-2.8.17 make 二、redis常用命令redis-cli // 进入命令行 /usr/local/bin/redis-server /usr/local/etc/redis.conf // 启动 找到你的redis-server、redis-server路径 quit // 退出 keys * // 查询所有的key set a 123 //创建字符串key（a）, value(123) get a // 查看字符串key为a的value del a //删除字符串key为a的数据 hmset key name &quot;a&quot; description &quot;123&quot; // hashmap的创建 hgetall a //hashmap通过key获取 lpush a 123 // list创建 lrange a 0 10 //list 获取 sadd a 123 // 集合set创建 smembers a // 集合set 获取 zadd a 123 // 有序集合set创建 zrange a 1 10 smembers // 集合set 获取 注：初期使用的命令，后期遇到之后在进行添加 三、spring boot集成redis1.项目基于spring boot创建的，eclipse 集成spring boot 后，可以选择redis，之后自动生成如下代码（pom.xml）:&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.配置redis，在application.propertise 的文件里面添加如下：spring.redis.database=0 spring.redis.host=localhost spring.redis.port=6379 // 端口号 spring.redis.password=redispass // 密码 spring.redis.pool.max-active=8 spring.redis.pool.max-wait=-1 spring.redis.pool.max-idle=8 spring.redis.pool.min-idle=0 spring.redis.timeout=5000 // 链接超时时间，可以设置大一些 3.创建一个service接口（redisService）：@Service public class RedisService { @Autowired private StringRedisTemplate redisTemplate; /** * 一周有多少秒 */ private static final long WEEK_SECONDS = 7 * 24 * 60 * 60; /** * 将 key，value 存放到redis数据库中，默认设置过期时间为一周 * @param key * @param value */ public void set(String key, Object value) { redisTemplate.opsForValue().set(key, JsonUtil.convertObj2String(value), WEEK_SECONDS, TimeUnit.SECONDS); } /** * 将 key，value 存放到redis数据库中，设置过期时间单位是秒 * * @param key * @param value * @param expireTime */ public void set(String key, Object value, long expireTime) { redisTemplate.opsForValue().set(key, JsonUtil.convertObj2String(value), expireTime, TimeUnit.SECONDS); } /** * 判断 key 是否在 redis 数据库中 * * @param key * @return */ public boolean exists(final String key) { return redisTemplate.hasKey(key); } /** * 获取与 key 对应的对象 * @param key * @param clazz 目标对象类型 * @param &lt;T&gt; * @return */ public &lt;T&gt; T get(String key, Class&lt;T&gt; clazz) { String s = get(key); if (s == null) { return null; } return JsonUtil.convertString2Obj(s, clazz); } /** * 获取 key 对应的字符串 * @param key * @return */ public String get(String key) { return redisTemplate.opsForValue().get(key); } /** * 删除 key 对应的 value * @param key */ public void delete(String key) { redisTemplate.delete(key); } } 4.在PifajiaOfficialApplicationTests里面进行测试@Test public void redisService(){ String str = &quot;test&quot;; String retStr = this.redisService.get(&quot;test&quot;); if(retStr == null) { this.redisService.set(&quot;test&quot;, str); retStr = str; } System.out.println(&quot;:::&quot;+retStr); } end]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用自定义注解进行切面，@Autowired装配的service一直报错空指针]]></title>
    <url>%2F201809012.html</url>
    <content type="text"><![CDATA[切面的方法是public就可以了]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Autowired</tag>
      </tags>
  </entry>
</search>
