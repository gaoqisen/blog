<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Learning Record</title>
  
  <subtitle>Welcome to Gao Qisen&#39;s blog.</subtitle>
  <link href="https://gaoqisen.github.io/atom.xml" rel="self"/>
  
  <link href="https://gaoqisen.github.io/"/>
  <updated>2021-07-10T05:55:05.043Z</updated>
  <id>https://gaoqisen.github.io/</id>
  
  <author>
    <name>Gao Qisen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的一些alfred工具</title>
    <link href="https://gaoqisen.github.io/tool/alfred.html"/>
    <id>https://gaoqisen.github.io/tool/alfred.html</id>
    <published>2021-07-10T12:10:11.000Z</published>
    <updated>2021-07-10T05:55:05.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><h2 id="二、用github制作的一个图床"><a href="#二、用github制作的一个图床" class="headerlink" title="二、用github制作的一个图床"></a>二、用github制作的一个图床</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt</span><span class="params">(text)</span>:</span></span><br><span class="line">        file = open(<span class="string">'github_image_path.txt'</span>,<span class="string">'w+'</span>)</span><br><span class="line">        file.write(text)</span><br><span class="line">        file.close()</span><br><span class="line">        os.system(<span class="string">'open github_image_path.txt'</span>)</span><br><span class="line">        os.system(<span class="string">'say "ok"'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create file</span></span><br><span class="line">dir=time.strftime(<span class="string">"%Y%m"</span>, time.localtime())</span><br><span class="line">fileName=dir+<span class="string">'/'</span>+time.strftime(<span class="string">"%Y%m%d%H%M%S"</span>, time.localtime())+<span class="string">'.png'</span></span><br><span class="line">path=<span class="string">'/Users/gaoqisen/Documents/blog/image/GraphBed/'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path+dir):</span><br><span class="line">        os.makedirs(path+dir)</span><br><span class="line"><span class="comment"># screencapture</span></span><br><span class="line">upload=os.system(<span class="string">'screencapture -i '</span>+path+fileName)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(upload==<span class="number">0</span>):</span><br><span class="line">        adds=os.system(<span class="string">'cd '</span>+path+<span class="string">' ; git add .'</span>)</span><br><span class="line">        commits=os.system(<span class="string">'cd '</span>+path+<span class="string">' ; git commit -m "'</span>+fileName+<span class="string">' add"'</span>)</span><br><span class="line">        pushs=os.system(<span class="string">'cd '</span>+path+<span class="string">' ; git pull origin master ; git push origin master'</span>)</span><br><span class="line">        str=<span class="string">'https://gaoqisen.github.io/GraphBed/'</span>+fileName</span><br><span class="line">        <span class="keyword">if</span> (adds+commits+pushs != <span class="number">0</span>):</span><br><span class="line">                os.system(<span class="string">'say "no"'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                txt(str)</span><br></pre></td></tr></table></figure><h2 id="三、Hexo推送"><a href="#三、Hexo推送" class="headerlink" title="三、Hexo推送"></a>三、Hexo推送</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/local/opt/coreutils/libexec/gnubin:/Library/Frameworks/Python.framework/Versions/3.5/bin:/Users/gaoqisen/HyperledgerFabricSamples/fabric-samples/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/gaoqisen/Downloads/apache-maven-3.5.2/bin:/usr/local/opt/go/bin</span><br><span class="line">cd /Users/gaoqisen/Documents/blog</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个特别实用的工具。</summary>
    
    
    
    <category term="tool" scheme="https://gaoqisen.github.io/categories/tool/"/>
    
    
    <category term="alfred" scheme="https://gaoqisen.github.io/tags/alfred/"/>
    
  </entry>
  
  <entry>
    <title>《学会提问》(尼尔.布朗)</title>
    <link href="https://gaoqisen.github.io/book/CriticalThinking.html"/>
    <id>https://gaoqisen.github.io/book/CriticalThinking.html</id>
    <published>2021-07-10T04:10:11.000Z</published>
    <updated>2021-07-18T13:45:22.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章、学会提出好问题"><a href="#第一章、学会提出好问题" class="headerlink" title="第一章、学会提出好问题"></a>第一章、学会提出好问题</h2><h3 id="1-1-一切从批判性思维开始"><a href="#1-1-一切从批判性思维开始" class="headerlink" title="1.1 一切从批判性思维开始"></a>1.1 一切从批判性思维开始</h3><p>现在是信息爆炸的时代，每个人都拥有手机，手机每天都可以看到各种各样的信息。作为有思想的人看到各种信息需要做出选择，一种就是全盘接受，久而久之就习以为常，会把别人的观点当成自己的观点，但是没有人愿意做别人的思维奴隶。另外一种就是就是提出有力的问题以便对自己看到的信息做出评判从而形成自己的观点。</p><h3 id="1-2-激发你的批判性思维"><a href="#1-2-激发你的批判性思维" class="headerlink" title="1.2 激发你的批判性思维"></a>1.2 激发你的批判性思维</h3><p>经常提出问题成为了自己的身份标记和存在宣言就是理想的状态。批判性思维涵盖了以下几个方面：</p><ol><li>有一套环环相扣的关键问题的意识</li><li>恰如其分的提出和回答关键问题的能力</li><li>积极主动的利用关键问题的强烈愿望</li></ol><p>关键问题的提出有有助于提升我们的书面和口头的表达能力，以下几个情形：</p><ol><li>客观评价图书，不盲从盲信</li><li>评判一场演讲的水平高低</li><li>提出自己观点并进行论证</li><li>通读指定文章后写有理有据的论文</li><li>积极参与各种讨论</li></ol><h3 id="1-3-两种思维方式：海绵式思维和淘金式思维"><a href="#1-3-两种思维方式：海绵式思维和淘金式思维" class="headerlink" title="1.3 两种思维方式：海绵式思维和淘金式思维"></a>1.3 两种思维方式：海绵式思维和淘金式思维</h3><p>海绵式思维，吸收外界的知识越多，就能体会到世界的千头万绪，从而为以后展开复杂思考打基础，这种思维是被动的，不需要绞尽脑汁去想，因此来的轻松有快捷。但是这种方法会导致自己无法取舍这些观点，读者会对自己最新读到的一切深信不疑。</p><p>淘金式思维，带着一定的态度去读书，带着问题去读书。这种思维需要有积极主动和书对话，虽然作者不在场。淘金式思维的读者会质疑作者为什么提出各种各样的主张，并在书页旁边写批注，提醒自己注意作者的推理中存在的问题。他会无时无刻和阅读材料进行互动</p><p>淘金式思维清单如下：</p><ol><li>别人让我相信他的观点，我有没有问为什么</li><li>在觉得别人说的问题的时候，有没有记录下来</li><li>我有没有客观的评价别人说的观点</li><li>在被人的合理说法上我有没有形成自己的结论</li></ol><h3 id="1-4-淘金式思维举例：美国该禁枪吗？"><a href="#1-4-淘金式思维举例：美国该禁枪吗？" class="headerlink" title="1.4 淘金式思维举例：美国该禁枪吗？"></a>1.4 淘金式思维举例：美国该禁枪吗？</h3><p>通过淘金式的提问得出结论：淘金式思维的特点就是参与和互动。<strong>批判性的提问是检索信息和搜寻答案的最好方法</strong></p><h3 id="1-5-正确答案莫非只是神话"><a href="#1-5-正确答案莫非只是神话" class="headerlink" title="1.5 正确答案莫非只是神话"></a>1.5 正确答案莫非只是神话</h3><p>很多问题都是没有正确答案的，只有目前为止最好的答案，指不定那天就有更好的答案。对于和我们意见不一致的人我们要洗耳恭听他们的观点，可能他观点才是对的。</p><h3 id="1-6-最好先问一问关我什么事"><a href="#1-6-最好先问一问关我什么事" class="headerlink" title="1.6 最好先问一问关我什么事"></a>1.6 最好先问一问关我什么事</h3><p>有一些问题是完全没有意义的，这种问题完全可以不必理会</p><h3 id="1-7-弱势批判性思维和强势批判性思维"><a href="#1-7-弱势批判性思维和强势批判性思维" class="headerlink" title="1.7 弱势批判性思维和强势批判性思维"></a>1.7 弱势批判性思维和强势批判性思维</h3><p>弱势批判性思维，是为了赢而去使用批判性思维的一种方式，目的是为了抵制和驳倒与你意见不同的观点</p><p>强势批判性思维，要求我们用一视同仁的态度去质疑一切主张包括自己</p><p>当我们思想开放的时候，我们就欢迎一切针对自己现有看法的批评，而当我们思想封闭的时候我们就会维护自己现有的观点绝不动摇</p><h3 id="1-8-亲自动手才更有乐趣"><a href="#1-8-亲自动手才更有乐趣" class="headerlink" title="1.8 亲自动手才更有乐趣"></a>1.8 亲自动手才更有乐趣</h3><p>亲自动手的乐趣要远远大于袖手旁观，而圆满完成任务的乐趣又远远大于浅尝辄止。在新的证据出现之前，如果一个观点符合制定的标准，同意这个标准是一个很好的选择。</p><h3 id="1-9-也许我们根本就问错了问题"><a href="#1-9-也许我们根本就问错了问题" class="headerlink" title="1.9 也许我们根本就问错了问题"></a>1.9 也许我们根本就问错了问题</h3><p>不要一有问题就马上提出来，可能自己稍微想一下就能解决这个问题。也可能有更好的提问方式</p><ol><li>论题和结论是什么</li><li>理由是什么</li><li>哪些词语意思不明确</li><li>什么是价值观假设和描述性假设</li><li>推理过程中有没有谬误</li><li>证据的效力如何</li><li>有没有替代原因</li><li>数据有没有欺骗性</li><li>有什么重要信息被省略了</li><li>能得出哪些合理的结论</li></ol><h3 id="1-10-价值观决定人与人之间的互动"><a href="#1-10-价值观决定人与人之间的互动" class="headerlink" title="1.10 价值观决定人与人之间的互动"></a>1.10 价值观决定人与人之间的互动</h3><p>价值观: 指人们觉得较有价值而没有说明的观点，它们树立了一定的行为准则，用这些来衡量人类行为的品质高下</p><p>每个人都有自己的一套价值观，可能你认为对的在别人那里就是错误的。我们常见的做法就是只愿意听取价值观和我们相似的人的观点，这种做法很不好，需要与这种倾向做斗争</p><p>一个有批判性思维人的主要目标是寻求更好的结论，更好的看法，做出更好的决定。批判性思维做主要的价值观：</p><ol><li>主见性，在和我们价值取向不同的人挑中某个好的选择</li><li>好奇心，你需要对遇到的一切不断提问</li><li>谦恭有礼，“我唯一所知的就是我一无所知”，世界上最聪明的人每周都要犯下一堆错误</li><li>以理服人者逢之必敬，有理有据时做事信心百倍，下结论时候不可犹豫，但也需要留有余地，三思而行</li></ol><h3 id="1-11-理智思考和感情用事"><a href="#1-11-理智思考和感情用事" class="headerlink" title="1.11 理智思考和感情用事"></a>1.11 理智思考和感情用事</h3><p>如果一个你的结论被推翻了，不要一直执迷不悟，如果感情用事一直去捍卫它，那是得不偿失的。<strong>接受还是拒绝一个立场，感情上的依恋绝不该成为最重要的基础</strong></p><h3 id="1-12-让对话一直进行下去"><a href="#1-12-让对话一直进行下去" class="headerlink" title="1.12 让对话一直进行下去"></a>1.12 让对话一直进行下去</h3><p>当你的结论被质疑时，要客观的进行自我评估，有分歧是一件很正常的事情。当遇到这种情况的时候，需要要别人明白你好学上进，让他们相信你本意是好的，不要口诛笔伐而收场。如果出现分歧无法继续可以用以下策略：</p><ol><li>委婉说“我好像听你说过这个”</li><li>问一下被人，有没有证据能让他改变他的观点</li><li>可以暂停一会儿，双方都可以找到最佳证据</li><li>可能双方的理由可以结合</li><li>寻找共同或者一致同意的找出分歧产生的原点</li><li>好奇心再强也需要不温不火</li><li>确保自己的表情和肢体都是谦恭的样子</li></ol><p>营造一个好的氛围是很重要的</p><h3 id="1-13-一厢情愿是批判性思维最大的劲敌"><a href="#1-13-一厢情愿是批判性思维最大的劲敌" class="headerlink" title="1.13 一厢情愿是批判性思维最大的劲敌"></a>1.13 一厢情愿是批判性思维最大的劲敌</h3><p>不要认为一件事是对的然后就认定他是对的。可能那只是你的一厢情愿罢了。这种时候可能已经有了能证明对的概率，而你却对他退避三舍。剧情总是会不停的反转，而我们也需要有用一颗明净的心去对待，努力越来越好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">总结:</span><br><span class="line">利用批判性思维形成自己的观点</span><br><span class="line">经常提问是拥有批判性思维的标志</span><br><span class="line">淘金式思维的重要性</span><br><span class="line">可能没有正确的答案，只有最好的答案</span><br><span class="line">无意义的话题不必理会</span><br><span class="line">用批判性思维去质疑一切，而不是为了打倒别人</span><br><span class="line">亲自动手，实践才是最好的办法</span><br><span class="line">不要一有问题就马上提，需要先思考一下</span><br><span class="line">有主见、有好奇心、谦卑有礼、以理服人是批判性思维的价值观</span><br><span class="line">不要为了自己输了而感情用事，要用理智去战胜它</span><br><span class="line">营造好的氛围，让对话不要因为口诛笔伐而收场</span><br><span class="line">不要一厢情愿的认为一件事情是对的，要以理服人</span><br></pre></td></tr></table></figure><h2 id="第二章、论题和结论是什么"><a href="#第二章、论题和结论是什么" class="headerlink" title="第二章、论题和结论是什么"></a>第二章、论题和结论是什么</h2><p>论题就是引起对话或者讨论的问题，结论就是最终讨论的结果</p><h3 id="2-1-“是什么”问题和“应不应该”问题"><a href="#2-1-“是什么”问题和“应不应该”问题" class="headerlink" title="2.1 “是什么”问题和“应不应该”问题"></a>2.1 “是什么”问题和“应不应该”问题</h3><p>是什么就是描述性问题，是对过去、现在或未来的各种描述的精确与否提出的问题</p><p>应不应该就是规定性问题，是指对什么该做什么不该做，什么是对什么是错，什么是好什么是坏</p><h3 id="2-2-他到底在说什么啊"><a href="#2-2-他到底在说什么啊" class="headerlink" title="2.2 他到底在说什么啊"></a>2.2 他到底在说什么啊</h3><p>找出他说的结论，就能对他说的话进行客观性的评论。所谓结论一般都是他希望你接受的信息</p><h3 id="2-3-他想让我相信什么结论"><a href="#2-3-他想让我相信什么结论" class="headerlink" title="2.3 他想让我相信什么结论"></a>2.3 他想让我相信什么结论</h3><p>在寻找结论的过程中，往往都会有很多理由让你去相信结论（证明结论的理由）。之后就可以将结论作为评论的重点，看支撑这个结论的理由我该不该接受</p><h3 id="2-4-找到结论有线索可循"><a href="#2-4-找到结论有线索可循" class="headerlink" title="2.4 找到结论有线索可循"></a>2.4 找到结论有线索可循</h3><ol><li>问问论题是什么</li><li>寻找指示词（因此、表面、由此可知、证明、告诉我们、重点是）</li><li>有可能的位置查看一下（文章的开头和结尾）</li><li>不可能作为结论（例句、数据、定义、背景资料、证据）</li><li>检查交流语境和作者背景</li><li>问一问“所有呢？”</li></ol><h3 id="2-5-轮到自己写时，可得吸取教训"><a href="#2-5-轮到自己写时，可得吸取教训" class="headerlink" title="2.5 轮到自己写时，可得吸取教训"></a>2.5 轮到自己写时，可得吸取教训</h3><p>建议自己写的时候要下功夫把自己的意思写的明明白白，清清楚楚。不要给出一个模糊的概念</p><ol><li>写作之前将论题的范围缩小。先将自己的思绪整理出来</li><li>引导读者得出你的结论，结论和理由应该一目了然。把结论说出来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">搞清楚描述性问题和规定性问题有助于客观评价</span><br><span class="line">找出对方说的结论</span><br><span class="line">找出结论是有线索的</span><br><span class="line">自己写的时候要尽量把范围缩小把结论和理由写清楚</span><br></pre></td></tr></table></figure><h2 id="第三章、理由是什么"><a href="#第三章、理由是什么" class="headerlink" title="第三章、理由是什么"></a>第三章、理由是什么</h2><p>只有找到支撑结论的理由才能判定一个结论的价值。火急火燎的推进批判性思维没有意义，先花一些时间去找到论证所在。一个人是否有头脑，主要标志是看他是否有提供充足的证据来支撑他的看法。</p><h3 id="3-1-他为什么相信这个观点"><a href="#3-1-他为什么相信这个观点" class="headerlink" title="3.1 他为什么相信这个观点"></a>3.1 他为什么相信这个观点</h3><p>用质疑的态度去接触每一个论证，需要问的第一个问题就是为什么，如果回答不了这个问题那么这个称述就不是理由。</p><h3 id="3-2-找出理由的提示词"><a href="#3-2-找出理由的提示词" class="headerlink" title="3.2 找出理由的提示词"></a>3.2 找出理由的提示词</h3><p>甲之所以成立是因为乙。 提示词: 由于、因为这个原因、因为这个事实、鉴于、由以下材料支撑、因为证据是、研究显示、第一第二…</p><h3 id="3-3-理由是模具，结论据此成型"><a href="#3-3-理由是模具，结论据此成型" class="headerlink" title="3.3 理由是模具，结论据此成型"></a>3.3 理由是模具，结论据此成型</h3><p>结论本身不是证据，它是一个由证据或其他看法支撑起来的看法</p><p>让理由和结论一目了然，当评价的时候一定的要让理由和结论一目了然，如下是找到文章中的理由和线索方式：</p><ol><li>圈出指示词</li><li>标记理由和结论</li><li>给理由和结论排序</li><li>文章结尾处顺序列出理由</li></ol><p>使用这个关键问题，结论是否能站住脚取决于理由是否扎实</p><p>先有理由，后有结论</p><h3 id="3-4-轮到自己写时，可得吸取教训"><a href="#3-4-轮到自己写时，可得吸取教训" class="headerlink" title="3.4 轮到自己写时，可得吸取教训"></a>3.4 轮到自己写时，可得吸取教训</h3><p>在作出结论前要探究可能存在的种种理由，多想一下有没有其他的理由可以支撑起这个论点，如果之前已经有过相关的整理，也需要想一下有没有其他的可能。如果一点都不了解的话，就需要通过各种方式先对论题需要的只是进行学习</p><p>找到涵盖你的论题的主要刊物，基本上所有人们感兴趣的领域都有主要的出版刊物，刊物可以作为较好的理由</p><p>帮助读者确定你的目标，他们需要清楚的了解你的结论是什么，你为什么得出这样的结论。可以给出内容梗概，或一开始就介绍你的理由</p><blockquote><p>尽量用自己的话复述理由，用自己的话复述理由有助于说清楚他们的含义和作用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">对观点提出为什么，如果回答不出则不是理由</span><br><span class="line">理由的提示词</span><br><span class="line">先有理由，再有结论</span><br><span class="line">作结论时多想想其他理由</span><br></pre></td></tr></table></figure><h2 id="第四章、哪些词语意思不明确"><a href="#第四章、哪些词语意思不明确" class="headerlink" title="第四章、哪些词语意思不明确"></a>第四章、哪些词语意思不明确</h2><p>只有把握住词语的准确含义，才能对一个论证进行评论</p><h3 id="4-1-让人琢磨不透的多义词"><a href="#4-1-让人琢磨不透的多义词" class="headerlink" title="4.1 让人琢磨不透的多义词"></a>4.1 让人琢磨不透的多义词</h3><p>一个词语会出现不同的理解，一个有歧义的词语常常需要澄清。在读书或听讲的时候需要去强迫自己寻找这种词语，这种词语会让你抓不住要领，需要更近一步的理解才能判断推理过程十分恰当</p><h3 id="4-2-找寻关键词"><a href="#4-2-找寻关键词" class="headerlink" title="4.2 找寻关键词"></a>4.2 找寻关键词</h3><p>不只有一个理由可以解释的通的词语，判断词语是否模糊不清</p><ol><li>检查论题</li><li>检查理由和结论</li><li>留意抽象词</li><li>通过反串方式</li></ol><h3 id="4-3-检查有没有歧义"><a href="#4-3-检查有没有歧义" class="headerlink" title="4.3 检查有没有歧义"></a>4.3 检查有没有歧义</h3><p>找到自己关注的词语，问一问自己是否完全知道他的意思。需要克服两个障碍，一个就是自以为和作者两个意思，另一个就是认为术语指存在一个意思</p><h3 id="4-4-判定歧义"><a href="#4-4-判定歧义" class="headerlink" title="4.4 判定歧义"></a>4.4 判定歧义</h3><p>建议可以通过词语在脑海中确定画面，如果无法明确的确定画面，或者有多种不同的画面，就说明找到了一个重要的歧义。如果你没有明白作者的词语是什么意思就贸然接受了，那你就是根本不理解你同意和接受的是什么。</p><h3 id="4-5-看看上下文，这才是正真的含义"><a href="#4-5-看看上下文，这才是正真的含义" class="headerlink" title="4.5 看看上下文，这才是正真的含义"></a>4.5 看看上下文，这才是正真的含义</h3><p>通过词语的上下文去理解其意思，如果意思还是难以确认，那么这里就是一个有歧义的地方了。如果词语很清楚，但是你不认同，那就需要警惕这个术语的任何一个推理认证</p><h3 id="4-6-字典里的定义不一定适合文章里的情景"><a href="#4-6-字典里的定义不一定适合文章里的情景" class="headerlink" title="4.6 字典里的定义不一定适合文章里的情景"></a>4.6 字典里的定义不一定适合文章里的情景</h3><p>一个词的意义表现通常有三种方式，同义词替换、举例说明、具体的一个标准定义。通常一个具体的标准定义都是有多重含义的，有时并不能在字典里面找到合适的定义。</p><h3 id="4-7-小心那些带有感情色彩的词语，它会让你的脑袋短路"><a href="#4-7-小心那些带有感情色彩的词语，它会让你的脑袋短路" class="headerlink" title="4.7 小心那些带有感情色彩的词语，它会让你的脑袋短路"></a>4.7 小心那些带有感情色彩的词语，它会让你的脑袋短路</h3><p>有很多的词语都是具有感情色彩的，比如改革/期望的改变，恢复/同意征税提案。这种词语是刻意用来淡化人们对其指代对象的淡化。</p><h3 id="4-8-谁想要说服你，谁就要负责解释清楚"><a href="#4-8-谁想要说服你，谁就要负责解释清楚" class="headerlink" title="4.8 谁想要说服你，谁就要负责解释清楚"></a>4.8 谁想要说服你，谁就要负责解释清楚</h3><p>一个说客想要把理由讲的特别清楚才能给听众消除各种歧义。如果他不能提供一个清晰有力的论证画面，那么不要相信他。有一个保单的协议是为“每一桩事故”提供最高保单35亿美元的保险条款，被保方认为是针对个人的保单，结果发生了灾难去世很多人，结果保险公司认为所有人的去世都是一桩特大的事故。</p><h3 id="4-9-轮到自己写时，可得吸取教训"><a href="#4-9-轮到自己写时，可得吸取教训" class="headerlink" title="4.9 轮到自己写时，可得吸取教训"></a>4.9 轮到自己写时，可得吸取教训</h3><p>一个词语对于不同的人，可能就有不同理解，这种词语就是一个有歧义的词语。这种情况我们就需要把这个词语解释清楚，要确保读者拥有一样的结论和理由。比如有钱人的就是一个有感情色彩的词语，有的人认为拥有稳定的工作的人就是有钱人，而有的人认为资产超过100w的人才是有钱人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">总结:</span><br><span class="line">多义词一般都是有歧义的</span><br><span class="line">通过检查论题、理由和结论、留意抽象词语、通过反串方式的可以找到歧义词</span><br><span class="line">判断词语是否存在歧义</span><br><span class="line">通过看上下文寻找歧义词语</span><br><span class="line">不能忽视字段里面的定义词语</span><br><span class="line">重视有感情色彩的词语</span><br><span class="line">自己写的时候一定要把有歧义的词语解释清楚</span><br></pre></td></tr></table></figure><h2 id="第五章、什么是价值观假设和描述性假设"><a href="#第五章、什么是价值观假设和描述性假设" class="headerlink" title="第五章、什么是价值观假设和描述性假设"></a>第五章、什么是价值观假设和描述性假设</h2><h3 id="5-1-到哪儿去找假设"><a href="#5-1-到哪儿去找假设" class="headerlink" title="5.1 到哪儿去找假设"></a>5.1 到哪儿去找假设</h3><h2 id="第六章、推理过程中有没有谬误"><a href="#第六章、推理过程中有没有谬误" class="headerlink" title="第六章、推理过程中有没有谬误"></a>第六章、推理过程中有没有谬误</h2><h2 id="第七章、证据效力如何：直觉、个人经历、典型案例、当事人证词和专家意见"><a href="#第七章、证据效力如何：直觉、个人经历、典型案例、当事人证词和专家意见" class="headerlink" title="第七章、证据效力如何：直觉、个人经历、典型案例、当事人证词和专家意见"></a>第七章、证据效力如何：直觉、个人经历、典型案例、当事人证词和专家意见</h2><h2 id="第八章、证据的效力如何：个人观察、研究报告和类比"><a href="#第八章、证据的效力如何：个人观察、研究报告和类比" class="headerlink" title="第八章、证据的效力如何：个人观察、研究报告和类比"></a>第八章、证据的效力如何：个人观察、研究报告和类比</h2><h2 id="第九章、有没有替代原因"><a href="#第九章、有没有替代原因" class="headerlink" title="第九章、有没有替代原因"></a>第九章、有没有替代原因</h2><h2 id="第十章、数据有没有欺骗性"><a href="#第十章、数据有没有欺骗性" class="headerlink" title="第十章、数据有没有欺骗性"></a>第十章、数据有没有欺骗性</h2><h2 id="第十一章、有什么重要信息被省略了"><a href="#第十一章、有什么重要信息被省略了" class="headerlink" title="第十一章、有什么重要信息被省略了"></a>第十一章、有什么重要信息被省略了</h2><h2 id="第十二章、等得出哪些合理的结论"><a href="#第十二章、等得出哪些合理的结论" class="headerlink" title="第十二章、等得出哪些合理的结论"></a>第十二章、等得出哪些合理的结论</h2>]]></content>
    
    
    <summary type="html">尼尔.布朗写的这本是批判性思维的学习方法，看了一点点就感觉学到了好多，这本书记得多多看几遍</summary>
    
    
    
    <category term="提问" scheme="https://gaoqisen.github.io/categories/提问/"/>
    
    
    <category term="book" scheme="https://gaoqisen.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>《学会提问》(韩根太)</title>
    <link href="https://gaoqisen.github.io/book/LearnQuestion.html"/>
    <id>https://gaoqisen.github.io/book/LearnQuestion.html</id>
    <published>2021-07-10T04:10:11.000Z</published>
    <updated>2021-07-11T06:03:04.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>画了下思维导图</p></blockquote><p><img src="https://gaoqisen.github.io/GraphBed/202107/20210710220359.png" alt="https://gaoqisen.github.io/GraphBed/202107/20210710220359.png"></p><h2 id="一、自我赋能"><a href="#一、自我赋能" class="headerlink" title="一、自我赋能"></a>一、自我赋能</h2><h3 id="1-1-能客观的看待自己吗？"><a href="#1-1-能客观的看待自己吗？" class="headerlink" title="1.1 能客观的看待自己吗？"></a>1.1 能客观的看待自己吗？</h3><p>幸福不是别人给的，需要自己去寻找。作者用故事说明了客观的了解自己是一件很重要的事情，但是想要了解自己是一件非常难的事情，所以能充分的了解自己就是一件很必要的事情。并给出了一些审视自己的问题，我自己给自己回答一下</p><ol><li>你觉得自己是一个什么样的人?<ul><li>我觉得我是一个不善言辞、木纳、怯场、不懂人情世故的人</li></ul></li><li>你认为这样的根据是什么？<ul><li>在工作中唯唯诺诺，不是自己的问题缺像是自己的问题一样，经常缺乏沟通导致频繁返工。生活中的朋友寥寥无几，朋友之间的话题也特别少。家人的沟通除了日常再无话题</li></ul></li><li>你现在的样子是你真正需要的吗？<ul><li>不是</li></ul></li><li>你从周围人中经常听到的评价是什么？<ul><li>老实人</li></ul></li><li>你身边有跟你说逆耳忠言的人吗？如果有，他们都说了什么？<ul><li>有！ 按时吃饭、按时睡觉、不要多想</li></ul></li><li>如果有一个可以摧毁你的致命缺点，你认为是什么<ul><li>怯场</li></ul></li><li>如果你要改正那个致命缺点，你认为需要怎么做？<ul><li>我认为要勇于发表自己的看法，多和同事沟通，尝试公开演讲（打死不敢）</li></ul></li><li>你害怕什么？<ul><li>我担心自己说的不好其他人觉得我是一个没用的人。不会说话的时候最容易说错话，说错话之后给别人造成不必要负担。有时有担心打扰到别人</li></ul></li><li>你所期望的未来的自己是怎样的？<ul><li>希望未来是一个不怯场，能在公共场合侃侃而谈的人。（光明磊落）</li></ul></li><li>如果要改变自己，你希望如何改变？<ul><li>先多和别人沟通，问一下别人的看法。给出几个建议，然后自己勇于尝试。制定计划和目标，然后逐步完成，不然又只是摘抄了一次。</li></ul></li></ol><h3 id="1-2-我真的渴望改变吗？"><a href="#1-2-我真的渴望改变吗？" class="headerlink" title="1.2 我真的渴望改变吗？"></a>1.2 我真的渴望改变吗？</h3><p>变化的三大核心要义：渴望、承受痛苦、新的习惯。为了得到自己渴望的变化，需要承受相应的痛苦才能养成新的习惯。这本书用了一个减肥的例子去描述，如果要减肥必须要对瘦下来的渴望非常强才有动力进行减肥，在减肥的过程中要承受运动和忌食的痛苦并且养成习惯之后才能减肥成功缺一不可。如果三天晒网两天打鱼那肯定是不行的。并给出为了改变必须提出的问题:</p><ol><li>我真的渴望改变吗？<ul><li>很渴望改变（内心深处想要得过且过）</li></ul></li><li>我能承受痛苦吗？<ul><li>能，就算失眠也不怕</li></ul></li><li>我能养成新的生活习惯吗？<ul><li>不确定，不知道自己能不能有一个好的计划并且按照计划执行 下去，已经有好多计划都没有执行了，对自己很失望</li></ul></li></ol><p>实现改变的问题：</p><ol><li>你现在想改变吗？<ul><li>想</li></ul></li><li>你有迫切改变的动机吗<ul><li>有，改变之后工作能回更强</li></ul></li><li>你想改变什么？<ul><li>怯场</li></ul></li><li>为了改变你需要付出怎样的代价？<ul><li>需要面对尴尬、需要打扰别人、需要不在乎他人的看法、需要直面自己的懦弱</li></ul></li><li>现在是改变的最佳时机吗？<ul><li>是（一直想要改变，但是一直不知道怎么做）</li></ul></li><li>不管是自身还是周围，预计在改变的过程中会有怎样的阻碍<ul><li>最大的阻碍就是拖延症和害怕</li></ul></li><li>通过改变能得到什么？<ul><li>能得到别人的认可，自己也会生活的更开心幸福</li></ul></li><li>如果改变失败，你会失去什么？<ul><li>什么都不会失去，最多就是当天给别人留下不好的印象（时间久了可能自己都不会记得这个事情了）。</li></ul></li><li>有谁可以帮助你改变？<ul><li>朋友</li></ul></li><li>为了改变，你要做的第一件事情是什么？<ul><li>把这篇笔记发给朋友，请朋友监督我</li></ul></li></ol><h3 id="1-3-你有目标吗？"><a href="#1-3-你有目标吗？" class="headerlink" title="1.3 你有目标吗？"></a>1.3 你有目标吗？</h3><p>自己的目标就像是导航的目的地一样，只有设定好了目的地，才能用更好更快的路径抵达。如果没有目标就会经常迷茫不知所措。目标是最好的激励手段，有了目标你就会一骨碌爬起来坐到书桌前，目标使人成长。</p><ol><li>你有制定目标并取得相应成就的经历吗？<ul><li>有</li></ul></li><li>如果到现在都没有实现过目标的话，你认为最根本的原因是什么？<ul><li>目标不是迫切需要的、拖延症</li></ul></li><li>要克服失败，你最先需要做什么？<ul><li>克服拖延症、拒绝玩手机</li></ul></li><li>现在你的目标是什么？<ul><li>改变怯场</li></ul></li><li>想要实现这个目标，你认为这次需要做出那些改变？<ul><li>工作的过程中多分析，多总结，并发出自己的看法。在沟通的过程中，不是自己的问题要学会拒绝。在公开场合说话时先事前准备</li></ul></li><li>你认为好的目标是什么？<ul><li>好的目标能让自己成长，能让身边的人快乐</li></ul></li><li>你认为现在的目标在人生中起到什么重要的作用？<ul><li>这个缺点从小就伴随我一起长大，它根生蒂固的影响着我，从小时候的不积极发言到现在从未改变过。这个目标是我目前为止最最的，它能改变我的一生</li></ul></li><li>如果不是以现在，而是以整个人生为基准，你最终的目标是什么？<ul><li>最终目标是拥有一个幸福美满的家庭</li></ul></li></ol><h3 id="1-4-你现在被束缚在哪里？"><a href="#1-4-你现在被束缚在哪里？" class="headerlink" title="1.4 你现在被束缚在哪里？"></a>1.4 你现在被束缚在哪里？</h3><p>大概的意思是讲不要被自己束缚，一个哥白尼的故事，开始的时候一直一地球为中心去推理星系但是一直都不对。之后换了一种方式以太阳为中心推理后一切都利理所当然（日心说的开始）。这个例子告诉我们要从多个角度去看待问题可能有不一样的收获</p><h3 id="1-5-站在未来，向现在的自己提问"><a href="#1-5-站在未来，向现在的自己提问" class="headerlink" title="1.5 站在未来，向现在的自己提问"></a>1.5 站在未来，向现在的自己提问</h3><p>人生有很多个决定，读书还是工作，运动还是玩手机，看书还是玩手机，结婚还是过几年再说等等问题。遇到这种问题的时候就可以想象一下自己已经年迈80了，在这个时候如果给现在的自己做决定的话会选择什么？这样可能就有一种新的选择，产生新的故事</p><h3 id="1-6-提出问题比回答问题更难"><a href="#1-6-提出问题比回答问题更难" class="headerlink" title="1.6 提出问题比回答问题更难"></a>1.6 提出问题比回答问题更难</h3><p>书籍中说大多数情况下问一个人“你有什么问题吗？”，通常得到的回答就是“没有问题？”， 那么这种情况下提出问题就显得很重要了。如果是在问了很多个问题被一一解答之后那倒是没什么问题，就怕一直什么问题都没有，然后一问什么都不知道，针对后者就需要多提问，提出问题之后就会有相应的解决问题方案。在解决的过程中自己也会学到很多东西，总比什么都不问要好太多</p><h3 id="1-7-质疑是理所当然的"><a href="#1-7-质疑是理所当然的" class="headerlink" title="1.7 质疑是理所当然的"></a>1.7 质疑是理所当然的</h3><p>去质疑各种事情，夫妻之间吵架是正常的吗为什么不可以不吵架。别人认为理所当然的事情就是对的吗？我们有相反的意见去反驳吗？反驳的观点靠谱吗？只有对任何事情都抱有怀疑的态度去审视，不盲目的相信就可能有新的收获</p><h3 id="1-8-提问要有知识储备"><a href="#1-8-提问要有知识储备" class="headerlink" title="1.8 提问要有知识储备"></a>1.8 提问要有知识储备</h3><p><strong>如果一无所知，当然就不会有问题</strong>，只有有了一定了解之后才会有相应的问题，问题解决之后就理解了问题，理解之后就可以有自己看法去质疑问题，然后有新的收获。因此在瞬息万变的时代就需要我们不断的获取新的知识，多看书，多了解，主动探索已知和未知的事情</p><h3 id="1-9-我经常提的问题"><a href="#1-9-我经常提的问题" class="headerlink" title="1.9 我经常提的问题"></a>1.9 我经常提的问题</h3><p>你说的什么意思呢？我没听懂！能再说一遍吗？</p><ul><li>为了减少沟通成本，不理解对方意思的时候一定要再次询问</li></ul><p>核心是什么？</p><ul><li>对方说了一大堆不明确的话，可以问清楚最主要讲的是什么意思</li></ul><p>如果是我，我怎么做？</p><ul><li>想一下自己怎么做之后，就很容易理解对方</li></ul><p>得与失是什么？</p><ul><li>塞翁失马焉知非福，想一下得与失之后有利于提供提问的素材</li></ul><p>真正重要的是什么？为什么要做这件事情？</p><ul><li>理清楚正真重要的东西后才能搞清楚怎么做才是最理想的情况，也能搞清楚为什么做这件事情</li></ul><h3 id="1-20-重新定义问题"><a href="#1-20-重新定义问题" class="headerlink" title="1.20 重新定义问题"></a>1.20 重新定义问题</h3><p>经常会出现问题定义不清楚导致和他人产生沟通的情况，这种情况我觉得就需要重新问题问题，把问题的描述定义清楚之后沟通起来就会顺畅很多</p><h2 id="二、拉近关系"><a href="#二、拉近关系" class="headerlink" title="二、拉近关系"></a>二、拉近关系</h2><h3 id="2-1-提问是沟通的桥梁"><a href="#2-1-提问是沟通的桥梁" class="headerlink" title="2.1 提问是沟通的桥梁"></a>2.1 提问是沟通的桥梁</h3><p>人与人之间都有一扇铁门，在大多数情况下，人们都不会自己先打开这扇门。而打开这扇门的最佳方法就是打招呼、搭话以及提出相关的问题。家人之间的沟通、朋友之间的沟通、工作上的沟通都是这种情况。多提一些问题然后一起解决问题这是一个很好的办法。作者描述了他和出租车司机的一段经历，作者只不过是想出租车司机提出了一个“这个音乐真好听，您是做过音乐方面的工作吗？”，之后就能和出租车司机沟通</p><h4 id="2-2-提问是最好的社交手段"><a href="#2-2-提问是最好的社交手段" class="headerlink" title="2.2 提问是最好的社交手段"></a>2.2 提问是最好的社交手段</h4><p>如果通过别人认识到一个陌生人，你知道怎么不会得罪他吗？就是不问任何问题，对他视而不见，那对方会多尴尬。但是提出问题之后可能就会有其他意想不到的收获。作者也描述了好几个都是讲通过提出问题后获得好的回响的经历</p><h3 id="2-3-用问题打开话题，转交对话主导权"><a href="#2-3-用问题打开话题，转交对话主导权" class="headerlink" title="2.3 用问题打开话题，转交对话主导权"></a>2.3 用问题打开话题，转交对话主导权</h3><p>想要做到擅长闲聊，需要注意以下三点：提出好的问题、学会倾听、做出积极反应。作者给的故事是他向一位出书的大企业退休高官提出了一个问题“出一本书并不容易，您为什么要写这本书呢？”。之后就是这位高管的回答，期间只需要做到倾听并做出积极反应即可。和对方第一次见面时，最好避开生硬的话题，不要直奔主题，应对谈有关对方的事（与其自己淘淘不绝，不如对让对方说话）</p><h3 id="2-4-好的问题让人产生好感"><a href="#2-4-好的问题让人产生好感" class="headerlink" title="2.4 好的问题让人产生好感"></a>2.4 好的问题让人产生好感</h3><p>好的问题就是与见面对象有关的问题，就是他所感兴趣的或者他擅长的领域，尽量避免谈论他不喜欢的、负面的以及政治方面的话题。好的问题会持续产生新的问题，在问答过程中，双发会变得更加亲近，这才是最大的快乐和收获。</p><h3 id="2-5-解决对话障碍的提问"><a href="#2-5-解决对话障碍的提问" class="headerlink" title="2.5 解决对话障碍的提问"></a>2.5 解决对话障碍的提问</h3><p>没有提问的对话不是对话，只不过是单方面的见解。如果对方没有话语空间，则无法提出问题。也就是需要给对方留出提问的空间，对方才能反向提问。作者认为最佳的留出空间的方式就是提问，先自己给自己提问产生话语空间，之后在给对方提问。<strong>只有产生“我的想法是错的，可以从对方身上学到些什么，我想理解的更多”</strong>等想法时，给对方留有话语空间，对方才能提问</p><h3 id="2-6-换位思考"><a href="#2-6-换位思考" class="headerlink" title="2.6 换位思考"></a>2.6 换位思考</h3><p>书中举例了一个叙利亚的事情，一个记者提出了“美国要攻打叙利亚，如果我是叙利亚人民，我会怎么想？叙利亚要如何避免美国的攻击”。 大多数人都是站在自己的立场上进行的思考，在需要问题的时候不妨站在对方的角度去思考一下问题，可能想法会发生改变</p><h3 id="2-7-把问题准备好"><a href="#2-7-把问题准备好" class="headerlink" title="2.7 把问题准备好"></a>2.7 把问题准备好</h3><p>见面是一切从相遇的开始，不管是新的机会，还是人生领悟，或者赚钱都是通过人与人之间的交往实现的，因此见面需要高度重视，让见面变得有价值。为了做到这一点，最好的办法就是见面之前多了解对方，然后准备好问题。</p><h3 id="2-8-精心准备的提问提升对话格调"><a href="#2-8-精心准备的提问提升对话格调" class="headerlink" title="2.8 精心准备的提问提升对话格调"></a>2.8 精心准备的提问提升对话格调</h3><p>有空的时候可以想一下如果自己就见到了自己最崇拜的人，会提出什么问题？可以把这个问题提给其他的人，就可以更加深入的了解他人。尤其是记者采访的时候，只有经过精心准备的提问才是一个好的访谈。不要觉得刻意准备就是不好的事情（有的人觉得刻意之后就不是正真的自己了），刻意准备才能突出朋友的重要性。不刻意才是忽略朋友</p><h3 id="2-9-提问是关心和关系的纽带"><a href="#2-9-提问是关心和关系的纽带" class="headerlink" title="2.9 提问是关心和关系的纽带"></a>2.9 提问是关心和关系的纽带</h3><p>关系是什么呢？作者通过繁体字关系解释为“只有打开门闩进入，关系才能开始”。在他人打开我的心门进入之前，首先得我敞开心门，如果我把心门关闭着，那么关系就结束了。人际关系的出发点就是关心对方，关系他人是最好的社交手段。而关心和关系的纽带就是提问。当关心他人，对他人产生兴趣的时候，你就会产生疑问，产生疑问之后就可以提问了。若不关心，则不会产生好奇。之后作者提出了提升兴趣的提问:</p><ul><li>最近对哪一个话题最感兴趣？</li><li>为了满足自己的好奇心，你做过那些事</li><li>以前关心过，但是现在感觉索然无味的话题是什么</li><li>有没有长久不变的话题领域</li><li>最近比较关注的领域是什么</li><li>你现在身边的人最关心的是什么</li><li>你和身边的人关注的领域相似吗</li><li>然后更有效的利用自己的兴趣</li></ul><h3 id="2-10-提问的搭档“倾听”"><a href="#2-10-提问的搭档“倾听”" class="headerlink" title="2.10 提问的搭档“倾听”"></a>2.10 提问的搭档“倾听”</h3><p>万物皆成双成对，男/女，昼/夜，车轮等，提问和倾听就是一对。有倾听才有收获、只有倾听才能赢得人心、只有主动洗耳恭听对方才能娓娓道来。只有学会倾听才能在适当的时候提出问题，这样才能让对话更活跃。</p><h2 id="三、优化工作能力"><a href="#三、优化工作能力" class="headerlink" title="三、优化工作能力"></a>三、优化工作能力</h2><h3 id="3-1-提问可以为你导航"><a href="#3-1-提问可以为你导航" class="headerlink" title="3.1 提问可以为你导航"></a>3.1 提问可以为你导航</h3><p>思想转化行动，行动转变为习惯，习惯成就个人。人生始于思考，基于兴趣，一个人思考什么就会提出什么问题，关注什么就会造就其人生。书中说如果你经常关注优秀员工的，经常思考优秀员工的种种，然后你自己就会慢慢发生改变，之后就成为了优秀员工</p><h3 id="3-2-找出有意义的提问"><a href="#3-2-找出有意义的提问" class="headerlink" title="3.2 找出有意义的提问"></a>3.2 找出有意义的提问</h3><p>有意义的人生一定是每个人都希望的。书中的例子就是一个老母亲一直老年痴呆，之后她的儿子发生了意外需要他人照顾，由于情况特殊则只有老母亲才能去照顾。之后老母亲的的老年痴呆也好了，因为她的生活被赋予了意义。如果生活有意义，那么他可以承受一切。如果没有意义，那么任何事情都无法忍受。那提问题也是一样的道理，没有意义的问题则不如不提</p><h3 id="3-3-自我发展阶段-知、识、见、解"><a href="#3-3-自我发展阶段-知、识、见、解" class="headerlink" title="3.3 自我发展阶段: 知、识、见、解"></a>3.3 自我发展阶段: 知、识、见、解</h3><p>“知”就是知道的意思，“道”就是说出来，那么知道的意思就是了解之后可以说出来，如果说不出来那么就等于不知道</p><p>“识”就是写作的意思写作可以锻炼自己的思想，观点等，也可以把他传递给他人。写文章是需要先胸有成竹之后，在有欲吐之言，并需要把思绪和想法整理清楚而去自己头脑中的概念明确之后才写的出来</p><p>“见”就是你意见的意思，一个没有主见的的人就会盲目的听从他人的想法，或者把从某处了解的一知半解的知识认为是真理，而去不接受其他任何好的意见。意见不会凭空产生，它是学习的产物，见识和眼界越多，意见就会越多。</p><p>“解”就是解决问题的能力，通过学习就算是遇到复杂的问题也能镇定自若。随着知识的不断增长，就会掌握不同的解决办法，在面对问题的时候就会不慌不忙</p><p>《1948》里面描述的世界里面不能思考，不能表达，不能写日记。这样人就容易变成傻瓜，傻瓜容易被控制</p><h3 id="3-4-不会提问的四个原因"><a href="#3-4-不会提问的四个原因" class="headerlink" title="3.4 不会提问的四个原因"></a>3.4 不会提问的四个原因</h3><p>第一个就是长时间不提问就养成了习惯，对于这个问题最好的办法就是遇到好奇的问题就不断提问去激活“提问肌肉”。</p><p>第二个就是害怕提问之后被认为是无知的人，不懂就问会让人进步，而不懂不问就会一直无知下去。即使出错被误解也依然要不断提问</p><p>第三个就是因为非常不理解，如果真的是一点都不了解那就需要自己补充相关的知识了。</p><p>第四个就是自以为非常了解，偶尔问问自己知道什么，不知道什么不知道一定不要装作知道，那样就没办法进步一直持续下去多半会变成无知的人</p><h3 id="3-5-向自己提问"><a href="#3-5-向自己提问" class="headerlink" title="3.5 向自己提问"></a>3.5 向自己提问</h3><p>讨厌某事和想要得到某物时截然不同的两件事，讨厌不会带来改变，也无法让人得到想要的东西。我们应该把重心放到想要得到的事物上，不要被讨厌的事情左右思想。不会提问就意味着不知道自想要什么，不知道自己想要什么就可能会把重心放在讨厌的事物上。那样就无法让人成长。记得要把重心放在想要得到的事物上</p><h3 id="3-6-精简提问"><a href="#3-6-精简提问" class="headerlink" title="3.6 精简提问"></a>3.6 精简提问</h3><p>如果一句话就能表达的事情，为什么需要写那些冗长的文字。文字越多就越容易让人不清楚文字的意义。提问的时候就需要自己先想清楚提出的问题是否可以精简，精简之后的文字是否更能表达清楚问题的本质。读书越多，阅读理解的能力就会越强，词汇量就会越来越丰富，不知不觉就会理清楚想法。</p><h3 id="3-7-得失的两面性"><a href="#3-7-得失的两面性" class="headerlink" title="3.7 得失的两面性"></a>3.7 得失的两面性</h3><p>塞翁失马焉知非福，每件事的都有两面性，得到什么的就会失去什么，同时失去什么也会相应的得到什么。在遇到事情的时候就要思考一下另一面，那样你的视角就会有不一样的转变</p><h3 id="3-8-用领导者的角度来提问"><a href="#3-8-用领导者的角度来提问" class="headerlink" title="3.8 用领导者的角度来提问"></a>3.8 用领导者的角度来提问</h3><p>领导拥有思考和质疑的能力，想要把事情做好我觉得比较好的方法就是质疑它然后完善，一直持续这种方法直到事情变为当前最完美的状态。再就是主动学习的能力，在学习的过程中就会有各种各样的问题，有了问题就会有相应的思考，之后就需想相应的解决办法。了解本质、懂得轻重缓急、能够客观的看待未来和现在的自己在这个过程中最重要的就是思考的质疑的能力</p><h3 id="3-9-为什么不尽力"><a href="#3-9-为什么不尽力" class="headerlink" title="3.9 为什么不尽力"></a>3.9 为什么不尽力</h3><p>时常可以问自己为什么不尽力，这样可以了解现状并做出相应的调整。塑料在燃烧的时候会产生刺鼻的味道，但是燃烧干净之后就会变的干净。如果不尽力就会有各种各样的问题，然后让自己和他人都难受。如果尽力后就了无遗憾，也会变得非常干净。最好的生活就是，就算生活只有一年可活现在的生活也是最好的</p><h3 id="3-10-耀眼的失败胜过平凡的成功"><a href="#3-10-耀眼的失败胜过平凡的成功" class="headerlink" title="3.10 耀眼的失败胜过平凡的成功"></a>3.10 耀眼的失败胜过平凡的成功</h3><p>失败的经验是非常宝贵的，如果不想重蹈覆辙就要吸取其中的教训。失败后就会努力学习，比如考试如果考通过之可能就不会在拿起之前的书本看了，但是没有考通过的话就会一直复习下去，可能最后学到的知识比一次性考过的知识要多很多。下面是一些从失败中汲取智慧的问题</p><ul><li>最近那件事情遭遇了失败</li><li>觉得这件事情最大的原因是什么</li><li>如果没失败现在会是什么情况</li><li>因为失败获得了什么好处</li><li>经历过失败的其他人怎么克服这些失败的</li><li>目前为止里经历过最大的失败是什么</li><li>那次失败让你产生了那些变化</li><li>那次失败之后你做了那些努力</li><li>那次失败之后你领悟了那些教训</li><li>你朋友失败了你想给他什么建议</li><li>人生就是在失败和成功中交替进行的，为了应对下一次失败你想说些什么</li></ul><h2 id="四、增强领导力的提问"><a href="#四、增强领导力的提问" class="headerlink" title="四、增强领导力的提问"></a>四、增强领导力的提问</h2><h3 id="4-1-用问题打动对方"><a href="#4-1-用问题打动对方" class="headerlink" title="4.1 用问题打动对方"></a>4.1 用问题打动对方</h3><p>领导不可能知道所有问题的答案，可用问题调动员工的参与度，让他们开动脑筋。比如美国的“本福尔德号”的一位军官就想军官提问“你们有哪些不满意的地方，如果你得到了授权，你想怎么整改”。通过这个问题以及后续的整改让这个海军战舰变成了所有军官最想待的战舰。</p><h3 id="4-2-领导因该如何提问"><a href="#4-2-领导因该如何提问" class="headerlink" title="4.2 领导因该如何提问"></a>4.2 领导因该如何提问</h3><p><strong>发展前景不是公司给予的，而是自己需要在工作中寻找的。</strong> 书中举例了一个提问的故事，说以前有个领导总是给员工下达指令分派任务其他的就不管不顾只是最终看成果，但是新的领导上任之后就问员工工作了多久、在相关行业是不是韩国最棒的人，在全世界是不是最棒的，如果满分是100分你给自己打多少分，那么明年的今天你打算提升多少分？这种提问的方式能让员工自己思考，不是别人逼去完成事情的，这样两种不同的情况就会产生完全不同的效果</p><h3 id="4-3-提问的三个前提"><a href="#4-3-提问的三个前提" class="headerlink" title="4.3 提问的三个前提"></a>4.3 提问的三个前提</h3><p>第一是谦虚，要知道自己的不足，在不能把握情况之前，毫不犹疑的说“不知道”才是好的领导</p><p>第二是尊重他人，只有尊重他人，他人才会真心实意的回答问题，嘲笑他人是不会提出任何问题的</p><p>第三是自我训练，只有经过自我训练的人才能提出好的问题。自高自大、信口开河的人是不会提出好的问题的</p><h3 id="4-4-提高工作效率的首要原则"><a href="#4-4-提高工作效率的首要原则" class="headerlink" title="4.4 提高工作效率的首要原则"></a>4.4 提高工作效率的首要原则</h3><p>父母或者老师等权威的人士总会习惯性的强求他人做某事，结果就是难以持续。没有人会在被强迫后改变自己的想法或者态度。强迫他人做某事是最简单、最方便、最经济的方法，并且这样只需要发泄自己情绪而不考虑别人的意见。比起单方面的意见或者主张，提问会更好。</p><h3 id="4-5-团队中的个人心理安全感"><a href="#4-5-团队中的个人心理安全感" class="headerlink" title="4.5 团队中的个人心理安全感"></a>4.5 团队中的个人心理安全感</h3><p>人通常不会轻易提问的，甚至不想回答问题。当人们觉得不会回答问题就是最安全的时候，就没有人在开口。因此营造出自由交流的氛围就是最重要的心理条件，让员工能放下心理包袱，不看任何人的眼色，能发表自己的看法。这样才是最重要的</p><h3 id="4-6-工作的本质是什么"><a href="#4-6-工作的本质是什么" class="headerlink" title="4.6 工作的本质是什么"></a>4.6 工作的本质是什么</h3><p>忙碌的生活容易使我们主客颠倒，忘记事物的本质，而把时间花在细枝末节的事上。这样就会让工作变得一盘散沙，故需要经常回顾事情的本质是什么</p><h3 id="4-7-没有反省的领导没有未来"><a href="#4-7-没有反省的领导没有未来" class="headerlink" title="4.7 没有反省的领导没有未来"></a>4.7 没有反省的领导没有未来</h3><p>自我反省需要独处，需要冥想的同时冷静的审查自己，需要站在第三者的角度看待自我。最好的反省是在顺风顺水的时候也进行反省就会越来越好，最不好的反省就是在遇到挫折的时候还不进行反省。自我反省的问题</p><ul><li>努力后没有取得成功的事是什么，原因是什么</li><li>没有怎么努力确得到意想不到成果的事情是什么，你觉得为什么</li><li>如果发展顺利｜遭遇困难，你预计持续多久，什么原因</li><li>自己哪方面做得好，哪方面需要改善</li><li>为了实现自我发展，需要怎么做？优先级？</li><li>为了实现目标，自身需要什么力量</li></ul><h3 id="4-8-提高面试质量的问题"><a href="#4-8-提高面试质量的问题" class="headerlink" title="4.8 提高面试质量的问题"></a>4.8 提高面试质量的问题</h3><p>最好不要问可以预测到标准答案的问题，也不要问从书本上或网上容易了解的问题，这是在浪费时间。可以通过提问对公司了解多少，用一些体系化的问题去问？有没有做过网上营销等</p><h3 id="4-9-提问是最佳激励工具"><a href="#4-9-提问是最佳激励工具" class="headerlink" title="4.9 提问是最佳激励工具"></a>4.9 提问是最佳激励工具</h3><p>当被询问自己的意见的时候，通常人们的心情都是最好的。提问是打通交流通道最有效的方式，提问可以激励员工，交流彼此想法，让公司充满活力</p><h3 id="4-10-回应提问的四项原则"><a href="#4-10-回应提问的四项原则" class="headerlink" title="4.10 回应提问的四项原则"></a>4.10 回应提问的四项原则</h3><p>第一，提问之人的用意，有可能提问的人不会将意图明确出来。最好问一下提问人的意图</p><p>第二，没有必要对所有问题都做回答，有些人只是习惯性的提问为了表现自己，并不是为了好奇提问。这种问题完全可以不予理会。</p><p>第三，如果问题不明确的的时候，可以通过反问来抓住明确的含义。</p><p>第四，提问超出范围，这种时候最好的办法就是明确的拒绝，我们无法回答所有的问题，当不知道的时候一定要明确说不知道</p><h3 id="4-11-通过提问限制条件"><a href="#4-11-通过提问限制条件" class="headerlink" title="4.11 通过提问限制条件"></a>4.11 通过提问限制条件</h3><p>每个人都有自己的限制，个人和公司不可能都是万事俱备的的，但是很多都是在有很多限制的条件下还是很好的完成了事情。为了提高效率，我们需要提出一些限制办事的条件比如：</p><p>第一、提出限制时间的条件，给出无限的时间可能不会打造一个无懈可击的产品，反而可能给力无限的时间导致工作效率下降，如果给出了时间限制可能效果会好很多</p><p>第二、提出限制空间条件的限制，长篇大论和脱离带水的问题都不是受人喜欢的，比如一个会议如果限制在10分钟之内可能会精简很多的冗余事情</p><p>第三、提出减少费用的条件，创新常常是在提出某些无理要求的情况下发生的</p><h3 id="4-12-转换视角的问题"><a href="#4-12-转换视角的问题" class="headerlink" title="4.12 转换视角的问题"></a>4.12 转换视角的问题</h3><p>有三种提问可以让我们用陌生的眼光审视熟悉的概率</p><p>第一种、提问事物的共同点，这样可能会有新的见解</p><p>第二种、提问事物的反义词，比如爱的反义词是什么呢？一般大家都回答是“很”，其实不是，“爱”的反义词是“漠不关心”。</p><p>提问的目的之一就是明确概念。在互相提问的过程中，曾经模糊的想法会变的更加清晰。</p>]]></content>
    
    
    <summary type="html">不会说话的我，在努力尝试学习沟通。看到一本学会提问的书，看了一遍之后一点映像都没有，记录一下每节的内容，加深一下印象。网上说《学会提问》是一本批判性思维的书，然后在图书馆借了这边，看完之后发现这本是同名，尼尔.布朗写的那本才是想看的那本。这本的提问技巧也学习一下吧!</summary>
    
    
    
    <category term="提问" scheme="https://gaoqisen.github.io/categories/提问/"/>
    
    
    <category term="book" scheme="https://gaoqisen.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>练吧</title>
    <link href="https://gaoqisen.github.io/study/train.html"/>
    <id>https://gaoqisen.github.io/study/train.html</id>
    <published>2021-06-27T13:03:40.000Z</published>
    <updated>2021-07-04T06:58:44.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、源起"><a href="#一、源起" class="headerlink" title="一、源起"></a>一、源起</h2><p>想要有一个能监督自己成长的工具类app。大致是制定目标 &gt; 当天完成情况 &gt; 亲朋好友评价(监督) &gt; 完善 &gt; 第二天完成情况 &gt; 评价 … 目标完成 &gt; 查看历史记录(时间线，版本迭代)</p><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><h3 id="1-1-制定目标"><a href="#1-1-制定目标" class="headerlink" title="1.1 制定目标"></a>1.1 制定目标</h3><ol><li><p>周期（单位：年、月、日、时）：默认第一天练习、第一天晚上考核、第二天完善</p></li><li><p>实践: 练习 &gt; 考核 &gt; 完善 然后循环实践直到完成</p><ul><li>练习: 练习项，如写文章（标题、内容、目标ID）等</li><li>考核: 目标ID、考核情况、考核级别</li><li>完善: 目标ID、是否完成、完成说明</li></ul></li><li><p>完成后奖励</p></li></ol><h3 id="1-2-练习项"><a href="#1-2-练习项" class="headerlink" title="1.2 练习项"></a>1.2 练习项</h3><ol><li>演讲：名称、内容（PPT）、时长、录音</li><li>文章：名称、内容</li><li>练字：名称用日期展示、内容就是练字的图片</li></ol><h3 id="1-3-完成进度"><a href="#1-3-完成进度" class="headerlink" title="1.3 完成进度"></a>1.3 完成进度</h3><ol><li>展示目标完成进度百分比</li><li>查看历史完成时间轴</li></ol><h3 id="1-4-公开池"><a href="#1-4-公开池" class="headerlink" title="1.4 公开池"></a>1.4 公开池</h3><p>有2个考核级别为A的则发布到公共区域</p><h2 id="三、领域建模"><a href="#三、领域建模" class="headerlink" title="三、领域建模"></a>三、领域建模</h2><h2 id="四、核心业务逻辑"><a href="#四、核心业务逻辑" class="headerlink" title="四、核心业务逻辑"></a>四、核心业务逻辑</h2><h2 id="五、技术细节"><a href="#五、技术细节" class="headerlink" title="五、技术细节"></a>五、技术细节</h2><p>监督自己: 自己的作品发给家人进行检查，家人给出改正意见，改正后朝着最好的方向发展。</p><p>闹钟定时提示后的选择项目: 已完成、马上开始、今天有事明天吧!</p>]]></content>
    
    
    <summary type="html">一直没有搞清楚DDD的精髓，今天看书的时候看到一句话“如果有自己看不懂的事情，那就多看几遍，之后多半就懂了”。于是让自己用这个小项目练练手吧！</summary>
    
    
    
    <category term="study" scheme="https://gaoqisen.github.io/categories/study/"/>
    
    
    <category term="study" scheme="https://gaoqisen.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>《代码精进之路》</title>
    <link href="https://gaoqisen.github.io/book/CodeDiligenceWay.html"/>
    <id>https://gaoqisen.github.io/book/CodeDiligenceWay.html</id>
    <published>2021-06-26T02:10:11.000Z</published>
    <updated>2021-07-04T03:47:43.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-技艺"><a href="#一-技艺" class="headerlink" title="一 技艺"></a>一 技艺</h2><h3 id="1-1-命名"><a href="#1-1-命名" class="headerlink" title="1.1 命名"></a>1.1 命名</h3><ol><li><p>命名的力量：就像企业名称一样，一个好的名字能给人留下一个深刻的映像</p></li><li><p>命名很难：一个好的名字需要把要义浓缩到一两个词语中</p></li><li><p>有意义的命名：好的命名代码即注释</p><ul><li>变量名：能正确描述业务的名词，不要用缩略单词</li><li>函数名：要具体。要体现做什么，而不是怎么做。</li><li>类名：实体类要体现业务语义，并在团队内达成共识。辅助类通过实体名加后缀，尽量不要用Helper、Util这种太笼统的后缀</li><li>包名：一组有关系的类的集合，不要太抽象也不要太具体</li><li>模块名：相对于包来说粒度更大，一个模块中包含了多个包</li></ul></li><li><p>保持一致，一旦选中就要持续遵循，可以提高代码的可读性，从而简化复杂度</p><ul><li><p>每个概念一个词如：create新增，add添加，remove删除，update修改，get获取单个结果，list获取多个结果，page分页查询，count统计</p></li><li><p>使用对仗词：add/remove, increment/decrement, open/close, begin/end, insert/delete, show/hide, create/destroy, lock/unlock, source/target, first/last, min/max, start/stop, get/set, next/previous, up/down, old/new</p></li><li><p>后置限定词：用类似Total, Sum, Average, Max, Min, Count这样的词作为后置限定</p></li><li><p>统一业务语言：统一业务语言之后和前端、测试、开发、业务沟通起来就会顺畅很多</p></li><li><p>统一技术语言：DO, DAT, DTO, ServiceI, ServiceImpl, Component, Repository设置通用的技术语言之后，开发人员都能一眼明白</p></li></ul></li><li><p>白明的代码：好的代码是最好的文档，在不借助注释的情况下，代码本身就能向读者清晰的传达自身的含义</p><ul><li>中间变量：用有意义的变量名命名中间变量，可以把隐藏的计算过程明白的表达出来，可以一眼就看出代码逻辑</li><li>设计模式语言：用设计模式在命名上面体现出来，能让阅读代码的人领会设计者的意图</li><li>小心注释：<strong>如果是为了阐述代码背后的意图，那么注释是有意义的；如果只是复述代码功能（为了弥补代码的表达能力不足），那么注释就有了坏味道。</strong><ol><li>不要复述功能：为了复述代码功能而存在的注释，就要考虑注释是否需要，真正的高手是尽量不写注释</li><li>要解释背后的意图：为什么写这段代码，这个代码的意义。而不是写这段代码的作用。如Thread.sleep(2000), 好的注释是：休息2秒，为了等待关联系统的处理结果。没必要的注释：在这里等待2秒</li></ol></li></ul></li><li>命名工具：OnlineSearch插件，里面有海量的互联网上的开源代码。</li></ol><p>命名的力量就是语言的力量，好的命名是人和人之间沟通的桥梁。</p><h3 id="1-2-规范"><a href="#1-2-规范" class="headerlink" title="1.2 规范"></a>1.2 规范</h3><ol><li>认知成本：在学习的过程中，需要交的学费就是认知成本。知识是人类对经验范围内的感觉进行总结归纳之后发现的规律。发现共同抽象和机制可以在很大程度上帮助我们理解复杂系统</li><li>混乱的代价：混乱是有代价的，我们有必要使用规范和约定来让大脑解脱出来，让有限的精力用在刀刃上面。</li><li>代码规范<ul><li>代码格式：缩进、水平对齐、代码注释等，统一固定模版</li><li>空行规范：免费的空行可以让相关概念的代码在一起。如果每行代码后面都添加空行则空行就失去了意义。空行加好之后，在看代码的时候会清晰很多。</li><li>命名规范：类名大驼峰，方法小驼峰，常量全部大写，枚举Enum结尾，抽象类Abstract结尾，包名统一小写</li><li>日志规范：error-不能自己恢复的错误，warn-可预知的业务问题，info-记录系统的基本运行过程和运行状态，debug-调试信息</li><li>异常规范：定义业务异常和系统异常，统一兜底处理。错误码统一约定，在搭建系统的时候就要制定好规范，否则后面想改就很麻烦</li></ul></li><li>埋点规范：数据采集可以沉淀数据</li><li>架构规范：架构有约束，需要遵从这些约束，才能符合架构要求，否则架构就失去了意义</li><li>防止破窗：不要做“打破第一扇窗的人”，发现“破窗”后及时修复，不要让事情进一步恶化。整洁的代码需要每一个人精心维护</li></ol><p>制定规范是为了从无序走向有序，减少认知成本。</p><h3 id="1-3-函数"><a href="#1-3-函数" class="headerlink" title="1.3 函数"></a>1.3 函数</h3><p>好的函数能够大大降低阅读代码的困难度，提升代码的可读性。在通往匠人的路上，好的函数必不可少。</p><ol><li><p>什么是函数：“凡此变数中函彼变数者，则此为彼之函数”</p></li><li><p>软件中的函数：函数是一组代码的集合，是程序中最小的功能模块。面向对象中叫方法。</p></li><li><p>封装判断：将判断封装起来能让代码更容易理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不明确的业务逻辑</span></span><br><span class="line"><span class="keyword">if</span>(xxx.equals(xxx) &amp;&amp; yyy.equels(yyy))&#123;</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明确的业务逻辑</span></span><br><span class="line"><span class="keyword">if</span>(isEquals())&#123;</span><br><span class="line">  <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEqueals</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!xxx.equals(xxx))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!yyy.equels(yyy))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数参数化：最理想的参数数量是0，其次是1，再次是2，尽量避免3。参数越少越容易理解，如果参数超过3个就应该封装为一个类</p></li><li><p>短小的函数：建议一个方法不要超过20行</p></li><li><p>职责单一：一个方法只做一件事。函数太长，拆分是有意义的</p></li><li><p>精简辅助代码：如判空、打日志、缓存检查等，减少这些代码可以让函数中的代码更体现业务逻辑，而不是让业务代码淹没在辅助代码中</p><ul><li>优化判空：利用Optional简化判空</li><li>优化缓存判断：可以利用注解（方法注解+字段注解）自研缓存框架，减少缓存的辅助代码。</li><li>优雅降级：比如Spring Cloud Hystrix提供的优雅降级方案</li></ul></li><li><p>组合函数模式：将大函数拆分为多个步骤，并组合在一起。利用入口函数（入口函数读起来向执行步骤一样），将一个大函数拆分为多个子函数的集合。</p></li><li><p>SLAP(抽象层次一致性): 函数体中的内容必须在同一个抽象层次上。如：不要在入口函数里面通过判断执行相同的函数，可以在函数里面通过类型进行区分</p></li><li><p>函数式编程：把函数作为参数传递给另一个函数（1. 减少冗余代码，让代码更简洁。2. 函数是无副作用的可以并行处理而不用担心线程安全问题）</p></li></ol><p>不解决函数的复杂性，就很难解决系统的复杂性。函数不向面向对象那么复杂，但是写好一个好的函数不是一件容易的事情。</p><h3 id="1-4-设计原则"><a href="#1-4-设计原则" class="headerlink" title="1.4 设计原则"></a>1.4 设计原则</h3><p>所谓原则，就是前人总结出来的一套经验，可以有效解决问题的指导思想和方法论</p><ol><li>SOLID(稳定的)，寓意可以建立稳定、灵活、健壮的系统（O、L是设计目标，S、I、D是设计方法）<ul><li>S（SRP）单一职责原则: 要求软件职责要单一，模块中应该只有一个被修改的原因</li><li>0（OCP）开闭原则：对扩展开放，对修改关闭</li><li>L（LSP）里氏替换原则: 父类型都应该可以正确地被子类型替换<ol><li>有强制类型转换和需要通过instanceof判断子类型的地方都不满足LSP</li><li>子类覆盖了父类的方法，改变了含义，这样会出现意想不到的问题</li></ol></li><li>I（LSP）接口隔离原则: 用多个专门的接口比使用一个宽泛用途的接口好</li><li>D（DIP）依赖倒置原则: 模块之间交互应该依赖抽象，而非实现。（面向接口编程）</li></ul></li><li>DRY: 系统的每个功能都应该是唯一的实现，不要开发重复的功能，避免散弹式修改</li><li>YAGNI: 你自以为有用的功能，实际上却用不到。除了核心功能外，其他功能都不要提前设计，这样可以大大加快开发进程</li><li>Rule of Three: 事不过三，三则重构。不赞成过度设计，也不赞成无设计。是DRY和YAGNL的一个平衡。</li><li>KILL原则：把事情变复杂很简单，把事情变简单很复杂。真正的简单不是不思考，而是先发散、在收敛。“宝剑锋从磨砺出”</li><li>POLA原则：最小惊奇原则，写代码不是写小说，要简单易懂，而不是是不是冒出个“Surprise”</li></ol><p>不要教条，软件是一种平衡的艺术。尽量减少系统的复杂度，在不能满足所有原则的时候，要懂得适当取舍</p><h3 id="1-5-设计模式"><a href="#1-5-设计模式" class="headerlink" title="1.5 设计模式"></a>1.5 设计模式</h3><ol><li>模式：模式不是框架也不是过程，不是简单的“问题解决方案”，必须是典型问题的解决方案。要做到知道，但不滥用</li><li>GoF: 四人组收录了23种设计模式，分为创建型（怎样创建对象，将创建和使用分离）、结构型（将对象组成更大的结构）、行为型（类或对象之间如何相互协作完成单个对象无法单独完成的任务）</li><li>拦截器模式：可以在业务操作前后提供一些切面的操作</li><li>插件模式：插件在软件外部将独立的组件加入到软件中（开源软件JPF）</li><li>管道模式：体现了一种分治思想如：Stream API的原理就是管道模式</li></ol><h3 id="1-6-模型"><a href="#1-6-模型" class="headerlink" title="1.6 模型"></a>1.6 模型</h3><ol><li>什么是模型：对现实世界的抽象<ul><li>物理模型：飞机模型、汽车模型等</li><li>数学模型：建模过程，代数方程</li><li>概率模型：对真实世界中问题域的事物的描述</li><li>思维模型：把简单易懂的图形、符号或结构化语言等表达人们思考和解决问题的形式称为思维模型</li><li>模型不能代替现实：能解决问题的模型就是好模型</li></ul></li><li>UML: 提供了一套IT专业人员期待多年的统一标准建模符号</li><li>类图：用来描述类以及它们的相互关系<ul><li>类的UML表示法：可见性（+共有的，-私有的，#受保护的）、名称（大驼峰字母）、类型（表示数据的基本数据类型）</li><li>类的关联关系：双向关联、限定关联、单向关联、自关联、聚合关系、组合关系、</li><li>类的依赖关系：将一个对象作为另一个类中方法的参数、一个类型将另一个类作为局部对象、一个类中调用另一个类的静态方法</li><li>类的泛化关系：继承关系（空心三角形的直线）</li><li>接口实现关系：只有操作的声明，没有操作的实现（用空心三角形的虚线）</li></ul></li><li>领域模型：帮助分析理解复杂业务领域问题、是分析人员和用户交流的有力工具、分析如何满足系统功能性需求</li><li>敏捷建模：模型能用来沟通和理解、尽量用简单的工具创建简单的模型、需求是变化的故模型也要随时变化、重点是交付软件不是交付模型（如果模型没有价值，就不要创建它们）</li><li>广义模型：凡是可以实现对复杂问题的抽象、帮助理解问题域、让沟通高效的图形化方法都是建模<ul><li>C4模型：使用上下文、容器、组件和代码分层的图表</li><li>UI流程图：用页面之间的流转来描述系统交互流程</li><li>业务模版：用图形化的方式描述业务</li></ul></li></ol><p>只要有助于对问题域的理解，就是好的模型</p><h3 id="1-7-DDD的精髓"><a href="#1-7-DDD的精髓" class="headerlink" title="1.7 DDD的精髓"></a>1.7 DDD的精髓</h3><ol><li>什么是DDD: 通过统一语言、业务抽象、领域划分和领域建模等一系列手段控制软件复杂度的方法论</li><li>初步体验DDD: 将行为和业务逻辑放到实体，重构后类多了，但是每个类的职责更加单一，代码的可读性和扩展性随之提高</li><li>数据驱动和领域驱动<ul><li>数据驱动：需求分析 &gt; 数据建模 &gt; 建库建表 &gt; 编写业务逻辑</li><li>领域驱动: 需求分许 &gt; 领域分析 &gt;  领域建模 &gt; 核心业务逻辑 &gt;  技术细节</li><li>ORM: 太理想化，期望通过工具把数据建模和领域建模合一，实践DDD建议不要使用工具建模</li></ul></li><li>优势<ul><li>统一语言： 日常交流中术语无歧义，沟通效率会提高</li><li>面向对象：DDD强调业务抽象和面向对象编程（领域模型的设计精髓在于面向对象分析、对事物的抽象能力）</li><li>业务语义显性化：代码更容易被理解和维护，一切都是为了控制复杂度</li><li>分离业务逻辑和技术细节：核心业务逻辑对技术细节没有任何依赖，依赖都是由外向内。（数据库、框架、UI都是技术细节），业务逻辑不应该依赖框架</li></ul></li><li>核心概念<ol><li>领域实体：软件系统就是现实世界的真实模拟（事物&gt;对象，职责&gt;职责，行为&gt;函数，关系&gt;关系），通过找名词的方式可以获得</li><li>聚合跟：更大范围的把一组相同生命周期和在业务上不可分割的实体和值对象放在一起，是一种内聚性的表现</li><li>领域服务：有些领域中的动作是一些动词，看上去不属于任何对象。它们代表领域中的重要行为，所有不能忽略它们或者简单的合并到某个实体或对象中。这样的行为从领域中识别出来后推荐的方式就是把它声明为服务。</li><li>领域事件：一个特定领域由一个用户动作触发的，是发生在过去的行为产生的事件，这个事件是系统的其他部分或相关系统感兴趣的。</li><li>边界上下文：限定模型的应用范围，在同一个上下文中要保证模型在逻辑上统一，不用考虑它是不是适用于边界之外的情况。</li></ol></li><li>领域建模方法<ol><li>用例分析法：获取用户描述 &gt; 寻找概念类 &gt; 添加关联 &gt; 添加属性 &gt; 模型精化</li><li>四色建模法：任务关键时刻 &gt; 角色 &gt; 人、事、物 &gt; 描述</li></ol></li><li>模型演化: 建模不是一次性的工作，世界上唯一不变的就是变化，通过快速的改变来维护更加具体的模型</li><li>为什么饱受争议<ul><li>照搬概念： 没有领会精髓就在项目中加入概念</li><li>抽象的灵活性：不合理的抽象不如没有抽象，不同的人看问题的角度和对业务的理解各有不同</li><li>领域层的边界：如何划分Application层逻辑和Domain层逻辑是很模糊的，不容易找到边界</li></ul></li></ol><p>对于DDD自己还是没有很好的理解，大部分都只是搬运了一下书上的内容加深了一下自己的理解</p><h2 id="二-思想"><a href="#二-思想" class="headerlink" title="二 思想"></a>二 思想</h2><h3 id="2-1-抽象"><a href="#2-1-抽象" class="headerlink" title="2.1 抽象"></a>2.1 抽象</h3><ol><li>伟大的抽象：人类之所以成为人类，是因为人类能够想象。（归类）</li><li>到底什么是抽象：抽象就是简化事物，抓住事物本质的过程</li><li>抽象是OO的基础: 万物皆对象，抽象帮我们将现实世界的对象抽象为类，完成了现实世界到计算机世界的模型映射</li><li>抽象的层次：抽象是有不同层次的，抽象程度越高所包含的东西就越多，含义就越宽泛，忽略的细节就越多。</li><li>如何进行抽象<ul><li>寻找共性：合并同类项、归并分类、寻找共性的过程</li><li>提升抽象层次：当发现有些无法归到一个类时，就可以往上提升一个抽象层次</li><li>构筑金字塔：金字塔结构通过抽象形成不同的抽象层次，便于理解和记忆</li></ul></li><li>如何提升抽象思维<ul><li>多阅读：阅读的过程可以锻炼我们的抽象能力、想象能力。抽象思维的差别区分了孩子们的学习成绩，零件部件、车床等更加具象，因此不适应抽象训练的孩子就可能去选择读职业技校</li><li>多总结：读书笔记最好不要抄写，要添加自己的理解，用自己的话归纳总结，这样不仅提升自己的抽象思维还可以加深理解（感觉自己这方面没做好）</li><li>领域建模训练：直接去进行领域建模，在实践的过程中就是在锻炼自己的抽象能力</li></ul></li></ol><p>自己要坚持锻炼自己的抽象能力，寻找抽象之美</p><h3 id="2-2-分治"><a href="#2-2-分治" class="headerlink" title="2.2 分治"></a>2.2 分治</h3><p>分治思想是人类进化过程中伟大的智慧，是我们解决问题的不二选择</p><ol><li>分支算法：分解 &gt; 求解 &gt; 合并(归并排序、二分搜索、k选择问题)</li><li>函数分解：将大函数分为多个小的函数</li><li>写代码的两次创造: 第一遍实现功能，第二遍重构优化</li><li>分治模式：责任链和装饰者模式都是分治的思想</li><li>分层设计：<ul><li>分层网络模型：TCP/IP的四层模型</li><li>分层架构：通过分离关注点来降低系统的复杂度</li></ul></li><li>横切和竖切：分库分表的水平拆分和垂直拆分</li></ol><h3 id="2-3-技术人的素养"><a href="#2-3-技术人的素养" class="headerlink" title="2.3 技术人的素养"></a>2.3 技术人的素养</h3><ol><li><p>不教条：软件中没有“银弹”。“控制软件复杂度”才是软件开发中最重要的原则</p><ul><li>瀑布/敏捷?：不要纠结用哪种方法开发，开发的过程都是需求 &gt; 分析与设计 &gt; 实现 &gt; 测试 &gt; 部署。综合各种方式找到最优的方式才是最好的办法</li><li>贫血/充血?: 开发的核心是有没有有效的控制复杂度，如果没有抓住本质就容易造成系统的复杂度</li><li>单体/分布式?: 当系统不满足业务需求的时候，必然需要分布式系统</li></ul></li><li><p>批判性思维：不被动全盘接受，也不刻意反驳一个观点。明知道对方乱说，却无法找到反驳的理由就需要批判性思维。</p></li><li><p>成长型思维: 把失败当成学习的机会，积极主动的去学习和寻找解决方案。工作遇到挫折和挑战的时候要用【成长型思维】去面对</p></li><li><p>结构化思维：无法把一件事情说明白就是没有结构化思维，这就是我所欠缺的。</p><ul><li>逻辑：演绎顺序（大前提、小前提、结论），时间(步骤)顺序（第一、第二、第三），空间（结构）顺序（前端、后端、数据），程度（重要性）顺序（最重要、次重要、不重要）</li><li>套路：why(who、when、where、what、what、how、how much)</li></ul><ol><li>如何落地新团队：<ul><li>熟悉业务：了解业务形态、了解业务流程、走访客户</li><li>熟悉技术：了解系统架构、了解领域模型、了解代码结构</li><li>熟悉人：了解组织结构、了解人员角色、勤沟通</li></ul></li><li>如何做晋级述职： 提出问题、定义问题、分析问题、解决问题、展望未来</li></ol></li><li><p>工具化思维：适当的懒比低效的勤奋更有智慧（磨刀不误砍柴工），不要举步维艰还拒绝改变</p><ul><li>实在懒：拖延不喜欢的任务</li><li>开明懒：快速做完自己不喜欢的任务，以摆脱之</li><li>智慧懒：写工具去完成不喜欢的任务，一劳永逸</li></ul></li><li><p>好奇心：好奇心是创新的驱动力，持续学习才能创造价值并且快乐</p></li><li><p>做笔记：知识内化、形成知识体系、方便回顾。做笔记时候尽量归类分组方便自己查找，不要复制粘贴要记录自己吸收吸收消化之后的东西，简短内容的重点突出</p></li><li><p>有目标：没有带着目标去学习很容易找不到方向，有了目标就会事半功倍</p></li><li><p>选择的自由：<strong>自由不是想做什么就做什么，自由是为自己过去、现在、未来负责的一种价值观。自由是一种责任，是一种敢于做出选择，并愿意为自己选择承担后果的责任</strong></p></li><li><p>平和的心态：做事要积极，心态要放平。“动机至善，了无私心；用无为的心，做有为的事”</p></li><li><p>精进：每天进步一点点，滴水穿石。“人生就像滚雪球，关键就是找到足够多的雪，和足够长的坡”</p></li></ol><h3 id="2-4-技术Leader的修养"><a href="#2-4-技术Leader的修养" class="headerlink" title="2.4 技术Leader的修养"></a>2.4 技术Leader的修养</h3><ol><li>技术氛围：一个技术团队如果没有“技术味道”，那个Leader要负很大的责任<ul><li>代码好坏味道：每周成员轮流组织分享自己找到的3个代码好味道和代码坏味道</li><li>技术分享：用分享倒逼我们去学习，一个人学习整个团队都有了解和认知</li><li>CR周报：透明的代码审查</li><li>读书会：看中学习能力。书的范围放宽、读书的方式可以是几章可以读同一本书、频率灵活</li></ul></li><li>目标管理<ul><li>什么是OKR: 目标与关键成果区别于KPI</li><li>SMART原则：S-指标要具体，M-指标要可衡量，A-指标是有可能达成的，R-表示kr和o要有一定关联性，T-具有明确的截止期限</li><li>OKR设定：目标要足够有野心，只有高远的目标，才能最大程度的激发人的潜能</li></ul></li><li>技术规划：分而治之<ul><li>当前问题：马上需要解决的问题</li><li>技术领域：根据优先级去判断使用那些技术领域等</li><li>业务领域：让业务先赢是技术的首要使命</li><li>团队特色：寻找自己团队的特色（差异化部分）</li></ul></li><li>推理阶梯：不要轻易对员工做推理。在做决定之前一定要问问自己“此事是否可能只是我的推理，实际情况并非如此”。</li><li>Leader和Manager的区别：Manager是控制和权威,Leader是引领和激发。<strong>“我们不需要那么多‘高高在上’，‘指点江山”的技术Manager,而是需要能深入系统，深入技术细节，给团队带来改变的技术Leader</strong></li><li>视人为人：对待上级-有胆量，对待平级-有肺腑，对待下级-有心肝。</li></ol><h2 id="三-实践"><a href="#三-实践" class="headerlink" title="三 实践"></a>三 实践</h2><h3 id="3-1-COLA架构"><a href="#3-1-COLA架构" class="headerlink" title="3.1 COLA架构"></a>3.1 COLA架构</h3><ol><li>软件架构：架构始于建筑，是人类发展分工协作的需要（业务架构、应用架构、系统架构、数据架构、物理架构、运维架构）</li><li>典型的应用架构<ul><li>分层架构：根据系统角色和组织代码单元的常规实践</li><li>CQRS: 任何一个对象的方法都可以分为命令和查询</li><li>六边形架构：也是分层架构，不是上下，而是内部和外部</li><li>洋葱架构：提供了一个完全独立的对象模型，在架构层面运用了依赖倒置原则</li><li>DDD: 以数据驱动转向为领域驱动</li></ul></li><li>COLA架构设计<ul><li>分层设计：一种改良的三层架构（展现层、应用层、领域层、基础设施层）</li><li>扩展设计：每个业务或者场景都可以实现一个或多个扩展点</li><li>规范设计：组件规范、包规范、命名规范、</li></ul></li><li>COLA测试：单元测试、集成测试、ColaMock(自研的mock工具)</li></ol><h3 id="3-2-工匠平台"><a href="#3-2-工匠平台" class="headerlink" title="3.2 工匠平台"></a>3.2 工匠平台</h3><ol><li>项目背景：技术人员的画像，反应技术人员的技术贡献</li><li>整理需求：应用质量、技术影响力、技术贡献、开发质量</li><li>工匠demo：团队成员列表页面、个人详情页面</li><li>使用COLA: 安装、搭建应用</li><li>领域模型<ul><li>领域建模：代码和模型的迭代是交替、螺旋式前进的</li><li>领域词汇表：通过建模过程整理出核心的领域词汇</li></ul></li><li>核心业务逻辑：核心业务逻辑不依赖任何技术细节</li><li>实现技术细节<ul><li>数据存储：领域模型关注业务抽象，将少量的数据进行数据落库</li><li>控制器：利用Controller实现</li></ul></li><li>单元测试：测试范围小、运行速度快</li><li>集成测试：用mock数据进行测试</li><li>回归测试：有了单元测试和集成测试之后，在改代码后只要回归了这些测试就很方便的可以进行预发布验证</li></ol><p>总结：上周把整本书看完之后，感觉自己没什么印象，今天10点抵达图书馆把整本书有过了一遍，还是有不少的收获。唯一不足的就是大部分的都是抄的数据的目录，自己没有归纳总结。唯一的收获就是加深了自己的理解也加深了自己的印象，在以后的工作中可以经常回顾一下，时常巩固才能有所提高。以后要加强自己的归纳总结的能力，争取能有更多的收获。加油^o^!</p>]]></content>
    
    
    <summary type="html">整理了一下代码精进之路每章的大致内容，加深一下映像。每次都记不住，看了就忘。按照书的目录整理一下，希望自己能有所收获。</summary>
    
    
    
    <category term="book" scheme="https://gaoqisen.github.io/categories/book/"/>
    
    
    <category term="code" scheme="https://gaoqisen.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道》</title>
    <link href="https://gaoqisen.github.io/book/TheCleanCoder.html"/>
    <id>https://gaoqisen.github.io/book/TheCleanCoder.html</id>
    <published>2021-06-05T02:10:11.000Z</published>
    <updated>2021-07-04T02:53:55.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-专业主义"><a href="#第一章-专业主义" class="headerlink" title="第一章 专业主义"></a>第一章 专业主义</h3><h4 id="1-1清楚你要什么"><a href="#1-1清楚你要什么" class="headerlink" title="1.1清楚你要什么"></a>1.1清楚你要什么</h4><p>清楚自己负责的是什么，并为自己收拾残局</p><h4 id="1-2-担当责任"><a href="#1-2-担当责任" class="headerlink" title="1.2 担当责任"></a>1.2 担当责任</h4><p>自己写的代码要对它负责，如果有bug需要自己去负责，不要推卸责任。并且需要想清楚为什么会有这个bug，现在如何更好的解决这个bug，以及以后如何防止相同的事情发生</p><h4 id="1-3-职业道德"><a href="#1-3-职业道德" class="headerlink" title="1.3  职业道德"></a>1.3  职业道德</h4><ol><li>需要了解自己的领域：必须精通设计模式、设计原则、方法（结构化分析、瀑布模型等）、实践（测试驱动开发、面向对象设计、持续集成）、工件（UML图、结构图）。</li><li>坚持学习：与时俱进，学习不同的语言</li><li>练习：歌手练习声音、医生联系手术缝合、音乐家练习音阶</li><li>合作：一起编程、一起计划、一起练习、一起设计、一起合作。也需要学会独处</li><li>辅导：辅导新人的同时自己也会受益</li><li>了解业务领域：如果不了解业务是写不出好的程序的，需要花时间去了解业务</li><li>与顾客保持一致：雇主的问题就是你的问题。必须弄清楚问题，并找到最佳解决方案。</li><li>谦虚：专业人士都知道自己也会摔跟头，不要因别人犯错了就对之横加贬损，因为自己很可能就是下一个犯错的人。如果遇到挫折最好的办法就是一笑而过，并在上面长个心眼</li></ol><h3 id="第二章-说“不”"><a href="#第二章-说“不”" class="headerlink" title="第二章 说“不”"></a>第二章 说“不”</h3><p>能就是能，不能就是不能。不要说“试试看”。– 尤达</p><h4 id="2-1-对抗角色"><a href="#2-1-对抗角色" class="headerlink" title="2.1 对抗角色"></a>2.1 对抗角色</h4><p>竭尽所能的捍卫自身的目标，如果无法完成任务就要勇于说“不”，也要勇于对抗，不能为达目的不择手段。“为什么”远不如“事实”重要。为什么是一个细节问题。不能因为各种原因而去省略重要的步骤</p><h4 id="2-2-高风险时刻"><a href="#2-2-高风险时刻" class="headerlink" title="2.2 高风险时刻"></a>2.2 高风险时刻</h4><p>最要说“不”的时候就是那些高风险的时刻。越是关键时刻，“不”字就越具有价值</p><h4 id="2-3-要有团队精神"><a href="#2-3-要有团队精神" class="headerlink" title="2.3 要有团队精神"></a>2.3 要有团队精神</h4><p>有团队精神的人，不会永远说是。那些事情做得到，那些事情做不到一定要分清楚，做不到的事情一定要讲出来，不能自信过头。</p><ol><li>试试看： 没有“试试看”这回事，尝试的意思就是“付出额外的精力”</li><li>消极对抗：一辆火车冲向大家，只有你一个人有所察觉，你可以选择自己轻轻抽身到马路边，眼睁睁看着其他人被车碾过，也可以选择大喊：“车来了，快离开”</li></ol><h4 id="2-4-说“是”的成本"><a href="#2-4-说“是”的成本" class="headerlink" title="2.4 说“是”的成本"></a>2.4 说“是”的成本</h4><p>大多数情况下，我们都希望说是。一个故事：部门招标1个月时间做一个系统，然后a公司中标了。b成员负责项目的开发，时间特别赶b成员同意做此项目。他没日没夜的加班，全部用硬编码方式完成了这个项目，自己还沾沾自喜的认为干了一件特别了不起的事情（项目开发期间还加了一些其他的功能）。结果之后部门来了个新领导砍掉了这个项目。</p><h4 id="2-5-如何写出好代码"><a href="#2-5-如何写出好代码" class="headerlink" title="2.5 如何写出好代码"></a>2.5 如何写出好代码</h4><p>有可能写出好的代码吗？有可能坚守专业主义的精神吗？在项目特别赶的情况下就可以硬编码，不管设计原则吗？其实想要写出好的代码就需要学会如何说“不”。</p><h3 id="第三章-说“是”"><a href="#第三章-说“是”" class="headerlink" title="第三章 说“是”"></a>第三章 说“是”</h3><h4 id="3-1-承诺用语"><a href="#3-1-承诺用语" class="headerlink" title="3.1 承诺用语"></a>3.1 承诺用语</h4><p>做出承诺的步骤</p><ol><li>口头上说</li><li>心里认真对待做出的承诺</li><li>真正付诸行动</li></ol><h5 id="3-1-1-识别“缺乏承诺”的征兆"><a href="#3-1-1-识别“缺乏承诺”的征兆" class="headerlink" title="3.1.1 识别“缺乏承诺”的征兆"></a>3.1.1 识别“缺乏承诺”的征兆</h5><ol><li>需要/应当：我需要减肥、有人应当负责某某事情</li><li>希望/但愿：希望明天能完成任务、但愿明天有时间</li><li>让我们：让我们把事情做完</li></ol><h5 id="3-1-2-真正的承诺是怎样的"><a href="#3-1-2-真正的承诺是怎样的" class="headerlink" title="3.1.2 真正的承诺是怎样的"></a>3.1.2 真正的承诺是怎样的</h5><p>我将在…之前…完成任务。</p><ol><li>之所以没有成功，是因为我寄需求于某某去做这件事：比如这件事依赖于其他团队，这种情况应该提前就采取行动，提前预估风险</li><li>之所以没有成功，是因为我不太确信是否真正的能够完成：即使目标无法完成，你任然要不留余力的前进，离目标要更近一些</li><li>之所以没有成功，是因为有些时候我真的无能为力：遇到这种情况的时候要及时向承诺对象发出预警<strong>越快越好</strong>！</li></ol><h4 id="3-2-学习如何说“是”"><a href="#3-2-学习如何说“是”" class="headerlink" title="3.2 学习如何说“是”"></a>3.2 学习如何说“是”</h4><ol><li>“试试”的另一面：试试意味着“仍然有余力可施”</li><li>坚守原则：彻底不要出现“如果…或许…”，也不要冒险放弃原则，比如不写测试用例等。专业人士对自己的能力极限了如指掌，清楚的知道如果保持效率的加班能持续多久，也明白要付出的代价</li></ol><p>专人人士不需要对所有请求都回答“是”。不过，他们应该努力寻找创新的方法，尽可能做到有求必应。如果给出了肯定的回答，就要使用正式的承诺。</p><h3 id="第四章-编码"><a href="#第四章-编码" class="headerlink" title="第四章 编码"></a>第四章 编码</h3><h4 id="4-1-做好准备"><a href="#4-1-做好准备" class="headerlink" title="4.1 做好准备"></a>4.1 做好准备</h4><ol><li>代码必须能够正常工作</li><li>代码必须能够帮助你解决客户提出的问题</li><li>代码必须和现有的系统结合的天衣无缝</li><li>其他程序员必须能看懂你写的代码</li></ol><ul><li>凌晨3点写出的代码：疲劳的时候千万不要写代码，要确保自己已经将睡眠、健康和生活方式调整到最好的状况</li><li>焦虑时写下的代码：焦虑的时候建议可以花点时间让自己安静下来，不要硬逼自己写代码，不然很容易写出以后不得不抛弃的代码</li></ul><h4 id="4-2-流态区"><a href="#4-2-流态区" class="headerlink" title="4.2 流态区"></a>4.2 流态区</h4><p>高效率状态会出现“绝无错误”的误区，这种状态会为了追求所谓速度，理性思考的能力会下降。建议可以结对编程</p><ul><li>音乐：听音乐并没有帮助“我”专注编码，反而会消耗一部分脑力资源</li><li>中断：中断无法避免，发生这种情况的时候要想一下，自己也可能会去打扰别人，乐于助人的态度就是专注的态度。</li></ul><h4 id="4-3-阻塞"><a href="#4-3-阻塞" class="headerlink" title="4.3 阻塞"></a>4.3 阻塞</h4><p>无法写出代码的时候建议结对编程会有意想不到的收获</p><ul><li>创造性输入：广泛阅读各种资料来激励自己去创造</li></ul><h4 id="4-4-调试"><a href="#4-4-调试" class="headerlink" title="4.4 调试"></a>4.4 调试</h4><p>真正调试的时候往往是大于编码的时间的，建议使用“测试驱动开发”可以有效的减少调试时间。医生不喜欢重新打开病人的胸腔去修复此前犯下的错误、律师不喜欢之前搞砸过的案子、写代码如果写的更多的是bug也是不专业的</p><h4 id="4-5-保持节奏"><a href="#4-5-保持节奏" class="headerlink" title="4.5 保持节奏"></a>4.5 保持节奏</h4><p>知道何时应该离开一会： 当遇到问题感到疲倦的时候可以离开一会，调整一下精力后才会更好。</p><h4 id="4-6-进度延迟"><a href="#4-6-进度延迟" class="headerlink" title="4.6 进度延迟"></a>4.6 进度延迟</h4><p>管理延迟的诀窍： 早期检测和保持透明</p><ol><li>期望：如果计划的是12天开发周期，那么不要期望自己能10天完成，否则期望会导致大麻烦。不要让其他任何人对此抱有期望</li><li>盲目冲刺：快速冲刺是做不到的，要明确的告诉老板，让他们不要有这种期望</li><li>加班加点：如果没有加班失败的后备方案，建议不要同意接受加班方案</li><li>交付失误：明知道没有完成任务却说完成了任务</li><li>定义完成：要说清楚完成的情况，是代码编写完成了还是自测完成，还是对接完成了</li></ol><h4 id="4-7-帮助"><a href="#4-7-帮助" class="headerlink" title="4.7 帮助"></a>4.7 帮助</h4><ol><li>帮助他人： 互相帮助是每个程序员的职责所在，要以能帮助他人为荣</li><li>接受别人的帮助：如果有人向你伸出援手，要诚挚接受，心怀感激的接受帮助并诚意合作。不要因为自己压力大而推开伸来的援手。</li><li>辅导：向深资导师寻求辅导也是程序员的专业职责</li></ol><h3 id="第五章-测试驱动开发"><a href="#第五章-测试驱动开发" class="headerlink" title="第五章 测试驱动开发"></a>第五章 测试驱动开发</h3><h4 id="5-1-此事已有定论"><a href="#5-1-此事已有定论" class="headerlink" title="5.1 此事已有定论"></a>5.1 此事已有定论</h4><p>TDD不仅仅是一种用于缩短编码周期的简单技巧。结论很清楚，每个开发人员都需要掌握TDD</p><h4 id="5-2-TDD的三项法则"><a href="#5-2-TDD的三项法则" class="headerlink" title="5.2 TDD的三项法则"></a>5.2 TDD的三项法则</h4><ol><li>在写好失败的单元测试之前，不要写任何产品代码</li><li>只要有一个单元测试失败了就不要写测试代码了，无法通过编译的也是失败的情况</li><li>产品代码恰好能够让当前失败的单元测试代码通过即可，无需多写</li></ol><h4 id="5-3-TDD的优势"><a href="#5-3-TDD的优势" class="headerlink" title="5.3 TDD的优势"></a>5.3 TDD的优势</h4><ol><li>确定性： 代码有任何修改，都需要运行全部测试</li><li>缺陷注入率：有不少研究称TDD能显著降低缺陷</li><li>勇气：看到有坏味道的代码就可以马上修改，是TDD给你的勇气</li><li>文档：单元测试就是文档，每个单元测试都是一个调用示例</li><li>设计：遵循三项法则能够产生一种驱动力，促使你做出松耦合的设计</li></ol><h4 id="5-4-局限"><a href="#5-4-局限" class="headerlink" title="5.4 局限"></a>5.4 局限</h4><p>在某些情况下的三项法则是不切实际的，这种情况很少，如果弊大于利就不要使用它</p><h3 id="第六章-练习"><a href="#第六章-练习" class="headerlink" title="第六章 练习"></a>第六章 练习</h3><h4 id="6-1-引子"><a href="#6-1-引子" class="headerlink" title="6.1 引子"></a>6.1 引子</h4><p>没门编程语言都它的hello world。这也是第一个练习，练习能够带来协调的开发节奏。无论是搏斗还是编程，速度都来源于练习</p><h4 id="6-2-编程柔道场"><a href="#6-2-编程柔道场" class="headerlink" title="6.2 编程柔道场"></a>6.2 编程柔道场</h4><ol><li>卡塔：类似于编程小游戏，训练自己</li><li>自由练习：不限制形式的搏击</li></ol><h4 id="6-3-自身经验拓展"><a href="#6-3-自身经验拓展" class="headerlink" title="6.3 自身经验拓展"></a>6.3 自身经验拓展</h4><ol><li>开源：可以在开源网址上去贡献代码</li><li>练习的职业道德：不要在上班的时候进行练习，老板的职责不包括避免你的技术落伍</li></ol><p>无论何时，专业人士都需要练习。</p><h3 id="第七章-验收测试"><a href="#第七章-验收测试" class="headerlink" title="第七章 验收测试"></a>第七章 验收测试</h3><h4 id="7-1-需求的沟通"><a href="#7-1-需求的沟通" class="headerlink" title="7.1 需求的沟通"></a>7.1 需求的沟通</h4><ol><li>过早精细化：经常愿意花大代价追求这种不现实的精确性<ul><li>不确定原则：需求完成的越精细，就越容易被忽视。业务想看到和开发看到的不一致</li><li>预估焦虑：需求是一定会变化的，追求精确性是徒劳的</li></ul></li><li>迟来的模糊性：需求的不确定性会让开发和测试都搞错需求</li></ol><h4 id="7-2-验收测试"><a href="#7-2-验收测试" class="headerlink" title="7.2 验收测试"></a>7.2 验收测试</h4><ol><li>完成的定义：不同的团队的完成的定义是不相同的</li><li>沟通：验收测试的目的是沟通、澄清、精确化。开发方、业务方、测试方都要达成共识</li><li>自动化：验收测试都应该自动进行，手动执行的都要考虑成本</li><li>额外工作：大量的测试用例不是额外的工作，只有确定了细节指标才可以避免开发误入岐途</li><li>验收测试什么时候写，由谁写：通常会交给业务分析人员、QA或者开发人员。如果是开发人员尽量不让写代码的人和开发的人是同一个人</li><li>开发人员的角色：开发人员有责任把验收测试与系统联系起来，让测试通过</li><li>测试的协商与被动推进：测试也是普通人，也会犯错误。如果发现测试用例有问题要及时沟通改进</li><li>验收测试和单元测试：验收测试是业务方写给业务方的。单元测试是程序员写给程序员的。</li><li>图形界面及其他复杂因素：尽可能减少GUI测试，GUI测试越多后期维护的难度就越大</li><li>持续集成：持续集成不应该失败，如果失败了团队所有人应该都要停止干活，先让测试先通过</li></ol><h3 id="第八章-测试策略"><a href="#第八章-测试策略" class="headerlink" title="第八章 测试策略"></a>第八章 测试策略</h3><h4 id="8-1-QA应该找不到任何错误"><a href="#8-1-QA应该找不到任何错误" class="headerlink" title="8.1 QA应该找不到任何错误"></a>8.1 QA应该找不到任何错误</h4><p>开发小组应该把【QA找不到任何错误】当成努力的目标</p><ol><li>QA也是团队的一部分：他是团队中需求定义者和特性描述者</li><li>需求规约定义者：编写针对极端情况、边界状态、异常路径的测试</li></ol><h4 id="8-2-自动化测试金字塔"><a href="#8-2-自动化测试金字塔" class="headerlink" title="8.2 自动化测试金字塔"></a>8.2 自动化测试金字塔</h4><p>人工探索式测试 &gt; 系统测试 &gt; 集成测试 &gt; 组件测试 &gt; 单元测试</p><ol><li>单元测试：程序员自己编写的测试，应该要接近100%的覆盖率，通常要达到90%以上</li><li>组件测试： 针对系统的各个组件编写的，封装了业务规则（QA 和业务人员编写）</li><li>集成测试：对组件很多的大型系统才有意义</li><li>系统测试： 对整个集成完毕的系统进行的自动化测试包含吞吐率和性能测试等</li><li>人工探索式测试： 确保在人工操作下表现良好，同时有创造性的尽可能多的找到“古怪之处”</li></ol><h3 id="第九章-时间管理"><a href="#第九章-时间管理" class="headerlink" title="第九章 时间管理"></a>第九章 时间管理</h3><h4 id="9-1-会议"><a href="#9-1-会议" class="headerlink" title="9.1 会议"></a>9.1 会议</h4><p>公认：会议是必须的、会议浪费了大量的时间</p><ol><li>拒绝： 理智的使用时间，谨慎的选择需要参加的会议，礼貌的拒绝一些不必要的会议</li><li>离席：如果你明白继续待在会议室会浪费时间可以找合适的机会商量如何离席</li><li>确认议程与目标：务必弄清楚议题是什么，花多长时间，取得什么成果</li><li>立会：每个人回答不超过1分钟（昨天干了什么，今天打算干什么，遇到了什么问题）</li><li>迭代计划会议：会议的节奏要快，每个任务应该限制在5-10分钟之内，如果不够应该另选时间专人专门讨论</li><li>迭代回顾和demo展示： 看最新的工作成果的demo可以在最后一周的最后一天下班前45分钟召开，前20分钟回顾，后25分钟展示</li><li>争论/反对：如果观点无法在5-30分钟之内达成一致，就永远无法达成一致，出路是用数据说话</li></ol><h4 id="9-2-注意力点数"><a href="#9-2-注意力点数" class="headerlink" title="9.2 注意力点数"></a>9.2 注意力点数</h4><p>注意力是稀缺的资源如果注意力用光了需要1个小时或更多的时间去补充，可以在注意力不够的时候做其他事情。</p><ol><li>睡眠：充足的睡眠可以保证好的注意力</li><li>咖啡因：适当的咖啡可以保持注意力</li><li>恢复： 注意力耗尽可以自己沉思一会，或者小睡一会</li><li>肌肉注意力：转移注意力到肌肉注意力上面可以提升心智注意力</li></ol><h4 id="9-3-时间拆分和番茄工作法"><a href="#9-3-时间拆分和番茄工作法" class="headerlink" title="9.3 时间拆分和番茄工作法"></a>9.3 时间拆分和番茄工作法</h4><p>给自己设定25分钟，25分钟之内无论什么干扰都需要在25分钟之后在处理，没4个番茄时间段之后休息30分钟</p><h4 id="9-4-要避免的行为"><a href="#9-4-要避免的行为" class="headerlink" title="9.4 要避免的行为"></a>9.4 要避免的行为</h4><p>专业开发人员会评估每个任务的优先级，排除个人的喜好和需要，按照正式的紧急程度来执行任务</p><h4 id="9-5-死胡同"><a href="#9-5-死胡同" class="headerlink" title="9.5 死胡同"></a>9.5 死胡同</h4><p>比如选择了走不通的技术道路越是坚持浪费的时间就越多，专业的开发人员会保持开放的头脑来听取其他意见 ，即使走到尽头，他们仍然有其他选择</p><h4 id="9-6-泥潭"><a href="#9-6-泥潭" class="headerlink" title="9.6 泥潭"></a>9.6 泥潭</h4><p>专业人员时刻留意显露出来的泥潭，然后各种努力，尽快脱身。在泥潭中继续前进时不易察觉的，要及时修正设计。</p><h3 id="第十章-预估"><a href="#第十章-预估" class="headerlink" title="第十章 预估"></a>第十章 预估</h3><h4 id="10-1-什么是预估"><a href="#10-1-什么是预估" class="headerlink" title="10.1 什么是预估"></a>10.1 什么是预估</h4><p>开发认为预估是猜测，业务认为预估是承诺</p><ol><li>承诺：如果你承诺某事，就必须按时完成，不兑现承诺就是一种欺骗</li><li>预估：它不包含任何承诺</li><li>暗示性承诺：试试看就是暗示性承诺，尽量不要使用</li></ol><h4 id="10-2-PERT"><a href="#10-2-PERT" class="headerlink" title="10.2 PERT"></a>10.2 PERT</h4><p>一种避免乐观的项目估计的合理方法</p><h4 id="10-3-预估任务"><a href="#10-3-预估任务" class="headerlink" title="10.3 预估任务"></a>10.3 预估任务</h4><p>一组人集合起来重复进行讨论-预估的过程，直到意见统一</p><ol><li>亮手指： 统计大家树起的手指进行精细预估</li><li>规划扑克：用成员的扑克点数进行预估</li><li>关联预估：任务写在卡片上按照规则进行预估</li><li>三元预估： 用三种预估得出概率分布的一种方法</li></ol><h4 id="10-4-大数定律"><a href="#10-4-大数定律" class="headerlink" title="10.4 大数定律"></a>10.4 大数定律</h4><p>把大任务分成多个小任务，分开预估在加总，结果会比单独评估大任务要准确很多</p><h3 id="第十一章-压力"><a href="#第十一章-压力" class="headerlink" title="第十一章 压力"></a>第十一章 压力</h3><h4 id="11-1-避免压力"><a href="#11-1-避免压力" class="headerlink" title="11.1 避免压力"></a>11.1 避免压力</h4><ol><li>承诺：如果没有兑现承诺导致业务失败的压力</li><li>保持整洁：代码设计的整洁可以避免压力，混乱会降低速度，导致工期延误、承诺失信</li><li>危机中的纪律：当困境降临时，不要改好的行为。如：赶工期的时候要保证代码质量</li></ol><h4 id="11-2-应对压力"><a href="#11-2-应对压力" class="headerlink" title="11.2 应对压力"></a>11.2 应对压力</h4><ol><li>不要惊慌失措：放松下来，多想一下问题，努力寻找就会带来好的结果</li><li>沟通：请求团队其他成员或者主管，避免产生惊恐</li><li>依靠你的纪律原则：战胜压力的方式就是依靠你已经知道的切实有效的东西-纪律</li><li>需求帮助：结对编程可以制止你的精神错乱</li></ol><h3 id="第十二章-协作"><a href="#第十二章-协作" class="headerlink" title="第十二章 协作"></a>第十二章 协作</h3><h4 id="12-1-程序员与人"><a href="#12-1-程序员与人" class="headerlink" title="12.1 程序员与人"></a>12.1 程序员与人</h4><ol><li>程序员与雇主：要端正态度，准守规章制度</li><li>程序员与程序员<ul><li>代码个体所有：自己的代码自己维护和其他同事不沟通，拥有大量重复的代码</li><li>协作性的代码共有权：打破隔断，相互合作</li><li>结对：结对编程是复查代码最好的方式</li></ul></li></ol><p>一定要学会交流–和大家交流</p><h3 id="第十三章-团队与项目"><a href="#第十三章-团队与项目" class="headerlink" title="第十三章 团队与项目"></a>第十三章 团队与项目</h3><h4 id="13-1-只是简单混合吗"><a href="#13-1-只是简单混合吗" class="headerlink" title="13.1 只是简单混合吗"></a>13.1 只是简单混合吗</h4><ol><li>有凝聚力的团队<ul><li>发酵期：一起计划、一起解决问题、一起面对问题、一起搞定一切</li><li>团队和项目，何者为先：专业的开发组织把项目分配给有凝聚力的团队</li></ul></li><li>如何管理有凝聚力的团队：可以给团队设置目标值</li></ol><h3 id="第十四章-辅导、学徒期与技艺"><a href="#第十四章-辅导、学徒期与技艺" class="headerlink" title="第十四章 辅导、学徒期与技艺"></a>第十四章 辅导、学徒期与技艺</h3><p>软件学徒期</p><ol><li>大师：一般拥有10年以上的从业经验，他们懂得如何领导和协调多个团队，他们是熟练的设计师和架构师</li><li>熟练工：能胜任工作，并且精力充沛，他们会学习如何在团队中卓越的工作和成为团队的领导者</li><li>学徒/实习生：刚开始进入自己的职业生涯，他们需要熟练工的督导。他们应该至少持续一年的实习期</li></ol><p>技艺中包含着价值观、原则、技术、态度、正见。工匠知道何时该说不，他们懂得如何做出承诺，成熟的工匠才能算是专业人士。</p><p>​         </p>]]></content>
    
    
    <summary type="html">整理了一下代码整洁之道的每章的大致内容，加深一下影像。</summary>
    
    
    
    <category term="book" scheme="https://gaoqisen.github.io/categories/book/"/>
    
    
    <category term="code" scheme="https://gaoqisen.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>五一成都</title>
    <link href="https://gaoqisen.github.io/life/chengdu.html"/>
    <id>https://gaoqisen.github.io/life/chengdu.html</id>
    <published>2021-05-03T13:30:11.000Z</published>
    <updated>2021-07-07T14:52:25.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在五一假期来临的前一天决定了去成都。这次的成员有我、妈妈、堂弟。</p><h3 id="出行方式"><a href="#出行方式" class="headerlink" title="出行方式"></a>出行方式</h3><p>两种方式：跟团、自游。考虑了一下时间，也想到不用急急忙忙的安排时间去玩。于是确定了座火车去成都。</p><h3 id="出现路线"><a href="#出现路线" class="headerlink" title="出现路线"></a>出现路线</h3><p>初略计划路线: 春熙路 &gt; 锦里 &gt; 宽窄巷子 &gt; 青城山 &gt; 都江堰。之后沙大大贡献了一张手写攻略。将路线改为春熙路 &gt; 锦里 &gt; 宽窄巷子 &gt; 熊猫基地 &gt; 青城山 &gt; 都江堰。 </p><h3 id="车票问题"><a href="#车票问题" class="headerlink" title="车票问题"></a>车票问题</h3><p>路线确定好后就是购买车票，这个时间订票就比较困难了，看了一圈12306都没有合适的票。之后看到有个火车票在17:40出发，11:47到达成都东站(买票时是成都东站，订票成功之后就是成都站)，于是和妈妈沟通之后果断购买了该车次的火车票。</p><h3 id="住宿问题"><a href="#住宿问题" class="headerlink" title="住宿问题"></a>住宿问题</h3><p>火车票定好之后，就是住宿的问题，由于5月1日晚上11:47才到站。所以必须先定好住宿的地方，下火车之后就可以直接休息了。订票的几个关键点就是东站附近，价格适中，我们三个人住宿开始计划的是订两个房间，我和我堂弟一间，我妈妈一间。然后就开始下载app（携程旅行、美团），在里面搜索符合自己条件的酒店/民宿。花了两个小时也还是没有找到合适的。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="准备前"><a href="#准备前" class="headerlink" title="准备前"></a>准备前</h3><p>由于票是定在下午5点40的，因此上午还是有大把的时间可以准备的。于是上午我整理了一下房间，把该洗的衣服都洗好了。快10点多的时候我堂弟就拉着行李箱抵达到了我住的地方，12点左右的时候我妈妈带了一包炒黄豆（吃多了放屁的那种），还有一包炸熟了的腊肉和一箱牛奶出现在了楼下。（前一天晚上就跟我妈妈说不要带东西，去玩的时候带东西背着很累，作为老一辈勤俭持家的典范，她还是义无反顾的带上了），我也是像往常一样数落了一番。</p><h3 id="看房子"><a href="#看房子" class="headerlink" title="看房子"></a>看房子</h3><p>一看时间还早我们也没有吃午饭，于是商量之后决定先去买房子的地方（三亚湾）去看下，到了三亚湾去吃了个沙县小吃，然后围着还没修好的小区外面走了一圈。还没修好的小区看着总觉得破破烂烂的，工地旁边的车子停放的乱七八糟，凹凸不平的马路也没有休整，只有快交房的3期才看着像房子的样子。绕着整个小区走一圈还是有点费劲的，何况正午的太阳正是最热的时候，我的衬衫后背都全部汗湿了。买了瓶水之后我们就回到我住的地方了，休息了半个多小时（玩手机）我们就是出发去北站坐火车了。</p><h3 id="火车出发了"><a href="#火车出发了" class="headerlink" title="火车出发了"></a>火车出发了</h3><p>在车站玩了1小时的手机之后，17:40分的时候我们从重庆北站正式出发了。之后就是长达5小时的火车之旅，一路上有人下车，有人上车。有人侃侃而谈，有人沉默不语。一会有美丽的风景从眼前呼啸而过，一会有深不可测的隧道让人短暂沉默。在车上除了玩手机，就是把头撇向窗口。天黑了之后就只剩下玩手机和焦急看看还有多久才能到达终点。大概8点的时候我们拿出了在楼下买好的酸菜面，泡上了我妈妈炸好的腊肉也加了一些炒好的黄豆。于是我正儿八经的坐在椅子上津津有味的吃了起来，我估计坐在我对面的一个大兄弟一定也想来一碗。在吃的时候我问我堂弟和妈妈要吃吗？他们都说不饿，于是我就自己先泡了吃。吃了一半的时候我堂弟也去泡了面。我问我妈妈要吃吗，她还是说不饿。在堂弟泡好快吃的时候我说“妈妈我给你泡吧!”, 这次她没有说不饿，于是我去加好了水（准备把腊肉放在里面一起泡的，她说干吃好吃一些），泡好之后她也静静有味的吃了起来。现在想起来她是不是早就饿了，还是其他什么原因呢？我想不明白。我们打扫完小桌子之后，又安静的等待火车抵达的那一刻了。9点左右对面的大兄弟在咨询了盒饭25元一份之后果断的选择了7元一碗的泡面，他在津津有味的吃泡面的时候，却不知道吃饱了的我也是一点也吃不下了。我看向了黑漆漆的窗外，好像没有方向一样，不知道终点在哪里。</p><h3 id="东站？"><a href="#东站？" class="headerlink" title="东站？"></a>东站？</h3><p>晚上11点47我们抵达了终点成都站，下车后我妈妈开始拍照片。我就给我们定好的名宿老板打电话。“你好，我到成都东站了。”，“好的，你们直接在a酒店来”，“是b酒店吗？”，“不是”，“是c d e酒店吗？”，“不是，你们是在成都东站吗”，“稍等我看下地图”。好家伙，我们总算发现火车抵达的是成都站，住宿的地方是在成都东站。问了下老板怎么去东站，老板说假期的地铁往后延迟了，可以去做地铁，还不算晚。本来我们应该飞一般的奔向地铁的，奈何我们当中没有一个人着急，慢慢悠悠的走到的地铁里面，支付宝切换为成都扫码后就上了地铁。我堂弟没满18岁用不了支付宝去买票花了10分钟（其实没有这么久，可能只有5分钟吧！可是我分明觉得买了很久，哈哈～～～）。坐上车的那一刻，突然感觉终点好远，之后就是长达1小时的地铁之旅。</p><h3 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h3><p>在12点的时候我们实实在在到达了终点，名宿老板带我们过了一个红绿灯和一条马路之后就到小区门口了，进小区大门的时候还需要登记刷脸才能入住，刷脸还总是不过，我骂了句垃圾系统，大概也是10分钟左右才进到小区里面吧！洗漱之后就是快速的躺下入睡 了。我堂弟还睡的比较香，我还是日常失眠，睡不着，隔壁有人神经病一样的敲墙壁，迷迷糊糊的不知道从几点开始还是睡着了几个小时（五一假期的第一天过去了）。</p><h3 id="熊猫基地"><a href="#熊猫基地" class="headerlink" title="熊猫基地"></a>熊猫基地</h3><p>第二天醒来的洗漱完成之后，吃了一碗肥肠粉就就去做公交车了。有直达熊猫基地的车10元每人，做这个车子的人还是挺多的，一路上都没有座位，这是一趟直达的公交车，路途中间一共停留了两次。在快要到熊猫基地的时候堵了一会车，那个时候已经9点多了。在快要下公交车的时候就已经看到人山人海了，之后我们就找入口进去。在进去的时候整个广场上都排满了，人挤人。这是我第一次经历这么多人排队的时候。之前最多的时候也就是排队买票，但是这次真的是特别的挤。人太多了工作人员就会进行限流，拦住人群让前面的人先走一会。每次放人进去的时候每个人都想快一步进去，就会听到有人说“在挤就要发生踩踏事件了，不要挤了”。在这样经历了3次之后，我们总算进到了正式排队的地方（很多栏杆隔开像迷宫迷宫一样的广场，用来限流）。之后等待了20多分钟，总算是进到了熊猫基地里面。在里面看了一下官方推荐的地图就先去了天鹅湖围着天鹅湖走了一圈，看到了一只天鹅，我妈妈去拍了一张照片。这个时候的天气已经热起来了，我的衬衫已经汗湿了紧紧的贴着我的皮肤。而我们也满怀期待的在这个陌生的环境行走，想要去看大熊猫，小熊猫。</p><p>…</p><p>过了很久之后再来回忆（2020/7/6），好多事情都想不起来了。但是还是想把这次旅行写完，把故事继续下去。整个熊猫基地走下来也没有看到几只熊猫，有熊猫的地方往往都围了一堆人把路都堵的死死的。为了不添堵我们只好往前走，最近距离看到的一只熊猫拖着圆滚滚的身子在它经常走动的地方走了一圈，这个时候就听到好些人吆喝起来，“快来，这里有一只熊猫”。熊猫到是对发生的一切都习以为常，大概是它早已对自己待了好几年的地方不屑一顾,也想出去走走？他走了一小截路就回去躺着了，这个时候的天气本来就有点热了。可能对于胖子来说走几步的锻炼量总是足够的吧！之后我们去看小熊猫，提示牌提示说小熊猫主的地方会离的比较近不能进行投喂，我还兴冲冲的以为可以摸到小熊猫，结果一只都没有看到。进到了一个帘子都是铁链做的笼子里面之后，在里面逛了好几圈也没有看到一只，于是我们扫兴而归。出门后就看到有人贴着玻璃兴奋拍照，我们顺着他们的目光也总算是在树上面发现了几只小熊猫在打闹。这个时候我总是想到之前在贵阳黔灵山公园看到的几只猴子，他们也是在树上打闹，树长在河边，茂盛的树枝都繁衍到了河面上，然后一只贼兮兮的猴子快速的转动着它那双雪亮的大眼睛，趁着另一只猴子不注意，一下子就把它推到了河里面，之后就是猴子哈哈大笑的声音、游客哈哈大学的声音、当然我也发出了呵呵呵的声音。</p><p>回过神来我们在一个池塘旁的厕所方便完后就准备去下一个地方了，之后我们又去看了看熊猫博物馆在出口方向，排了10多分钟后才顺利进入（进去的时候必须有人出来之后才能进去）。里面好多都是讲述熊猫是如何培育的，还有3D的影片。草草的看完后我们就出熊猫基地了。</p><p>出去之后的下一个目标是去春熙路，原计划是做公交车的，然后看着导航顶着太阳绕了一大圈子之后又回到了开始排队近熊猫基地的地方。一人买了根老冰棍，这个时候已经快到饭点 了，在基地附近看了下都没什么吃的。然后征求意见之后就做大巴车到春熙路找吃的了。一个多小时的车程后我们就抵达了春熙路，可能是玩的比较累了在车上迷迷糊糊的还睡着了会。之后就是吃饭 &gt; 找住的地方 &gt; 休息片刻 &gt; 准备去下一个景点。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
    
    
    <summary type="html">五一假期已经过去大半的时间，在假期期间去了成都旅游了一圈。乘着还没有忘记所有的事情，记录一下这个成都之旅的流水日记^.^</summary>
    
    
    
    <category term="life" scheme="https://gaoqisen.github.io/categories/life/"/>
    
    
    <category term="life" scheme="https://gaoqisen.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>审核流学习</title>
    <link href="https://gaoqisen.github.io/java/view_flow.html"/>
    <id>https://gaoqisen.github.io/java/view_flow.html</id>
    <published>2021-02-06T06:23:52.000Z</published>
    <updated>2021-05-31T14:31:05.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、案例分析"><a href="#一、案例分析" class="headerlink" title="一、案例分析"></a>一、案例分析</h2><ol><li>有两个审核组（审核组1、审核组2）、每组有两个审核成员（审核组1- a，b。审核组2- c，d）</li><li>当有数据需要审核初始化审核组的时候，如数据a需要审核组1和审核组2进行审核。则初始化两条审核信息</li><li>初始数据只有审核组1的成员可以查看并且审核，审核组1审核通过之后审核组2才能查看和审核数据到审核数据。审核组2审核的时候，审核组1只能查看并不能操作审核数据。</li><li>当前用户去查询列表的时候，需要先去查找自己的数据权限。如果有权限则进行展示。（代办事项）</li></ol><p>sql初始化成功之后，进行代码开发。</p><h2 id="二、接口设计"><a href="#二、接口设计" class="headerlink" title="二、接口设计"></a>二、接口设计</h2><h3 id="2-1-创建审核流程接口（初始化审核流）"><a href="#2-1-创建审核流程接口（初始化审核流）" class="headerlink" title="2.1 创建审核流程接口（初始化审核流）"></a>2.1 创建审核流程接口（初始化审核流）</h3><ol><li>逻辑：根据审核类型关联flow_review_rule、flow_rule_group、flow_review_group获取审核类型所需要的审核组并创建审核流程</li><li>入参: 审核唯一编码、审核类型、用户ID…</li></ol><h3 id="2-2-流程列表查询接口（代办事项）"><a href="#2-2-流程列表查询接口（代办事项）" class="headerlink" title="2.2 流程列表查询接口（代办事项）"></a>2.2 流程列表查询接口（代办事项）</h3><ol><li>入参:  产品编码、用户ID、开始时间和结束时间</li><li>逻辑：<ol><li>通过用户ID去查询用户所在的审核组，如果没有审核组则直接返还空数据</li><li>通过审核组和业务类型分页获取当前用户可以审核的流程审核表里面的数据</li><li>用业务类型获取业务系统的dubbo接口</li><li>通过dubbo接口和分页获取的审核唯一编码泛化调用业务系统，获取业务系统的列表数据</li><li>组装审核信息后返还给前端</li></ol></li></ol><p>通用的业务审核列表。只是展示需要审核的数据</p><h3 id="2-3-流程审核查询（查看审核情况）"><a href="#2-3-流程审核查询（查看审核情况）" class="headerlink" title="2.3 流程审核查询（查看审核情况）"></a>2.3 流程审核查询（查看审核情况）</h3><ol><li>入参: 审核唯一编码、业务类型</li><li>逻辑: 通过审核唯一编码查询审核流程表和审核流程记录表并组装数据后返回给前端</li></ol><h3 id="2-4-流程审核接口（判断是否有审核权限）"><a href="#2-4-流程审核接口（判断是否有审核权限）" class="headerlink" title="2.4 流程审核接口（判断是否有审核权限）"></a>2.4 流程审核接口（判断是否有审核权限）</h3><ol><li>入参: 审核唯一编码、审核人员ID、审核结果、驳回资料等、当前审核流程ID、审核类型</li><li>逻辑：<ol><li>判断审核情况是通过还是拒绝，如果是拒绝则通过审核类型调用业务系统（用户中心or订单中心）审核接口进行拒绝操作。</li><li>如果是通过则判断当前审核流程是否是最后一个审核流程，如果是最后一个流程则通过审核类型调用业务系统（用户中心or订单中心）审核接口进行审核。</li><li>修改流程表里面当前流程流状态</li><li>在审核流程记录表里面添加记录</li></ol></li></ol><p>审核通过、审核拒绝时调用</p><h3 id="2-5-流程数据修改接口（判断是否有权限修改）"><a href="#2-5-流程数据修改接口（判断是否有权限修改）" class="headerlink" title="2.5 流程数据修改接口（判断是否有权限修改）"></a>2.5 流程数据修改接口（判断是否有权限修改）</h3><h2 id="三、数据库表设计"><a href="#三、数据库表设计" class="headerlink" title="三、数据库表设计"></a>三、数据库表设计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- 用户和组的关联表</span><br><span class="line">create table flow_group_user(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    group_id bigint(20) not null comment &apos;组ID&apos;,</span><br><span class="line">    user_id bigint(20) not null comment &apos;用户ID&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;用户和组的关联表&apos;;</span><br><span class="line">-- 审核组</span><br><span class="line">create table flow_review_group(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    name varchar(100) not null comment &apos;审核组名称&apos;,</span><br><span class="line">    `desc` varchar(300) default null comment &apos;审核组名称&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;审核组&apos;;</span><br><span class="line">-- 审核表（一条审核记录对应多条审核操作操作记录）为了展示所有的审核详情</span><br><span class="line">create table flow_review(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    review_no bigint(20) not null comment &apos;审核码&apos;,</span><br><span class="line">    rule_id bigint(20) not null comment &apos;规则ID&apos;,</span><br><span class="line">    review_status varchar(2) not null comment &apos;审核状态 0-待审核,1-审核中,2-审核成功,3-审核失败&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;审核表&apos;;</span><br><span class="line"></span><br><span class="line">-- 审核操作记录表</span><br><span class="line">create table flow_review_operate(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    review_no bigint(20) not null comment &apos;审核码&apos;,</span><br><span class="line">    review_parent_id bigint(20) not null comment &apos;审核父ID&apos;,</span><br><span class="line">    review_status varchar(2) not null comment &apos;审核状态 0-待审核,1-审核成功,2-审核失败&apos;,</span><br><span class="line">    `desc` varchar(300) default null comment &apos;审核描述&apos;,</span><br><span class="line">    review_group_id bigint(20) not null comment &apos;审核组ID&apos;,</span><br><span class="line">    review_user_id bigint(20) not null comment &apos;审核用户ID&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;审核操作记录表&apos;;</span><br><span class="line">-- 审核规则</span><br><span class="line">create table flow_review_rule(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    name bigint(50) not null comment &apos;名称&apos;,</span><br><span class="line">    `type` varchar(2) not null comment &apos;类型: 0-用户,1-订单,2-实名制&apos;,</span><br><span class="line">    `desc` varchar(300) default null comment &apos;描述&apos;,</span><br><span class="line">    request_type varchar(2) not null comment &apos;请求类型1-dubbo,2-http&apos;,</span><br><span class="line">    class_name varchar(300) default null comment &apos;类名&apos;,</span><br><span class="line">    class_method varchar(300) default null comment &apos;类方法&apos;,</span><br><span class="line">    class_method_args varchar(300) default null comment &apos;类方法参数&apos;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;审核规则&apos;;</span><br><span class="line">-- 规则和组关联表</span><br><span class="line">create table flow_rule_group(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    group_id bigint(20) not null comment &apos;组ID&apos;,</span><br><span class="line">    rule_id bigint(20) not null comment &apos;规则ID&apos;,</span><br><span class="line">    is_modify varchar(2) not null comment &apos;是否修改0-不修改, 1-修改&apos;,</span><br><span class="line">    is_review varchar(2) not null comment &apos;请求审核0-不审核, 1-审核&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;规则和组关联表&apos;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">学习一下审核流，整理一下思路</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="Java flow" scheme="https://gaoqisen.github.io/tags/Java-flow/"/>
    
  </entry>
  
  <entry>
    <title>简单的权限管理小工具详细设计</title>
    <link href="https://gaoqisen.github.io/java/webCenter2.0.html"/>
    <id>https://gaoqisen.github.io/java/webCenter2.0.html</id>
    <published>2020-12-09T12:50:11.000Z</published>
    <updated>2020-12-13T02:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 通用的核心类</span><br><span class="line">webcenter-core</span><br><span class="line">// 提供的接口</span><br><span class="line">webcenter-api</span><br><span class="line">// 只要的业务逻辑，项目通过集成core、api、admin即可实现简单的单系统权限框架</span><br><span class="line">webcenter-admin</span><br><span class="line">// 审核流，项目集成core、api、admin、review接口实现审核流功能</span><br><span class="line">webcenter-review</span><br><span class="line">// 控制台，项目通过集成core、api、admin、console即可实现web中心的单点登录功能</span><br><span class="line">webcenter-console</span><br><span class="line">// 提供ui页面</span><br><span class="line">webcenter-webpage</span><br></pre></td></tr></table></figure><h2 id="二、项目流程"><a href="#二、项目流程" class="headerlink" title="二、项目流程"></a>二、项目流程</h2><p><img src="https://gaoqisen.github.io/GraphBed/202012/20201212175908.png" alt="https://gaoqisen.github.io/GraphBed/202012/20201212175908.png"></p><p>一个用户多个角色</p><p>一个部门，多个角色(包含当前部门和当前部门子部门的所有权限)</p><p>一个用户一个部门，一个角色(用户拥有所有角色的并集权限)</p><p>一个角色多个菜单和权限<br><img src="https://gaoqisen.github.io/GraphBed/202012/20201212180556.png" alt="https://gaoqisen.github.io/GraphBed/202012/20201212180556.png"></p><h2 id="三、功能点"><a href="#三、功能点" class="headerlink" title="三、功能点"></a>三、功能点</h2><h3 id="webcenter-admin"><a href="#webcenter-admin" class="headerlink" title="webcenter-admin"></a>webcenter-admin</h3><ol><li>权限管理</li><li>用户管理</li><li>角色管理</li><li>菜单管理</li><li>流程审核</li></ol><h3 id="webcenter-console"><a href="#webcenter-console" class="headerlink" title="webcenter-console"></a>webcenter-console</h3><h4 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h4><p>用于给系统初始化client_id等参数，其它自系统必须通过初始化的参数进行系统的配置。</p><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>主要是进行接口的管理，给进行权限的控制，防止没有权限的用户进行接口的攻击</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>用户体系都用同一套。用户通过单点登录获取用户和权限信息等。</p><h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h4><p>给角色可以添加不同系统的不同菜单，和不同的权限</p><h4 id="菜单管理"><a href="#菜单管理" class="headerlink" title="菜单管理"></a>菜单管理</h4><p>菜单管理实现增加系统ID参数，通过系统ID区分不同的系统有不同的菜单。</p><h2 id="四、实现方式"><a href="#四、实现方式" class="headerlink" title="四、实现方式"></a>四、实现方式</h2><ol><li>通过导入依赖和增加数据库即可实现，简单的登陆注册、权限管理等</li><li>以一种插件的方式去集成</li></ol><h2 id="五、接口详细设计"><a href="#五、接口详细设计" class="headerlink" title="五、接口详细设计"></a>五、接口详细设计</h2><h3 id="5-1-webcenter-admin"><a href="#5-1-webcenter-admin" class="headerlink" title="5.1 webcenter-admin"></a>5.1 webcenter-admin</h3><p>用户的增删改查</p><p>角色的增删改查</p><p>菜单的增删改查</p><p>权限的查询（增加通过系统启动的时候初始化到数据库）</p><p>登录接口</p><p>退出接口</p><p>密码修改接口</p><p>菜单查询接口</p><p>验证码获取接口</p><h2 id="5-2-webcenter-console"><a href="#5-2-webcenter-console" class="headerlink" title="5.2 webcenter-console"></a>5.2 webcenter-console</h2><p>单点登录接口(登录后返回用户的权限、菜单等信息)</p><p>退出接口</p><p>系统的增删改查接口</p><p>菜单通过系统区分</p><p>用户角色的权限分配区分系统</p><h2 id="5-3-webcenter-review"><a href="#5-3-webcenter-review" class="headerlink" title="5.3 webcenter-review"></a>5.3 webcenter-review</h2>]]></content>
    
    
    <summary type="html">GQS-WEBCENTER, 一个轻量级的WEB中心。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java springBoot" scheme="https://gaoqisen.github.io/tags/java-springBoot/"/>
    
  </entry>
  
  <entry>
    <title>开发中一些常见的需要避免的问题</title>
    <link href="https://gaoqisen.github.io/java/codeIssue.html"/>
    <id>https://gaoqisen.github.io/java/codeIssue.html</id>
    <published>2020-12-05T08:22:40.000Z</published>
    <updated>2021-01-17T21:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、接口重放问题"><a href="#一、接口重放问题" class="headerlink" title="一、接口重放问题"></a>一、接口重放问题</h2><h3 id="1-1-影响"><a href="#1-1-影响" class="headerlink" title="1.1 影响"></a>1.1 影响</h3><p>同一个接口调用多次（请求原封不动的多次发送）导致出现重复数据。</p><h3 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2 解决办法"></a>1.2 解决办法</h3><p>利用时间戳(判断时间必须当前时间的60s以内)＋随机串（通过redis进行缓存校验查询，判断随机串是否出现过）</p><h2 id="二、平行越权问题"><a href="#二、平行越权问题" class="headerlink" title="二、平行越权问题"></a>二、平行越权问题</h2><h3 id="2-1-影响"><a href="#2-1-影响" class="headerlink" title="2.1 影响"></a>2.1 影响</h3><p>攻击者可以执行同级别的其它用户可以执行的权限，比如攻击者可以自己登陆之后修改其它用户的信息等</p><h3 id="2-2-解决办法"><a href="#2-2-解决办法" class="headerlink" title="2.2 解决办法"></a>2.2 解决办法</h3><p>每个阶段都通过cookie和sessin等进行用户身份的校验</p><h2 id="三、短信轰炸问题"><a href="#三、短信轰炸问题" class="headerlink" title="三、短信轰炸问题"></a>三、短信轰炸问题</h2><h3 id="3-1-影响"><a href="#3-1-影响" class="headerlink" title="3.1 影响"></a>3.1 影响</h3><ol><li>公司短信发送多余，产生经济损失。2. 造成用户收到垃圾短信</li></ol><h3 id="3-2-解决办法"><a href="#3-2-解决办法" class="headerlink" title="3.2 解决办法"></a>3.2 解决办法</h3><p>短信频率限制（1分钟获取一次等），添加图形验证码（防止爬虫通过接口发送验证码）</p><h2 id="四、铭感信息隐藏"><a href="#四、铭感信息隐藏" class="headerlink" title="四、铭感信息隐藏"></a>四、铭感信息隐藏</h2><p>隐藏手机号码、邮箱等敏感信息</p><h2 id="五、分布式锁"><a href="#五、分布式锁" class="headerlink" title="五、分布式锁"></a>五、分布式锁</h2><h3 id="5-1-数据库锁"><a href="#5-1-数据库锁" class="headerlink" title="5.1 数据库锁"></a>5.1 数据库锁</h3><h4 id="5-1-1-乐观锁"><a href="#5-1-1-乐观锁" class="headerlink" title="5.1.1 乐观锁"></a>5.1.1 乐观锁</h4><p>乐观锁一般都乐观的认为数据不会被锁，</p><ol><li><p>在读取数据的时候把数据的版本号一起读出，更新数据的时候使用数据版本号进行数据的更新，如果更新失败了则重新读取数据后再次更新如: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tablesname set data = #&#123;data&#125;, version = #&#123;version&#125; +1 where id = #&#123;id&#125; and version = #&#123;version&#125;</span><br></pre></td></tr></table></figure></li><li><p>也是增加一个字段用来保存时间戳，查询数据的时候把时间戳也查询出来。更新的是判断时间戳是否是一致的</p></li></ol><h4 id="5-1-2-悲观锁"><a href="#5-1-2-悲观锁" class="headerlink" title="5.1.2 悲观锁"></a>5.1.2 悲观锁</h4><p>悲观锁是悲观的认为所有的数据都会出现被锁的情况，故有表锁、行锁、读锁、写锁等，直接数据库层面的锁属于重量级的锁</p><h3 id="5-2-redis锁"><a href="#5-2-redis锁" class="headerlink" title="5.2 redis锁"></a>5.2 redis锁</h3><p>利用redis的setnx去增加锁(setnx只有当key在redis中不存在的时候才能设置成功)，通过expire去释放锁来实现。在代码中判断setnx是否成功，如果成功了则表示锁是空闲状态，否则锁处于占用状态</p><p>l</p><h3 id="5-3-redission"><a href="#5-3-redission" class="headerlink" title="5.3 redission"></a>5.3 redission</h3><h3 id="5-4-zookeeper"><a href="#5-4-zookeeper" class="headerlink" title="5.4 zookeeper"></a>5.4 zookeeper</h3><h2 id="六、分布式事务"><a href="#六、分布式事务" class="headerlink" title="六、分布式事务"></a>六、分布式事务</h2>]]></content>
    
    
    <summary type="html">在开发中经常会遇到的一些问题，都是公司Master强调需要注意的地方。在开发中也要避免这种情况。这里整理一下，加深自己的记忆力。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://gaoqisen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java一些常用的类</title>
    <link href="https://gaoqisen.github.io/java/commom.html"/>
    <id>https://gaoqisen.github.io/java/commom.html</id>
    <published>2020-08-16T12:50:11.000Z</published>
    <updated>2021-07-02T07:52:07.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BeanCopier"><a href="#BeanCopier" class="headerlink" title="BeanCopier"></a>BeanCopier</h2><p>拷贝两个对象,网上资料显示: BeanCopier的性能是PropertyUtils (apache-common)的504倍。PropertyUtils的性能是BeanUtils(apache-common)的1.71倍,因此对象的拷贝尽量使用BeanCopier。注意属性没有提供set方法，只是提供了get方法是会报错的，无法复制属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝对象， 在create对象的时候会出现性能瓶颈，可以将创建的过程放在缓存中，方便直接获取</span></span><br><span class="line">BeanCopier copier = BeanCopier.create(FromEntity.class, ToEntity.class, <span class="keyword">false</span>);  </span><br><span class="line">ToEntity to = <span class="keyword">new</span> ToEntity();  </span><br><span class="line">copier.copy(from, to, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总条数</span></span><br><span class="line"><span class="keyword">int</span> totalRow = <span class="number">101</span>;</span><br><span class="line"><span class="comment">// 每页记录数</span></span><br><span class="line"><span class="keyword">int</span> pageSize = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 总页数</span></span><br><span class="line"><span class="keyword">int</span> totalPage = (totalRow - <span class="number">1</span>) / pageSize + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; totalPage; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> start = i * pageSize;</span><br><span class="line"><span class="keyword">int</span> end = Math.min((i + <span class="number">1</span>) * pageSize, totalRow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分页助手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PageTemplateHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始执行分页</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 总条数</span></span><br><span class="line">        <span class="keyword">int</span> totalRow = <span class="number">50</span>;</span><br><span class="line">        <span class="comment">// 每页记录数</span></span><br><span class="line">        <span class="keyword">int</span> pageSize = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 总页数</span></span><br><span class="line">        <span class="keyword">int</span> totalPage = (totalRow - <span class="number">1</span>) / pageSize + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; totalPage; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> total = execute(i + <span class="number">1</span>, pageSize);</span><br><span class="line">            <span class="keyword">if</span>(total != totalRow) &#123;</span><br><span class="line">                totalRow = total;</span><br><span class="line">                totalPage = (totalRow - <span class="number">1</span>) / pageSize + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(PageTemplateHelper pageTemplate)</span> </span>&#123;</span><br><span class="line">        pageTemplate.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行分页逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法,引入函数式方法</span></span><br><span class="line">PageTemplateHelper.init((start, end) -&gt; &#123;</span><br><span class="line">  System.out.println(start + <span class="string">", "</span> + end);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="AOP注解"><a href="#AOP注解" class="headerlink" title="AOP注解"></a>AOP注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Before 切入点开始处切入内容</span></span><br><span class="line"><span class="comment">// @After 切入点结尾处切入内容</span></span><br><span class="line"><span class="comment">// @AfterReturning 切入点return内容之后切入内容</span></span><br><span class="line"><span class="comment">// @Around在切入点前后切入内容，并自己控制何时执行切入点自身的内容</span></span><br><span class="line"><span class="comment">// @AfterThrowing用来处理当切入内容部分抛出异常之后的处理逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line">     <span class="keyword">try</span>&#123;  </span><br><span class="line">         doBefore();<span class="comment">//对应@Before注解的方法切面逻辑  </span></span><br><span class="line">         method.invoke();  </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">         doAfter();<span class="comment">//对应@After注解的方法切面逻辑  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     doAfterReturning();<span class="comment">//对应@AfterReturning注解的方法切面逻辑  </span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(Exception e)&#123;  </span><br><span class="line">      doAfterThrowing();<span class="comment">//对应@AfterThrowing注解的方法切面逻辑  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hi,666</span></span><br><span class="line">String.format(<span class="string">"Hi,%s"</span>, <span class="string">"666"</span>);</span><br><span class="line"><span class="comment">//f的使用  </span></span><br><span class="line">System.out.printf(<span class="string">"年-月-日 时:分:秒  %tF%n %tT%n"</span>,<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录一些新的语法和自己不经常使用的方法，方便自己以后使用</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java base" scheme="https://gaoqisen.github.io/tags/java-base/"/>
    
  </entry>
  
  <entry>
    <title>一些面试题</title>
    <link href="https://gaoqisen.github.io/study/interview.html"/>
    <id>https://gaoqisen.github.io/study/interview.html</id>
    <published>2020-07-18T06:43:40.000Z</published>
    <updated>2020-08-11T18:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、索引问题"><a href="#一、索引问题" class="headerlink" title="一、索引问题"></a>一、索引问题</h2><h3 id="1-1-从数据结构角度"><a href="#1-1-从数据结构角度" class="headerlink" title="1.1 从数据结构角度"></a>1.1 从数据结构角度</h3><ol><li>B+Tree索引: 适用于查找范围内的数据</li><li>hash索引: 适用于随机访问的场合，查找每条数据的时间都是一样的。</li><li>Fulltext索引: 查找文本中的关键字。</li><li>R-Tree索引: 查询比较接近的数据</li></ol><h3 id="1-2-物理存储角度"><a href="#1-2-物理存储角度" class="headerlink" title="1.2 物理存储角度"></a>1.2 物理存储角度</h3><ol><li><p>聚集索引: 表数据按照索引的顺序来存储</p><p>InnoDB的主键使用的就是聚簇索引，MyISAM不管是主键还是二级索引都是使用的非聚簇索引。</p></li><li><p>非聚集索引: 表数据存储顺序与索引的顺序无关</p></li></ol><h3 id="1-3-逻辑角度"><a href="#1-3-逻辑角度" class="headerlink" title="1.3 逻辑角度"></a>1.3 逻辑角度</h3><ol><li>主键索引:  </li><li>普通索引和单列索引: 唯一的任务就是加快数据的访问速度</li><li>多列索引: 符合最左原则: key index(a,b,c)相当于创建了三个索引a,ab,abc。不支持bc索引。</li><li>唯一索引: 允许有空值，索引列的值必须唯一</li><li>空间索引</li></ol><h3 id="1-2-聚簇索引"><a href="#1-2-聚簇索引" class="headerlink" title="1.2 聚簇索引"></a>1.2 聚簇索引</h3><h2 id="二、Mysql的引擎对比"><a href="#二、Mysql的引擎对比" class="headerlink" title="二、Mysql的引擎对比"></a>二、Mysql的引擎对比</h2><h3 id="2-1-InnoDB"><a href="#2-1-InnoDB" class="headerlink" title="2.1 InnoDB"></a>2.1 InnoDB</h3><p>支持事务、支持外键、支持崩溃修复能力和并发控制、支持行级锁和表级锁</p><h3 id="2-2-MyISAM"><a href="#2-2-MyISAM" class="headerlink" title="2.2 MyISAM"></a>2.2 MyISAM</h3><p>插入速度快、空间和内存使用比较低、只支持表级锁。不支持事务，安全性不高</p><h2 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h2><p>单独学习: <a href="https://gaoqisen.github.io/java/classloader.html">https://gaoqisen.github.io/java/classloader.html</a></p><h2 id="四、HashMap原理"><a href="#四、HashMap原理" class="headerlink" title="四、HashMap原理"></a>四、HashMap原理</h2><ol><li><p>通过key的hashCode经过扰动函数处理过后得到hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扰动函数: 使用扰动函数可以减少碰撞，防止不同的hashcode的高位不同但低位相同导致的hash冲突</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// key.hashCode(): 返回的就是散列值就是hashcode</span></span><br><span class="line">  <span class="comment">// ^: 的意思就是按位异或</span></span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;: 无符号右移，忽略符号位，空位用0补齐</span></span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>通过(n-1)&amp;hash判断当前元素存在的位置，如果当前位置已经存在值则对比key是否一样，如果一样就替换值，如果不一样就通过拉链法解决冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">// 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line"><span class="comment">// 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">       <span class="comment">// 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，这里的相同指的是hashCode以及equals</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">       <span class="comment">// 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line"><span class="comment">// // 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>拉链法: 将链表和数组结合，如果遇到hash冲突就将值放到链表中</p><p>JDK1.8: 当链表的长度大于阀值(默认8)之后，将链表转为了红黑树减少搜索时间。</p></blockquote><h2 id="五、排序算法原理"><a href="#五、排序算法原理" class="headerlink" title="五、排序算法原理"></a>五、排序算法原理</h2><p>Arrays.sort(list.toArray());源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    legacyMergeSort(a);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// Tim优化后的归并排序</span></span><br><span class="line">    ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-legacyMergeSort-a-源码"><a href="#5-1-legacyMergeSort-a-源码" class="headerlink" title="5.1 legacyMergeSort(a)源码"></a>5.1 legacyMergeSort(a)源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** To be removed in a future release. 在以后的版本中会删除*/</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">legacyMergeSort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">      Object[] aux = a.clone();</span><br><span class="line">      mergeSort(aux, a, <span class="number">0</span>, a.length, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>mergeSort(aux, a, 0, a.length, 0);归并算法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object[] src,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Object[] dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> low,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> high,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> off)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> length = high - low;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果数组长度小于INSERTIONSORT_THRESHOLD(7),直接用插入排序</span></span><br><span class="line">      <span class="comment">// Insertion sort on smallest arrays</span></span><br><span class="line">      <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class="line">                       ((Comparable) dest[j-<span class="number">1</span>]).compareTo(dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">                  swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">      <span class="comment">// Recursively sort halves of dest into src</span></span><br><span class="line">      <span class="keyword">int</span> destLow  = low;</span><br><span class="line">      <span class="keyword">int</span> destHigh = high;</span><br><span class="line">      low  += off;</span><br><span class="line">      high += off;</span><br><span class="line">      <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      mergeSort(dest, src, low, mid, -off);</span><br><span class="line">      mergeSort(dest, src, mid, high, -off);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class="line">      <span class="comment">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class="line">      <span class="keyword">if</span> (((Comparable)src[mid-<span class="number">1</span>]).compareTo(src[mid]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Merge sorted halves (now in src) into dest</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=<span class="number">0</span>)</span><br><span class="line">              dest[i] = src[p++];</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              dest[i] = src[q++];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-ComparableTimSort-sort源码"><a href="#5-2-ComparableTimSort-sort源码" class="headerlink" title="5.2 ComparableTimSort.sort源码"></a>5.2 ComparableTimSort.sort源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本质是插入排序和归并排序的结合体</span></span><br><span class="line">  <span class="comment">// 1.是稳定的排序算法，最坏时间复杂度为O(N*log(N))</span></span><br><span class="line"><span class="comment">// 2.对小块进行插入排序，然后进行归并排序</span></span><br><span class="line"><span class="comment">// TimSort算法是由Tim Peters在2002提出并首先实现在了phtyon中，是结合了合并排序（merge sort）和插入排序（insertion sort）的一种高效稳定的算法。算法原理看这里 https://blog.csdn.net/yangzhongblog/article/details/8184707</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Object[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 保证数组的合法性</span></span><br><span class="line"><span class="keyword">assert</span> a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">      <span class="comment">// 对于只有0|1个元素的数组，不需要进行排序</span></span><br><span class="line">      <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">          <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line"><span class="comment">// 如果数组长度小于32个则调用binarySort，二分插入排序</span></span><br><span class="line">      <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">        <span class="comment">// 计算数组头部递增或递减的的序列长度，如果是递减，则翻转，保持升序</span></span><br><span class="line">          <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line">        <span class="comment">// 使用二叉插入排序对在initRunLen后的元素进行排序</span></span><br><span class="line">          binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * March over the array once, left to right, finding natural runs,</span></span><br><span class="line"><span class="comment">       * extending short natural runs to minRun elements, and merging runs</span></span><br><span class="line"><span class="comment">       * to maintain stack invariant.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ComparableTimSort ts = <span class="keyword">new</span> ComparableTimSort(a, work, workBase, workLen);</span><br><span class="line">      <span class="comment">// 计算最小run的长度</span></span><br><span class="line"><span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// Identify next run</span></span><br><span class="line">        <span class="comment">// 计算当前排序的run的长度，如果为递减数组则翻转</span></span><br><span class="line">          <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">        <span class="comment">// 如果当前run的长度小于minRun，则进行扩展，在扩展过程中使用二叉排序来排序扩展的的元素</span></span><br><span class="line">          <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">              <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">              binarySort(a, lo, lo + force, lo + runLen);</span><br><span class="line">              runLen = force;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">          <span class="comment">// 将此run放入栈中</span></span><br><span class="line">        ts.pushRun(lo, runLen);</span><br><span class="line">        <span class="comment">// 执行合并逻辑，合并的时候也做了一些优化</span></span><br><span class="line">          ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Advance to find next run</span></span><br><span class="line">          lo += runLen;</span><br><span class="line">          nRemaining -= runLen;</span><br><span class="line">      &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">      <span class="keyword">assert</span> lo == hi;</span><br><span class="line"><span class="comment">// 保证最后的run都被合并</span></span><br><span class="line">      ts.mergeForceCollapse();</span><br><span class="line">      <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>binarySort原码(二叉插入排序)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">      <span class="keyword">if</span> (start == lo)</span><br><span class="line">          start++;</span><br><span class="line">      <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">          Comparable pivot = (Comparable) a[start];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">          <span class="keyword">int</span> left = lo;</span><br><span class="line">          <span class="keyword">int</span> right = start;</span><br><span class="line">          <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * Invariants:</span></span><br><span class="line"><span class="comment">           *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">           *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">              <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (pivot.compareTo(a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                  right = mid;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  left = mid + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">           * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">           * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">           * first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">           * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">          <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">          <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">          &#125;</span><br><span class="line">          a[left] = pivot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="六、ConcurrentHashMap原理"><a href="#六、ConcurrentHashMap原理" class="headerlink" title="六、ConcurrentHashMap原理"></a>六、ConcurrentHashMap原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 不允许插入空值，否则报错空指针</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">      <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 更新元素是使用的CAS机制，需要不断尝试，直到成功为止</span></span><br><span class="line">      <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f：链表或红黑二叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。</span></span><br><span class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 判断Node[]数组是否初始化，没有则进行初始化操作</span></span><br><span class="line">          <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">              tab = initTable();</span><br><span class="line">        <span class="comment">// 通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                           <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                  <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 检查到内部正在移动元素（Node[] 数组扩容）</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// //帮助它扩容</span></span><br><span class="line">              tab = helpTransfer(tab, f);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 锁住链表或红黑二叉树的头结点</span></span><br><span class="line">              <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 判断f是否是链表的头结点</span></span><br><span class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果fh&gt;=0 是链表节点</span></span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表所有节点</span></span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                              K ek;</span><br><span class="line">                            <span class="comment">// 如果节点存在，则更新value</span></span><br><span class="line">                              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                  ((ek = e.key) == key ||</span><br><span class="line">                                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                  oldVal = e.val;</span><br><span class="line">                                  <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                      e.val = value;</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                            <span class="comment">// 不存在则在链表尾部添加新节点。</span></span><br><span class="line">                              Node&lt;K,V&gt; pred = e;</span><br><span class="line">                              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                  pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    <span class="comment">// TreeBin是红黑二叉树节点</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                          Node&lt;K,V&gt; p;</span><br><span class="line">                          binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 添加树节点</span></span><br><span class="line">                          <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                         value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              oldVal = p.val;</span><br><span class="line">                              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                  p.val = value;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                  <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                      treeifyBin(tab, i);</span><br><span class="line">                  <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                      <span class="keyword">return</span> oldVal;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 将当前ConcurrentHashMap的size数量+1</span></span><br><span class="line">      addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li><p>判断Node[]数组是否初始化，没有则进行初始化操作</p></li><li><p>通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</p></li><li><p>检查到内部正在扩容，如果正在扩容，就帮助它一块扩容。</p></li><li><p>如果f!=null，则使用synchronized锁住f元素（链表/红黑二叉树的头元素）<br> 4.1 如果是Node(链表结构)则执行链表的添加操作。<br> 4.2 如果是TreeNode(树型结果)则执行树添加操作。</p></li><li><p>判断链表长度已经达到临界值8 就需要把链表转换为树结构。</p></li></ol><h2 id="七、秒杀库存问题"><a href="#七、秒杀库存问题" class="headerlink" title="七、秒杀库存问题"></a>七、秒杀库存问题</h2><ol><li>前端限制(防止普通用户): 用户只能请求一次，一次之后按钮变灰。限制用户只能在10分钟之内只能提交一次等，大概拦住了80%的请求。</li><li>防止接口重复调用(防止程序员写for循环): 同一个uid限制访问频度，60秒内请求的接口返回相同的页面(页面缓存)</li><li>后端限流: 异步处理、消息队列、并发限制.对于超过系统负载的请求，可以选择直接拒绝，以此来对系统进行保护，保证在极限压力的情况下，系统有合理范围内的处理能力</li><li>下单减库存: 用户下单的时候就减库存，这种情况会出现用户下单了但是不支付的情况</li><li>付款减库存: 用户支付之后减库存，这种情况会出现多个人下单了，但是付款的时候没有库存了。</li><li>预扣库存: 用户下单之后预先减去库存，之后提示用户2分钟之内进行付款，如果不支付就回滚数据不进行库存减少。</li><li>防止多并发时数据错误问题: 修改库存的时候，判断当前取回的库存在修改的时候是否一致。“Compare And Set”（CAS）</li></ol><h2 id="八、数据库锁"><a href="#八、数据库锁" class="headerlink" title="八、数据库锁"></a>八、数据库锁</h2><p>悲观锁: 认为别的线程会修改值</p><p>乐观锁: 认为别的线程不会修改值（cas）</p><p>如何防止锁表，数据库死锁问题</p><h2 id="九、如何自己实现削峰填谷、限流等"><a href="#九、如何自己实现削峰填谷、限流等" class="headerlink" title="九、如何自己实现削峰填谷、限流等"></a>九、如何自己实现削峰填谷、限流等</h2><p>令牌桶算法</p><h2 id="十、事务级别"><a href="#十、事务级别" class="headerlink" title="十、事务级别"></a>十、事务级别</h2><ol><li>未提交</li><li>已提交</li><li>可重复读</li><li>序列化</li></ol><h2 id="十一、消息队列积压500万条数据如何处理"><a href="#十一、消息队列积压500万条数据如何处理" class="headerlink" title="十一、消息队列积压500万条数据如何处理"></a>十一、消息队列积压500万条数据如何处理</h2><p>只能操作临时扩容，以更快的速度去消费数据</p><h2 id="十二、方法重写的注解的区别"><a href="#十二、方法重写的注解的区别" class="headerlink" title="十二、方法重写的注解的区别"></a>十二、方法重写的注解的区别</h2><ol><li><em>一般来说，写与不写没什么区别，JVM可以自识别</em> </li><li><em>写的情况下：即说明子类要覆盖基类的方法，基类必须存在方法 （控制类型public,protected，返回值，参数列表类型）与子类方法完成一致的方法，否则会报错（找不到被Override的方法）。</em>  </li><li><em>在不写@Override注解的情况下，当基类存在与子类各种条件都符合的方法时实现覆盖；如果条件不符合时，则是当成新定义的方法使用。</em> </li><li><em>所以如果想覆盖基类方法时，最好还是写上@Override注解，这样有利于编译器帮助检查错误</em></li></ol><h2 id="十三、Springboot和Spring的区别"><a href="#十三、Springboot和Spring的区别" class="headerlink" title="十三、Springboot和Spring的区别"></a>十三、Springboot和Spring的区别</h2><p>SpringBoot是在Spring上面封装的，简化了xml配置，使开发、测试、部署更加方便。SpringBoot有如下特点：</p><ol><li>嵌入式tomcat等</li><li>提供starters简化构建配置</li><li>尽可能自动化配置spring</li><li>使用java -jar 独立运行jar</li></ol><p>SpringBoot是基于Spring的一套快速开发整合包。</p><h2 id="十四、Web攻击"><a href="#十四、Web攻击" class="headerlink" title="十四、Web攻击"></a>十四、Web攻击</h2><h3 id="14-1-DDOS"><a href="#14-1-DDOS" class="headerlink" title="14.1 DDOS"></a>14.1 DDOS</h3><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS）分布式拒绝服务攻击、 发送大量的正确请求到服务端，让服务端收到海量的数据后处理不过来导致服务无法使用。</p><h3 id="14-2-CSRF"><a href="#14-2-CSRF" class="headerlink" title="14.2 CSRF"></a>14.2 CSRF</h3><p>跨站请求伪造（Cross-site request forgery，CSRF）。跨站点请求伪造。通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。</p><p>防范措施: </p><ol><li>检查referer首部字段，检查这个首部字段并要求请求来源的地址在同一个域名下</li><li>添加校验token，不通过cookie进行校验</li><li>输入验证码，重要接口增加验证码验证，用户输入正确验证码后方可操作，让用户明白自己当前的操作。</li></ol><h3 id="14-3-XSS攻击"><a href="#14-3-XSS攻击" class="headerlink" title="14.3 XSS攻击"></a>14.3 XSS攻击</h3><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。是最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><p>防范措施: </p><ol><li>将cookie设置为HttpOnly可以防止JavaScript脚本调用</li><li>过滤特殊字符,例如将script转为其它字符</li></ol><h3 id="14-4-SQL注入"><a href="#14-4-SQL注入" class="headerlink" title="14.4 SQL注入"></a>14.4 SQL注入</h3><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成</p><p>防范措施: </p><ol><li>mysql关键字过滤，不允许用户输入sql关键字</li><li>使用预编译sql语句，没有拼接的过程</li><li>mybatis使用#{}传入数据</li></ol><h2 id="十五、Redis的List是如何实现的"><a href="#十五、Redis的List是如何实现的" class="headerlink" title="十五、Redis的List是如何实现的"></a>十五、Redis的List是如何实现的</h2><p>是使用的链表数据结构存储的数据。</p><ul><li>版本3.2之前<ul><li>压缩列表ziplist</li><li>双向列表linked list</li></ul></li><li>版本3.2之后<ul><li>快速列表quicklist</li></ul></li></ul><h2 id="十六、程序运行慢生产如何调试"><a href="#十六、程序运行慢生产如何调试" class="headerlink" title="十六、程序运行慢生产如何调试"></a>十六、程序运行慢生产如何调试</h2><ol><li>查看数据库是否有锁表，如果有锁表排查是否是程序导致的，并kill掉锁表线程</li><li>查看服务器CPU是否过高，如果CPU过高可以通过jtask查看</li><li>判断程序是一直慢还是突然慢，通过nginx日志筛选是否有第三方恶意工具网站</li><li>排查程序是sql执行慢，还是程序逻辑处理太多。sql慢就进行sql优化，程序逻辑太多的话就进行缓存处理</li></ol><h2 id="十七、集群环境中功能Session如何实现共享"><a href="#十七、集群环境中功能Session如何实现共享" class="headerlink" title="十七、集群环境中功能Session如何实现共享"></a>十七、集群环境中功能Session如何实现共享</h2><ol><li>利用公共的区域存储session例如用redis存储session实现sesison共享</li><li>多台服务器的sesison进行同步比如多台tomcat的session进行同步</li><li>利用新的机制鉴权，不用cookie-session机制。</li></ol><h2 id="十八、什么是线程安全，非线程安全"><a href="#十八、什么是线程安全，非线程安全" class="headerlink" title="十八、什么是线程安全，非线程安全"></a>十八、什么是线程安全，非线程安全</h2><p>多个线程去操作同一个数据不会出现问题叫线程安全，会出现问题就是非线程安全</p><p><a href="https://github.com/gaoqisen/notes/blob/master/java/threadSecurity.md" target="_blank" rel="noopener">https://github.com/gaoqisen/notes/blob/master/java/threadSecurity.md</a></p><h2 id="十九、说一下观察者模式"><a href="#十九、说一下观察者模式" class="headerlink" title="十九、说一下观察者模式"></a>十九、说一下观察者模式</h2><p><a href="https://github.com/gaoqisen/notes/blob/master/patterm/observe.md" target="_blank" rel="noopener">https://github.com/gaoqisen/notes/blob/master/patterm/observe.md</a></p><h2 id="二十、Vue原理"><a href="#二十、Vue原理" class="headerlink" title="二十、Vue原理"></a>二十、Vue原理</h2><p>双向数据绑定的mvvm模式</p><p><a href="https://github.com/gaoqisen/notes/blob/master/web/vueBase.md" target="_blank" rel="noopener">https://github.com/gaoqisen/notes/blob/master/web/vueBase.md</a></p><h2 id="二十一、范式"><a href="#二十一、范式" class="headerlink" title="二十一、范式"></a>二十一、范式</h2><p>第一范式: 数据库表中的任何属性都是原子性的, 不可再分</p><p>第二范式:数据表里的非主属性都要和这个数据表的候选键有完全依赖关系. </p><p>第三范式: 在满足 2NF 的同时, 数据表中的非属性与候选键不存在传递依赖性.</p><h2 id="二十二、参考"><a href="#二十二、参考" class="headerlink" title="二十二、参考"></a>二十二、参考</h2><ol><li>hashmap: <a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></li><li>Arrays.sort: <a href="https://my.oschina.net/u/3286119/blog/2055991" target="_blank" rel="noopener">https://my.oschina.net/u/3286119/blog/2055991</a></li><li>ConCurrentHashMap: <a href="https://www.jianshu.com/p/d10256f0ebea" target="_blank" rel="noopener">https://www.jianshu.com/p/d10256f0ebea</a></li><li>redis list: <a href="https://zhuanlan.zhihu.com/p/102422311" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102422311</a></li><li>范式: <a href="https://bigmorebig.github.io/2019/08/07/SQL进阶/" target="_blank" rel="noopener">https://bigmorebig.github.io/2019/08/07/SQL%E8%BF%9B%E9%98%B6/</a></li><li>攻击: <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/攻击技术.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md</a></li></ol>]]></content>
    
    
    <summary type="html">最近面试了，遇到了好多不是很熟悉的面试题，故记录下来。</summary>
    
    
    
    <category term="study" scheme="https://gaoqisen.github.io/categories/study/"/>
    
    
    <category term="study" scheme="https://gaoqisen.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载的学习</title>
    <link href="https://gaoqisen.github.io/java/classloader.html"/>
    <id>https://gaoqisen.github.io/java/classloader.html</id>
    <published>2020-07-10T08:22:26.000Z</published>
    <updated>2020-07-14T06:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>类加载过程</p><p><img src="https://gaoqisen.github.io/GraphBed/202007/20200710125152.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200710125152.png"></p><ol><li><p>加载: 通过类加载器查找和导入Class文件</p></li><li><p>链接: 把类的二进制数据合并到JRE中</p><ul><li>验证：检查载入class文件数据的正确性，为了确保当前的Class文件符合java虚拟机的要求，并且不会危害虚拟机自身的安全（文件格式验证、元数据验证、字节码验证、符号引用验证）</li><li>准备：给类变量(被static修饰的变量)分配内存,实例变量在实例变量初始化的时候会随对象一起分配在堆中。</li><li>解析: 将符号引用(javap反编译的就是符号引用)转化为直接引用(是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄)的过程</li></ul></li><li><p>初始化: 类的静态变量，静态代码块等执行，类的构造器初始化操作等。虚拟机定义了5种会触发初始化的场景。</p><ul><li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行初始化，则要先触发初始化；    </p></li><li><p>使用java.lang.reflect包中的方法对类进行反射调用的时候；</p></li><li><p>初始化类时，若发现其父类还没有初始化，则先触发父类的初始化；</p></li><li><p>虚拟机启动的时候，虚拟机会先初始化用户指定的包含main()方法的那个类 </p></li><li><p>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p></li></ul></li></ol><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><blockquote><p>加载阶段是开发期相对来说可控性比较强，该阶段既可以使用系统提供的类加载器完成，也可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式</p></blockquote><h3 id="2-1-加载过程"><a href="#2-1-加载过程" class="headerlink" title="2.1 加载过程"></a>2.1 加载过程</h3><ol><li>通过全限定名称取此类的二进制字节流</li><li>将字节流的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成这个class对象作为方法区数据的访问入口</li></ol><h3 id="2-2-JVM内置的ClassLoader"><a href="#2-2-JVM内置的ClassLoader" class="headerlink" title="2.2 JVM内置的ClassLoader"></a>2.2 JVM内置的ClassLoader</h3><ul><li>BootstrpClassLoader: 启动类加载器，顶层的加载器，c++实现，负责加载JAVA_HOME/lib目录下面的jar包和类或者被 <code>-Xbootclasspath</code>参数指定路径下的类</li><li>ExtensionClassLoader: 扩展类加载器，主要加载JAVA_HOME/lib/ext目录下面的jar包和类或者<code>java.ext.dirs</code>系统变量指定的jar包</li><li>AppClassLoader: 应用程序类加载器，面向用户的加载器，加载当前应用的classpath下的所有jar包和类。</li></ul><h3 id="2-3-双亲委派模型"><a href="#2-3-双亲委派模型" class="headerlink" title="2.3 双亲委派模型"></a>2.3 双亲委派模型</h3><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都不愿意干活，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这就是传说中的双亲委派模式。</p><p><img src="https://gaoqisen.github.io/GraphBed/202007/20200710162520.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200710162520.png"></p><ul><li><p>优势:</p><ol><li>避免重复的类加载，如果父类已经加载了子类就不会再次加载。</li><li>保证Java核心API不被篡改。比如黑客自定义了java.lang.String类，有了双亲委派模型后自定义的java.lang.String类就永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。</li></ol></li><li><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双亲委派模型的工作过程源码</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">            <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            <span class="comment">//父类加载器无法完成类加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If still not found, then invoke findClass in order to find the class</span></span><br><span class="line">            <span class="comment">//子加载器进行类加载 </span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        <span class="comment">//判断是否需要链接过程，参数传入</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-破坏双亲委派模型-深入理解java虚拟机"><a href="#2-4-破坏双亲委派模型-深入理解java虚拟机" class="headerlink" title="2.4 破坏双亲委派模型(深入理解java虚拟机)"></a>2.4 破坏双亲委派模型(深入理解java虚拟机)</h3><ul><li><p>向前兼容:  由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。</p></li><li><p>基础类调用用户的代码: 双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢? 这并非是不可能的事情，一个典型的例子便是JNDI服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能“认识”之些代码，该怎么办？为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI，JDBC，JCE，JAXB和JBI等。</p></li></ul><h2 id="三、自定义类加载器"><a href="#三、自定义类加载器" class="headerlink" title="三、自定义类加载器"></a>三、自定义类加载器</h2><h3 id="3-1-什么时候会需要自定义类加载器"><a href="#3-1-什么时候会需要自定义类加载器" class="headerlink" title="3.1 什么时候会需要自定义类加载器"></a>3.1 什么时候会需要自定义类加载器</h3><ol><li>加密: 在类需要加密的时候可以自定义类加载器，这样就可以在读取到密文的类之后在解密之后进行类加载</li><li>非标准来源的类: 比如字节码是从网络获取，或者从数据库中读取，就可以指定来源加载类</li><li>动态创建: 根据实际的情况进行进行动态的创建类</li></ol><h3 id="3-2-自定义类加载器"><a href="#3-2-自定义类加载器" class="headerlink" title="3.2 自定义类加载器"></a>3.2 自定义类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(ClassLoader parent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写findClass方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/jasongao/Desktop/People.class"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过File获取二进制流字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.read(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.write(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"People"</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写People类之后，用javac People.java即可生成class文件</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>类加载: <a href="https://juejin.im/post/5a810b0e5188257a5c606a85" target="_blank" rel="noopener">https://juejin.im/post/5a810b0e5188257a5c606a85</a></li><li>双亲委派模型优势: <a href="https://blog.csdn.net/weixin_38055381/article/details/80167881" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38055381/article/details/80167881</a></li><li>破坏双亲委派模型: <a href="https://juejin.im/post/5d7bbea8e51d4561c541a74f" target="_blank" rel="noopener">https://juejin.im/post/5d7bbea8e51d4561c541a74f</a></li><li>线程上下文: <a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">https://blog.csdn.net/yangcheng33/article/details/52631940</a></li></ul>]]></content>
    
    
    <summary type="html">关于类加载的一些学习。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://gaoqisen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>k8s命令记录</title>
    <link href="https://gaoqisen.github.io/linux/kubernetes.html"/>
    <id>https://gaoqisen.github.io/linux/kubernetes.html</id>
    <published>2020-07-02T10:10:11.000Z</published>
    <updated>2020-07-12T00:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、来源"><a href="#一、来源" class="headerlink" title="一、来源"></a>一、来源</h2><ul><li>Infrastructure as a Service 基础设施即服务(IaaS)</li><li>platform as a Service 平台即服务(PaaS)</li><li>Software as a Service 软件即服务(SaaS)</li></ul><h2 id="一、名词介绍"><a href="#一、名词介绍" class="headerlink" title="一、名词介绍"></a>一、名词介绍</h2><ul><li><p><strong>kubernetes</strong>: 开源的 Docker 容器编排系统，它可以调度计算集群的节点，动态管理上面的作业，保证它们按用户期望的状态运行。通过使用「labels」和「pods」的概念，Kubernetes 将应用按逻辑单元进行分组，方便管理和服务发现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">优势:</span><br><span class="line">1. 快速创建、部署、扩展应用</span><br><span class="line">2. 开发和运行相分离，资源隔离，资源利用更高效</span><br><span class="line">3. 无缝对接新的功能</span><br><span class="line">4. 节省资源，优化硬件资源的使用</span><br><span class="line">5. 自动重启、自动部署、自动复制、自动扩缩容</span><br><span class="line">6. 模块化、插件化、可挂载、可组合</span><br><span class="line">7. 持续开发、集成和部署</span><br><span class="line">8. 开发，测试和生产环境一致性</span><br><span class="line">9. 分布式，弹性，微服务化</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>pods</strong>: 是一组紧密关联的容器集合，它们共享 IPC(进程间通信)、Network(网络) 和 UTS namespace(UTS 命名空间是 Linux 命名空间的一个子系统，主要作用是完成对容器 Hostname 和 Domain 的隔离，同时保存内核名称、版本、以及底层体系结构类型等信息)，是 Kubernetes 调度的基本单位。</p></li><li><p><strong>labels</strong>: 键值对(key/value)标签，可以被关联到如 Pod 这样的对象上，主要作用是给用户一个直观的感受，比如这个 Pod 是用来放置数据库的</p></li><li><p><strong>GUI</strong>: 用户图形界面，可以是 Web 用户界面，比如使用 <code>kubernetes-dashboard</code> 组件，用户可以通过 Dashboard 在 Kubernetes 集群中部署容器化的应用，可以查看集群中应用的运行情况，同时也能够基于 Dashboard 创建或修改部署、任务、服务等 Kubernetes 的资源。通过部署向导，用户能够对部署进行扩缩容，进行滚动更新、重启 Pod 和部署新应用。当然，通过 Dashboard 也能够查看 Kubernetes 资源的状态</p></li><li><p><strong>kube-apiserver</strong>: 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</p></li><li><p><strong>Kubernetes Master</strong>:  Kubernetes 集群主节点，主要由 <code>kube-apiserver</code>、<code>kube-scheduler</code>、<code>kube-controller-manager</code>、<code>etcd</code> 四个模块组成</p></li><li><p><strong>kubernetes Node</strong>: Kubernetes 集群子节点，主要由 <code>kubelet</code>、<code>kube-proxy</code>、<code>runtime</code> 三个模块组成</p></li><li><p><strong>kubeadm</strong>: kubernetes 的集群安装工具，能够快速安装 kubernetes 集群，安装 kubernetes 主要是安装它的各个镜像，而 kubeadm 已经为我们集成好了运行 kubernetes 所需的基本镜像。但由于国内的网络原因，在搭建环境时，无法拉取到这些镜像。此时我们只需要修改为阿里云提供的镜像服务即可解决该问题。</p></li><li><p><strong>kubelet</strong>: 运行在cluster所有节点上,负责启动POD和容器</p></li><li><p><strong>kubectl</strong>: kebenetes的命令行工具,通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件</p></li></ul><h2 id="二、集群安装"><a href="#二、集群安装" class="headerlink" title="二、集群安装"></a>二、集群安装</h2><h3 id="2-1-安装必备工具"><a href="#2-1-安装必备工具" class="headerlink" title="2.1 安装必备工具"></a>2.1 安装必备工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h3 id="2-2-kubeadm安装"><a href="#2-2-kubeadm安装" class="headerlink" title="2.2 kubeadm安装"></a>2.2 kubeadm安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 导出配置文件</span></span><br><span class="line">kubeadm config print init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所需镜像</span></span><br><span class="line">kubeadm config images list --config kubeadm.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line">kubeadm config images pull --config kubeadm.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装主节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定了初始化时需要使用的配置文件，其中添加 --upload-certs 参数可以在后续执行加入节点时自动分发证书文件。追加的 tee kubeadm-init.log 用以输出日志</span></span><br><span class="line">kubeadm init --config=kubeadm.yml --upload-certs | tee kubeadm-init.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装子节点</span></span><br><span class="line">kubeadm join 192.168.81.110:6443 --token abcdef.0123456789abcdef --discovery-token-ca-cert-hash sha256:3eac1be34c9e324279ebd843087e7dd002b3102c7d14313aec490cd73b4138ad</span><br></pre></td></tr></table></figure><h3 id="2-3-常用命令"><a href="#2-3-常用命令" class="headerlink" title="2.3 常用命令"></a>2.3 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看kubernetes api版本</span></span><br><span class="line">kubectl api-versions</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看命名空间</span></span><br><span class="line">kubectl get namespace</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在主节点查看是否安装成功，检查node状态</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Pods 状态</span></span><br><span class="line">watch kubectl get pods -n kube-system -o wide</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看组件运行状态</span></span><br><span class="line">kubectl get cs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下</span></span><br><span class="line">  NAME                 STATUS    MESSAGE             ERROR</span><br><span class="line">  scheduler            Healthy   ok  # 调度服务，主要作用是将 POD 调度到 Node</span><br><span class="line">  controller-manager   Healthy   ok  # 自动化修复服务，主要作用是 Node 宕机后自动修复 Node 回到正常的工作状态</span><br><span class="line">  etcd-0               Healthy   &#123;"health":"true"&#125; # 服务注册与发现</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查master状态</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 kubectl 命令创建两个监听 80 端口的 Nginx Pod（Kubernetes 运行容器的最小单元）</span></span><br><span class="line">kubectl run nginx --image=nginx --replicas=2 --port=80</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pods状态</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经部署的服务</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经发布的服务</span></span><br><span class="line">kubectl get services</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用负载均衡模式发布服务，让用户可以访问</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --type=LoadBalancer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务详情</span></span><br><span class="line">kubectl describe service kubia-web-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已经部署的服务</span></span><br><span class="line">kubectl delete deployment nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已经发布的服务</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署根据配置文件里面列出来的内容，升级现有的,内容可以只写需要升级的属性</span></span><br><span class="line">kubectl apply -f filename.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署先删除所有现有的东西，重新根据yaml文件生成新的</span></span><br><span class="line">kubectl create -f filename.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过ingress查看</span></span><br><span class="line">kubectl get ingress</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑ingress信息</span></span><br><span class="line">kubectl edit ingress nginx-web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除ingress</span></span><br><span class="line">kubectl delete ingress nginx-web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ingress资源</span></span><br><span class="line">kubectl get pods -n ingress-nginx -o wide</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过创建的svc可以看到已经把ingress-nginx service在主机映射的端口</span></span><br><span class="line">kubectl get svc -n ingress-nginx</span><br></pre></td></tr></table></figure><h2 id="三、部署"><a href="#三、部署" class="headerlink" title="三、部署"></a>三、部署</h2><ul><li>tomcat</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建该对象所使用的 Kubernetes API 的版本。通过kubectl api-versions可以查看版本</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建的对象的类型: Deployment、Job、Ingress、Service、Pod</span></span><br><span class="line">kind: Deployment</span><br><span class="line"><span class="meta">#</span><span class="bash"> Pod的一些meta信息，比如名称、namespace、标签等信息</span></span><br><span class="line">metadata:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 资源的名字，在同一个namespace中必须唯一</span></span><br><span class="line">  name: tomcat-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> Pod中容器的详细定义</span></span><br><span class="line">spec:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 定义标签选择器</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      # 容器标签的名字，发布 Service 时，selector 需要和这里对应</span><br><span class="line">      app: tomcat</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 副本数量</span></span><br><span class="line">  replicas: 2</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Pod的定义</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      # Pod的label</span><br><span class="line">      labels:</span><br><span class="line">        app: tomcat</span><br><span class="line">    # 指定该资源的内容</span><br><span class="line">    spec:</span><br><span class="line">      # 容器</span><br><span class="line">      containers:</span><br><span class="line">      - name: tomcat</span><br><span class="line">        image: tomcat:8.5.43</span><br><span class="line">        # 镜像拉取策略: Always不管镜像是否存在都会进行一次拉取,Never不管镜像是否存在都不会进行拉取,IfNotPresent:只有镜像不存在时，才会进行镜像拉取注意</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat-http</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8080</span><br><span class="line">      targetPort: 8080</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ClusterIP, NodePort, LoadBalancer</span></span><br><span class="line">  type: ClusterIP</span><br><span class="line">  selector:</span><br><span class="line">    app: tomcat</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-web</span><br><span class="line">  annotations:</span><br><span class="line">    # 指定 Ingress Controller 的类型</span><br><span class="line">    kubernetes.io/ingress.class: "nginx"</span><br><span class="line">    # 指定我们的 rules 的 path 可以使用正则表达式</span><br><span class="line">    nginx.ingress.kubernetes.io/use-regex: "true"</span><br><span class="line">    # 连接超时时间，默认为 5s</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"</span><br><span class="line">    # 后端服务器回转数据超时时间，默认为 60s</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"</span><br><span class="line">    # 后端服务器响应超时时间，默认为 60s</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"</span><br><span class="line">    # 客户端上传文件，最大大小，默认为 20m</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-body-size: "10m"</span><br><span class="line">    # URL 重写</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /</span><br><span class="line">spec:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 路由规则</span></span><br><span class="line">  rules:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 主机名，只能是域名，修改为你自己的</span></span><br><span class="line">  - host: k8s.test.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path:</span><br><span class="line">        backend:</span><br><span class="line">          # 后台部署的 Service Name</span><br><span class="line">          serviceName: tomcat-http</span><br><span class="line">          # 后台部署的 Service Port</span><br><span class="line">          servicePort: 8080</span><br></pre></td></tr></table></figure><h2 id="四、深入学习"><a href="#四、深入学习" class="headerlink" title="四、深入学习"></a>四、深入学习</h2><h3 id="介绍说明"><a href="#介绍说明" class="headerlink" title="介绍说明"></a>介绍说明</h3><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>Horizoontal Pod Autoscaling(HPA): 扩容缩</p><p>StatefulSet: 解决有服务状态服务的问题</p><p>DameonSet: 确保全部挥、或者一些Node上运行一个Pod副本。比如没有node上都安装一个logstash</p><p>Job: 负责批处理任务，只执行一次的任务。如备份等。</p><h3 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h3><h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><p>ReplicaSets(RC): 滚动更新</p><p>Horizoontal Pod Autoscaling(HPA): 扩容缩</p><p>StatefulSet: 解决有服务状态服务的问题</p><p>DameonSet: 确保全部挥、或者一些Node上运行一个Pod副本。比如没有node上都安装一个logstash</p><p>Job: 负责批处理任务，只执行一次的任务。如备份等。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>service</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h3 id="HELM"><a href="#HELM" class="headerlink" title="HELM"></a>HELM</h3><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3>]]></content>
    
    
    <summary type="html">k8s命令记录。</summary>
    
    
    
    <category term="linux" scheme="https://gaoqisen.github.io/categories/linux/"/>
    
    
    <category term="k8s" scheme="https://gaoqisen.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>线程安全的学习</title>
    <link href="https://gaoqisen.github.io/java/threadSecurity.html"/>
    <id>https://gaoqisen.github.io/java/threadSecurity.html</id>
    <published>2020-07-01T10:22:26.000Z</published>
    <updated>2020-07-09T17:16:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线程安全与非线程安全"><a href="#一、线程安全与非线程安全" class="headerlink" title="一、线程安全与非线程安全"></a>一、线程安全与非线程安全</h2><p>非线程安全: ArrayList、HashMap、StringBuilder。</p><p>线程安全: <del>Vector</del>、<del>HashTable</del>(ConcurrentHashMap)、StringBuffer</p><ul><li>HashMap与ConcurrentHashMap的区别<ol><li>ConcurrentHashMap是线程安全的，HashMap不是线程安全的</li><li>ConcurrentHashMap对桶数组进行了分段，HashMap没有。</li><li>ConcurrentHashMap在每个分段上都用锁进行保护，从而让锁更精细一些，并发性能要好一些。HashMap没有锁机制。</li></ol></li></ul><blockquote><p> 在主线程中new了一个非线程安全的ArrayList，然后开1000个线程分别向这个ArrayList里面添加元素，每个线程添加100个元素，等所有线程执行完成后查看list的总数。之后又new一个Vector用同样的方法查看数量，对比结果。例子:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList与Vector测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程不安全</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadHandleArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程安全</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadHandleVector();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadHandleVector</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> Vector();</span><br><span class="line">        <span class="comment">// 用来让主线程等待threadCount个子线程执行完毕</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="string">"线程"</span>+ (i+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                        list.add(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadHandleArrayList</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">// 用来让主线程等待threadCount个子线程执行完毕</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="string">"线程"</span>+ (i+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                        list.add(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个线程操作同一个对象的话就需要使用线程安全的对象，如果在线程内部new的对象则完全没必要使用线程安全的，如果使用了反而会造成性能影响因为线程安全的加了锁的。</p><h2 id="二、-死锁"><a href="#二、-死锁" class="headerlink" title="二、 死锁"></a>二、 死锁</h2><h3 id="2-1-什么是线程死锁"><a href="#2-1-什么是线程死锁" class="headerlink" title="2.1 什么是线程死锁"></a>2.1 什么是线程死锁</h3><p>定义: 如果多个线程在操作同一个对象的时候相互等待，在没有人为干预的情况下无法打破这种僵局。这种情况就是死锁。例如，某计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object a = <span class="keyword">new</span> Object();</span><br><span class="line">        Object b = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"线程1"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"给对象a加锁并访问对象b"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"获取对象b"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"线程2"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"给对象b加锁并访问对象a"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"获取对象a"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-产生的原因"><a href="#2-2-产生的原因" class="headerlink" title="2.2 产生的原因"></a>2.2 产生的原因</h3><ul><li>系统资源的竞争: 系统中有一些资源有限，多线程去处理的时候经常处理资源不够的情况。在线程的运行中，会因为争抢资源而陷入僵局，只有对不可剥夺的资源进行竞争才可能产生死锁。</li><li>线程顺序不对: 在运行的线程中由于顺序不对也会造成死锁。如: 线程1和2同时使用资源1和2，线程1在没有释放的情况下去获取资源2，线程2在没有释放的情况下去获取资源1。就会造成死锁。或者进程A等待进程B发的消息，进程B又在等待进程A 发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</li></ul><h3 id="2-3-必要条件"><a href="#2-3-必要条件" class="headerlink" title="2.3 必要条件"></a>2.3 必要条件</h3><ol><li><strong>互斥条件</strong>：一个资源，或者说一个锁只能被一个线程所占用，当一个线程首先获取到这个锁之后，在该线程释放这个锁之前，其它线程均是无法获取到这个锁。</li><li><strong>占有且等待</strong>：一个线程已经获取到一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁。</li><li><strong>不可剥夺条件</strong>：任何一个线程都无法强制获取别的线程已经占有的锁</li><li><strong>循环等待条件</strong>：线程A拿着线程B的锁，线程B拿着线程A的锁</li></ol><h3 id="2-3-如何避免"><a href="#2-3-如何避免" class="headerlink" title="2.3 如何避免"></a>2.3 如何避免</h3><p>死锁必须满足以上的4个条件，只要其中一个条件不满足就不好产生死锁。</p><ul><li>加锁顺序: 线程按照相同的顺序加锁。</li><li>加锁时限: 线程获取锁的过程中限制一定的时间，如果给定时间内获取不到，就算了，别勉强自己。这需要用到Lock的一些API</li><li>死锁检测: 死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。每当一个线程获得了锁，就在一个数据结构中记录一下如：线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）<ul><li>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。</li><li>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</li></ul></li></ul><h3 id="2-4-死锁检测"><a href="#2-4-死锁检测" class="headerlink" title="2.4 死锁检测"></a>2.4 死锁检测</h3><ul><li><p>jstack: 是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。<strong>线程快照</strong>是当前java虚拟机内每一条线程<strong>正在执行</strong>的<strong>方法堆栈</strong>的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如<code>线程间死锁</code>、<code>死循环</code>、<code>请求外部资源导致的长时间等待</code>等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">JasonGaodeMacBook-Air:~ jasongao$ jps  // 找到当前执行任务的进程号</span><br><span class="line">2770 App</span><br><span class="line">67397 DeathLock</span><br><span class="line">67396 Launcher</span><br><span class="line">65497 KotlinCompileDaemon</span><br><span class="line">64299</span><br><span class="line">67434 Jps</span><br><span class="line">64463 RemoteMavenServer36</span><br><span class="line">JasonGaodeMacBook-Air:~ jasongao$ jstack 67397  // 执行jstack命令查看当前进程堆栈信息</span><br><span class="line">2020-07-01 14:54:34</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):</span><br><span class="line"></span><br><span class="line">"Attach Listener" #15 daemon prio=9 os_prio=31 tid=0x00007fc13b802000 nid=0x360b waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"DestroyJavaVM" #14 prio=5 os_prio=31 tid=0x00007fc13b8e9800 nid=0x1003 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"线程2" #13 prio=5 os_prio=31 tid=0x00007fc13b8e9000 nid=0x5503 waiting for monitor entry [0x0000700001555000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.gaoqisen.threadcecurity.DeathLock$2.run(DeathLock.java:34)</span><br><span class="line">- waiting to lock &lt;0x00000007aad54eb0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000007aad54ec0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">"线程1" #12 prio=5 os_prio=31 tid=0x00007fc13a050800 nid=0x5303 waiting for monitor entry [0x0000700001452000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.gaoqisen.threadcecurity.DeathLock$1.run(DeathLock.java:17)</span><br><span class="line">- waiting to lock &lt;0x00000007aad54ec0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000007aad54eb0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">JNI global references: 1432</span><br><span class="line"></span><br><span class="line">// 线程死锁信息</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"线程2":</span><br><span class="line">  waiting to lock monitor 0x00007fc13b83dca8 (object 0x00000007aad54eb0, a java.lang.Object),</span><br><span class="line">  which is held by "线程1"</span><br><span class="line">"线程1":</span><br><span class="line">  waiting to lock monitor 0x00007fc13b839c08 (object 0x00000007aad54ec0, a java.lang.Object),</span><br><span class="line">  which is held by "线程2"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"线程2":</span><br><span class="line">at com.gaoqisen.threadcecurity.DeathLock$2.run(DeathLock.java:34)</span><br><span class="line">- waiting to lock &lt;0x00000007aad54eb0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000007aad54ec0&gt; (a java.lang.Object)</span><br><span class="line">"线程1":</span><br><span class="line">at com.gaoqisen.threadcecurity.DeathLock$1.run(DeathLock.java:17)</span><br><span class="line">- waiting to lock &lt;0x00000007aad54ec0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000007aad54eb0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure></li><li><p>jconsole: 是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。在命令行中敲入jconsole命令，会自动弹出以下对话框，选择进程67397，并点击“Connect”。</p><p><img src="https://gaoqisen.github.io/GraphBed/202007/20200701150151.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200701150151.png"></p></li></ul><p>  点击Threads后再点击Detect Deadlock</p><p>  <img src="https://gaoqisen.github.io/GraphBed/202007/20200701150311.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200701150311.png"></p><p>之后就可以查看死锁信息了。</p><p><img src="https://gaoqisen.github.io/GraphBed/202007/20200701150506.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200701150506.png"></p><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><ul><li>死锁： <a href="https://www.cnblogs.com/sthu/p/9660914.html" target="_blank" rel="noopener">https://www.cnblogs.com/sthu/p/9660914.html</a></li><li>线程安全：<a href="https://blog.csdn.net/xiao__gui/article/details/8934832" target="_blank" rel="noopener">https://blog.csdn.net/xiao__gui/article/details/8934832</a></li><li>死锁的4个必要条件: <a href="https://blog.csdn.net/rabbit_in_android/article/details/50530960" target="_blank" rel="noopener">https://blog.csdn.net/rabbit_in_android/article/details/50530960</a></li></ul>]]></content>
    
    
    <summary type="html">关于线程安全的一些学习。</summary>
    
    
    
    <category term="Lock thread" scheme="https://gaoqisen.github.io/categories/Lock-thread/"/>
    
    
    <category term="thread" scheme="https://gaoqisen.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://gaoqisen.github.io/study/algorithm.html"/>
    <id>https://gaoqisen.github.io/study/algorithm.html</id>
    <published>2020-06-30T12:43:40.000Z</published>
    <updated>2020-07-20T06:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li>数据结构: 存储数据的不同方式如：数组、链表、</li><li>算法: 同一个问题的不同解决方法,算法往往是针对特定数据结构的</li><li>时间测量：计算算法时间差、幅度不够循环来凑(扩大数据量)</li><li>空间测算: 数据占用的空间越小越好</li><li>时间复杂度(Big O): 时间复杂度为O(n)随着处理数据量的增加，处理时间也会增加。时间复杂度为O(1)表示随着处理数据的规模增大但是处理的时间没有变化。</li><li>对数器: 检查算法是否正确，用足够多的样本和正确的算法计算结果样本去对比被验证的算法结果(用已有的排序算法和自己写的排序算法都去处理数据，之后将处理的结果对比一下是否一致)</li><li>O(1): 表示操作一次之后就可以获取目标元素</li><li>O(n): 表示要检查n个元素来搜索目标</li><li>O(log n): 从数组的中间选择一个随机点进行查找，然后重复这个过程</li><li>O(n2): 一个算法时bai间的消耗是和其计du算步数成平方增长的</li></ul><h2 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h2><h3 id="2-1-选择排序O-n2"><a href="#2-1-选择排序O-n2" class="headerlink" title="2.1 选择排序O(n2)"></a>2.1 选择排序O(n2)</h3><p>先找到最小的数字然后把它放在列表的最前面。最简单最没用的排序算法，有优化空间,不稳定(没用)。原理是找到最小的数把它放在最前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序算法，每次找到最小的数字放在最前面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minVal = i;</span><br><span class="line">            <span class="comment">// 找到最小数字的下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[minVal]) &#123;</span><br><span class="line">                    minVal = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将最小的数字放在最前面</span></span><br><span class="line">            <span class="keyword">int</span> tmp = arr[minVal];</span><br><span class="line">            arr[minVal] = arr[i];</span><br><span class="line">            arr[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-冒泡排序"><a href="#2-2-冒泡排序" class="headerlink" title="2.2 冒泡排序"></a>2.2 冒泡排序</h3><p>从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">80</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = j-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[index] &gt; a[j]) &#123;</span><br><span class="line">                    swap(a, index, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == (a.length - <span class="number">1</span>))&#123;</span><br><span class="line">                System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(a[i]+ <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        a[start] = a[end];</span><br><span class="line">        a[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h3><p>插入排序是一种简单直观的排序算法。它的基本思想是拿到当前值之后往前面的正确位置移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">80</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 通过当前值和前面的值比较，并把当前值放到恰当的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; a[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(a, j, j-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        a[start] = a[end];</span><br><span class="line">        a[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == (a.length - <span class="number">1</span>))&#123;</span><br><span class="line">                System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(a[i]+ <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-希尔排序"><a href="#2-4-希尔排序" class="headerlink" title="2.4 希尔排序"></a>2.4 希尔排序</h3><p>将数组分为几段处理，不如15个数组元素分为每4个一组进行插入排序，之后在进行2个一组插入排序，之后在进行1个一组进行插入排序就可以了。这样缩短了数字之间的插入排序。希尔排序是不常用的排序方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">80</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// knuth序列</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( h &lt;= a.length / <span class="number">3</span>) &#123;</span><br><span class="line">            h = h*<span class="number">3</span> +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = h; gap &gt; <span class="number">0</span>; gap = (gap -<span class="number">1</span>)/<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; gap -<span class="number">1</span> ; j-=gap) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j] &lt; a[j-gap]) &#123;</span><br><span class="line">                        swap(a, j, j-gap);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        a[start] = a[end];</span><br><span class="line">        a[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == (a.length - <span class="number">1</span>))&#123;</span><br><span class="line">                System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(a[i]+ <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-快速排序"><a href="#2-5-快速排序" class="headerlink" title="2.5 快速排序"></a>2.5 快速排序</h3><ul><li><p>单轴排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序: 采用不断的比较和移动来实现排序</span></span><br><span class="line"><span class="comment">// 对于给定的一组记录，选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，</span></span><br><span class="line"><span class="comment">// 将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序</span></span><br><span class="line"><span class="comment">// 后的正确位置,然后再用同样的方法递归地排序划分的两部分，直到序列中的所有记录均有序为止。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        print(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        partition(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针指向左边的第一个值</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">// 已右边的数为基数(轴)</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[right];</span><br><span class="line">        <span class="comment">// 右边的指针就是right-1</span></span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当左边的值小于右边值的时候</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 从左往右找大于或者基数的数字，并移动到arr.length-1的位置</span></span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; arr[i] &lt;= temp) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                arr[j--] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从有右往左找小于或者等于基数的数字，并移动数字到i++的位置</span></span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; arr[j] &gt; temp)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                arr[i++] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基数放在i的位置</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">// 递归循环轴左边的值</span></span><br><span class="line">        partition(arr, left, i-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归循环轴右边的值</span></span><br><span class="line">        partition(arr, i+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        a[start] = a[end];</span><br><span class="line">        a[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == (a.length - <span class="number">1</span>))&#123;</span><br><span class="line">                System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(a[i]+ <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>双轴快排</li></ul><p>从两边同时查找</p><h3 id="2-6-计数排序"><a href="#2-6-计数排序" class="headerlink" title="2.6 计数排序"></a>2.6 计数排序</h3><p>用于统计有特别多的重复数据的时候，比如2万个学生的年龄分布等。非比较排序。 </p><h3 id="2-7-基数排序"><a href="#2-7-基数排序" class="headerlink" title="2.7 基数排序"></a>2.7 基数排序</h3><p>通过每个数字的个位、十位、百位等进行计数排序之后就可以了</p>]]></content>
    
    
    <summary type="html">一些algorithm学习，后期自己努力的方向。</summary>
    
    
    
    <category term="study" scheme="https://gaoqisen.github.io/categories/study/"/>
    
    
    <category term="algorithm" scheme="https://gaoqisen.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>GC学习笔记</title>
    <link href="https://gaoqisen.github.io/java/gc.html"/>
    <id>https://gaoqisen.github.io/java/gc.html</id>
    <published>2020-06-28T08:30:19.000Z</published>
    <updated>2020-07-14T08:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gaoqisen.github.io/GraphBed/202006/20200627172523.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200627172523.png"></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ol><li>serial(新): 一个CPU或一条GC线程进行垃圾回收,会出现STW。采用复制算法</li><li>parNew(新): serial的多线程版本,多条gc线程去回收(降低gc时间)。采用复制算法</li><li>parallel shavenge(新): 并行的多线程(追求CPU吞吐量)。采用复制算法</li><li>serial old(老): 单线程收集。标记-整理算法</li><li>parallel old(老): 多线程回收(追求CPU吞吐量)。标记-整理算法</li><li>CMS(老): 多线程回收(追求最短停顿时间)。标记-清除算法</li><li>G1(java9默认): 没有分代概念，将java堆分为相同的Region，回收最多垃圾数据的Regio</li><li>ZGC: java11, 暂停时间不超过10ms,支持 4TB,JDK13 到了 16TB!</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> JDK版本默认垃圾收集器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Serial Old（老年代）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Serial Old（老年代）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jdk1.9 默认垃圾收集器G1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jdk10 默认垃圾收集器G1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前使用的是哪种回收策略，-XX:+Use后面的就是 -XX:+PrintGCDetails 亦可通过打印的GC日志的新生代、老年代名称判断</span></span><br><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><h2 id="二、垃圾回收算法"><a href="#二、垃圾回收算法" class="headerlink" title="二、垃圾回收算法"></a>二、垃圾回收算法</h2><h3 id="2-1-标记-清除"><a href="#2-1-标记-清除" class="headerlink" title="2.1 标记-清除"></a>2.1 标记-清除</h3><p>首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的 对象。它是最基础的收集算法,后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题: 1. 效率问题。2. 空间问题(标记清除后会产生大量不连续的碎片)</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200627174125.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200627174125.png"></p><h3 id="2-2-标记-整理"><a href="#2-2-标记-整理" class="headerlink" title="2.2 标记-整理"></a>2.2 标记-整理</h3><p>根据老年代的特点特出的一种标记算法,标记过程仍然与“标记-清除”算法一样,但后续步骤不是直接<br>对可回收对象回收,而是让所有存活的对象向一端移动,然后直接清理掉端边界以外的内存</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200627173653.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200627173653.png"></p><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p>为了解决效率问题,“复制”收集算法出现了。它可以将内存分为大小相同的两块,每次使用其中的一 块。当这一块的内存使用完后,就将还存活的对象复制到另一块去,然后再把使用的空间一次清理掉。 这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200627174302.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200627174302.png"></p><h3 id="2-4-分代收集"><a href="#2-4-分代收集" class="headerlink" title="2.4 分代收集"></a>2.4 分代收集</h3><p>当前虚拟机的垃圾收集都采用分代收集算法,只是根据对象存活周期的不 同将内存分为几块。一般将java堆分为新生代和老年代,这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中,每次收集都会有大量对象死去,所以可以选择复制算法,只需要付出少量对象的复制 成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的,而且没有额外的空间对它进行分配担保,所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h2 id="三、垃圾收集器详解"><a href="#三、垃圾收集器详解" class="headerlink" title="三、垃圾收集器详解"></a>三、垃圾收集器详解</h2><h3 id="3-1-serial"><a href="#3-1-serial" class="headerlink" title="3.1 serial"></a>3.1 serial</h3><p>Serial(串行新生代)，serial old(老年代)收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是 一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收 集工作,更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” ),直到它收集结束。</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200630101205.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200630101205.png"></p><p>Serial收集器由于没有线程交互的开销,可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择,简单而且高效。</p><h3 id="3-2-parNew"><a href="#3-2-parNew" class="headerlink" title="3.2 parNew"></a>3.2 parNew</h3><p>ParNew收集器其实就是Serial收集器的多线程版本,除了使用多线程进行垃圾收集外,其余行为(控制参数、收集算法、回收策略等等)和Serial收集器完全一样。新生代采用复制算法,老年代采用标记-整理算法。它是许多运行在Server模式下的虚拟机的首要选择,除了Serial收集器外,只有它能与CMS收集器(真 正意义上的并发收集器,后面会介绍到)配合工作。新生代采用复制算法,老年代采用标记-整理算法。</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200630101848.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200630101848.png"></p><h3 id="3-3-Parallel-Scavenge"><a href="#3-3-Parallel-Scavenge" class="headerlink" title="3.3 Parallel Scavenge"></a>3.3 Parallel Scavenge</h3><p>Parallel Scavenge 收集器类似于ParNew 收集器。Parallel Scavenge收集器关注点是吞吐量(高效率的利用CPU)。CMS等垃圾收集器的关注点更多的是 用户线程的停顿时间(提高用户体验)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时 间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量,如 果对于收集器运作不太了解的话,手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一 个不错的选择。</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200630101848.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200630101848.png"></p><h3 id="3-4-Serial-Old"><a href="#3-4-Serial-Old" class="headerlink" title="3.4 Serial Old"></a>3.4 Serial Old</h3><p>Serial收集器的老年代版本,它同样是一个单线程收集器。它主要有两大用途:一种用途是在JDK1.5以<br>及以前的版本中与Parallel Scavenge收集器搭配使用,另一种用途是作为CMS收集器的后备方案。</p><h3 id="3-5-Parallel-Old"><a href="#3-5-Parallel-Old" class="headerlink" title="3.5 Parallel Old"></a>3.5 Parallel Old</h3><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源 的场合,都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h3 id="3-6-CMS"><a href="#3-6-CMS" class="headerlink" title="3.6 CMS"></a>3.6 CMS</h3><p>Concurrent Mark Sweep 收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合<br>在注重用户体验的应用上使用。是HotSpot虚拟机第一款真正意义上的并发收集器,它第一次实 现了让垃圾收集线程与用户线程(基本上)同时工作， “标记-清除”算法实现。运行分为四个步骤初始标记、并发标记、重新标记、并发清除:</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200630103223.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200630103223.png"></p><ul><li><p>初始标记: 暂停所有线程，记录所有与根(root)对象相连的对象，速度特别快</p></li><li><p>并发标记: 同时开启GC和用户线程,用一个闭包结构去记录可达对象。但在这个阶段结束,这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域,所以 GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p>重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变 动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段的时间稍⻓,远远比 并发标记阶段时间短</p></li><li><p>并发清除: 开启用户线程,同时GC线程开始对为标记的区域做清扫。</p></li></ul><p>  优点: 并发收集，低停顿。</p><p>  缺点: 对CPU资源敏感，无法处理浮动垃圾，标记清除算法会导致大量空间碎片。</p><h3 id="3-7-G1"><a href="#3-7-G1" class="headerlink" title="3.7 G1"></a>3.7 G1</h3><p>java9默认的收集器是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器.<br>以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。筛选回收进化特征：</p><ul><li>并行与并发:G1能充分利用CPU、多核环境下的硬件优势,使用多个CPU(CPU或者CPU核心)来缩 短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作,G1收集器仍 然可以通过并发的方式让java程序继续执行。</li><li>分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆,但是还是保留了分代的概 念。</li><li>空间整合:与CMS的“标记–清理”算法不同,G1从整体来看是基于“标记整理”算法实现的收集 器;从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿:这是G1相对于CMS的另一个大优势,降低停顿时间是G1 和 CMS 共同的关注点, 但G1 除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个⻓度为M 毫秒的时间片段内。</li></ul><p>G1收集器在后台维护了一个优先列表,每次根据允许的收集时间,优先选择回收价值最大的Region(这 也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式, 保证了GF收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)，G1收集过程。</p><ul><li>初始标记 标记与GC Roots直接关联的对象,停止所有用户线程,只启动一条初始标记线程,这个过程很快.</li><li>并发标记 进行全面的可达性分析,开启一条并发标记线程与用户线程并行执行.这个过程比较长.</li><li>最终标记 标记出并发标记过程中用户线程新产生的垃圾.停止所有用户线程,并使用多条最终标记线程并行执行.</li><li>筛选回收 回收废弃的对象.此时也需要停止一切用户线程,并使用多条筛选回收线程并行执行.</li></ul><h3 id="3-8-ZGC"><a href="#3-8-ZGC" class="headerlink" title="3.8 ZGC"></a>3.8 ZGC</h3><p>ZGC是从JDK11中引入的一种新的<strong>支持弹性伸缩</strong>和<strong>低延迟</strong>垃圾收集器，ZGC可以工作在KB~TB的内存之下，作为一种并发的垃圾收集器，ZGC保证应用延迟不会超过10毫秒(即便在堆内存很大的情况下)，在JDK11中是以实验阶段的特性被发布出来的，到JDK13时，ZGC可以支持到16TB的堆内存，并且可以将<strong>未提交的内存归还给操作系统</strong>。</p><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><ul><li>垃圾回收算法: <a href="https://www.jianshu.com/p/114bf4d9e59e" target="_blank" rel="noopener">https://www.jianshu.com/p/114bf4d9e59e</a></li><li>垃圾收集器: <a href="https://cloud.tencent.com/developer/article/163396" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/163396</a></li><li>ZGC: <a href="https://zhuanlan.zhihu.com/p/43608166" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43608166</a></li></ul>]]></content>
    
    
    <summary type="html">学习一下GC的垃圾回收算法，以及现有的垃圾回收器。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java gc" scheme="https://gaoqisen.github.io/tags/java-gc/"/>
    
  </entry>
  
  <entry>
    <title>对象的引用学习笔记</title>
    <link href="https://gaoqisen.github.io/java/reference.html"/>
    <id>https://gaoqisen.github.io/java/reference.html</id>
    <published>2020-06-27T02:31:19.000Z</published>
    <updated>2021-05-31T13:08:37.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的强、软、弱、虚引用"><a href="#对象的强、软、弱、虚引用" class="headerlink" title="对象的强、软、弱、虚引用"></a>对象的强、软、弱、虚引用</h2><ul><li><p>强引用（只要有引用指向就不会被回收）一个对象被强引用时，就算抛出OOM异常也不会被GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// M写finalize方法，在垃圾回收的时候会被调用. 垃圾回收的线程和main主线程那个先执行，不可控。</span></span><br><span class="line">        M m = <span class="keyword">new</span> M();  <span class="comment">// 强引用</span></span><br><span class="line">        m = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();  <span class="comment">// 显示调用垃圾回收</span></span><br><span class="line">        System.out.println(m);  <span class="comment">// 输出 null</span></span><br><span class="line">        System.in.read();  <span class="comment">// 阻塞main线程，给垃圾回收线程时间去执行. 如果重写了finalize方法的话，就会执行该方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>软引用（堆空间不够的时候，gc会去回收），可用来实现内存敏感的高速缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 在内存中，内存中开辟了一块10m的空间。m执行了SoftReference对象，SoftReference软引用指向了10m的内存数据</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; m = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]);</span><br><span class="line">        System.out.println (m.get());  <span class="comment">// 获取对象地址</span></span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);  <span class="comment">// 给gc回收时间</span></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置堆空间最大为20m的时候，前面m的软引用已经有10m的数据了。[-Xmx20M]</span></span><br><span class="line">        <span class="comment">// 这个时候在new一个硬引用的b有15m，这个时候堆空间不够20m，故gc会把软引用的数据清理掉。</span></span><br><span class="line">        <span class="comment">// 在输出m的对象地址就为空</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">12</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 软引用特别适合作缓存</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>弱引用（只要执行gc就会被回收），弱引用可以和一个引用队列(ReferenceQueue)联合使用,如果弱引用所引用的对象被垃圾回收,Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 弱引用</span></span><br><span class="line">       WeakReference&lt;M&gt; m = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> M());</span><br><span class="line">  </span><br><span class="line">       System.out.println(m.get());</span><br><span class="line">       System.gc(); <span class="comment">// gc回收时直接回收弱引用</span></span><br><span class="line">       System.out.println(m.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>虚引用（一直不会被引用，jvm会使用），虚引用主要用来跟踪对象被垃圾回收的活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用来管理直接内存（在对象被垃圾回收之后会执行一些操作）</span></span><br><span class="line">        <span class="comment">// 看m对象有没有指向堆外内存(不归gc管理的)，如果后指向，则清理堆外内存。</span></span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> M(), QUEUE);</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 垃圾回收线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Reference&lt;? extends M&gt; poll = QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"虚引用被jvm回收"</span> + poll);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>虚引用与软引用和弱引用的一个区别在于: 虚引用必须和引用队列(ReferenceQueue)联合使用。当 垃 圾回收器准备回收一个对象时,如果发现它还有虚引用,就会在回收对象的内存之前,把这个虚引 用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用,来了解被引 用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列,那么就可以在所引用 的对象的内存被回收之前采取必要的行动。</p></blockquote><blockquote><p>对象传值的三种方式：1. 通过方法的参数。2. 通过静态变量。3.通过ThreadLocal</p></blockquote><ul><li><p>ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程私有的， 只有在同一个线程里面才可以拿到值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;People&gt; th = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"th: "</span> + th.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在当前线程的map对象里面放 map.set(this, value);</span></span><br><span class="line">            <span class="comment">// set的时候Entry继承了WeakReference，防止内存泄漏。弱引用，只要没有对象指向</span></span><br><span class="line">            th.set(<span class="keyword">new</span> People());</span><br><span class="line">            <span class="comment">// 不用了一定要remove，不然也会内存泄漏</span></span><br><span class="line">            th.remove();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>学习网址: <a href="https://www.bilibili.com/video/BV1HD4y1Q71y?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1HD4y1Q71y?p=8</a></p>]]></content>
    
    
    <summary type="html">JDK1.2之前如果reference类型的数据存储的数值代表的是另一块内存的起始地址,就称这块内存代表一个引用。JDK1.2以后,Java对引用的概念进行了扩充,将引用分为强引用、软引用、弱引用、虚引用四种(引用 强度逐渐减弱)</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java reference" scheme="https://gaoqisen.github.io/tags/java-reference/"/>
    
  </entry>
  
  <entry>
    <title>filebeat学习笔记</title>
    <link href="https://gaoqisen.github.io/tool/filebeat.html"/>
    <id>https://gaoqisen.github.io/tool/filebeat.html</id>
    <published>2020-06-26T12:10:11.000Z</published>
    <updated>2020-07-11T02:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Filebeat是一个日志文件托运工具，在你的服务器上安装客户端后，filebeat会监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh中存放。filebeat是一个轻量级的logstash，当你需要收集信息的机器配置或资源并不是特别多时，使用filebeat来收集日志。日常使用中，filebeat十分稳定。</p><p>logstash 功能虽然强大，但是基于ruby的配置语法、依赖jdk、消耗系统资源等弊端，使得考虑其他方式来替换logstash，filebeat则是一个完美的替代者</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><ul><li><p>最新下载地址: <a href="https://www.elastic.co/cn/downloads/beats/filebeat" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/beats/filebeat</a></p></li><li><p>解压文件夹：</p></li><li><p>启动: sudo ./filebeat -e -c filebeat.yml</p></li><li><p>docker安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mac:</span><br><span class="line">    brew install filebeat</span><br><span class="line">linux:</span><br><span class="line">    wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">    tar -zxvf filebeat-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">    nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;  // 后台启动将所有标准输出及标准错误输出到/dev/null空设备，即没有任何输出</span><br><span class="line">docker:</span><br><span class="line">    docker pull docker.elastic.co/beats/filebeat:7.3.1</span><br><span class="line">    docker tag docker.elastic.co/beats/filebeat:7.3.1 filebeat</span><br><span class="line">    docker run -d --name logstash 10.45.53.221:5000/filebeat </span><br><span class="line">    docker run --name filebeat -d --link logstash -v ~/elk/yaml/filebeat.yml:/usr/share/filebeat/filebeat.yml -v ~/elk/logs/:/home/logs/ filebeat   // 启动filebeat并关联logstash</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">filebeat.yml</span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- paths:</span><br><span class="line">    - /home/user/elk/logs/order/*.log</span><br><span class="line">  multiline:</span><br><span class="line">      pattern: ^\d&#123;4&#125;</span><br><span class="line">      negate: true</span><br><span class="line">      match: after</span><br><span class="line">  fields:</span><br><span class="line">    doc_type: order</span><br><span class="line">- paths:</span><br><span class="line">    - /home/user/elk/logs/customer/*.log</span><br><span class="line">  multiline:</span><br><span class="line">      pattern: ^\d&#123;4&#125;</span><br><span class="line">      negate: true</span><br><span class="line">      match: after</span><br><span class="line">  fields:</span><br><span class="line">    doc_type: customer</span><br><span class="line">output.logstash: # 输出地址</span><br><span class="line">  hosts: [&quot;logstash:5043&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">filebeat学习的一些笔记,还在记录中， 加油！</summary>
    
    
    
    <category term="tool" scheme="https://gaoqisen.github.io/categories/tool/"/>
    
    
    <category term="filebeat" scheme="https://gaoqisen.github.io/tags/filebeat/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch学习</title>
    <link href="https://gaoqisen.github.io/tool/elasticsearch.html"/>
    <id>https://gaoqisen.github.io/tool/elasticsearch.html</id>
    <published>2020-06-25T08:11:32.000Z</published>
    <updated>2020-07-11T02:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h2 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h2><ul><li>下载安装包地址: <a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></li><li><p>修改config/elasticsearch.yml配置</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称</span><br><span class="line">cluster.name: web-application</span><br><span class="line"># ------------------------------------ Node ------------------------------------</span><br><span class="line"># 节点名称</span><br><span class="line">node.name: node-1</span><br><span class="line"># 增加一个自定义属性</span><br><span class="line">#node.attr.rack: r1</span><br><span class="line"># ----------------------------------- Paths ------------------------------------</span><br><span class="line"># 存储数据的目录(用逗号分隔)</span><br><span class="line">#path.data: /path/to/data</span><br><span class="line"># 日志路径</span><br><span class="line">#path.logs: /path/to/logs</span><br><span class="line"># ----------------------------------- Memory -----------------------------------</span><br><span class="line"># 启动时锁定内存:</span><br><span class="line">#bootstrap.memory_lock: true</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br><span class="line"># ---------------------------------- Network -----------------------------------</span><br><span class="line"># 设置外网可以访问</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"># 自定义端口</span><br><span class="line">#http.port: 9200</span><br><span class="line"># --------------------------------- Discovery ----------------------------------</span><br><span class="line">#</span><br><span class="line"># 启动后去发现list里面主机节点是否启动 默认列表[&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span><br><span class="line">#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]</span><br><span class="line"># 初始化主节点</span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;]</span><br><span class="line"># ---------------------------------- Gateway -----------------------------------</span><br><span class="line"># 整个集群启动之后</span><br><span class="line">#gateway.recover_after_nodes: 3</span><br><span class="line"># ---------------------------------- Various -----------------------------------</span><br><span class="line"># 删除索引时需要显示名称</span><br><span class="line">#action.destructive_requires_name: true</span><br><span class="line"># 启动输入密码访问</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line">xpack.security.enabled: true</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>操作命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 增加elasticsearch用户</span><br><span class="line">adduser elasticsearch</span><br><span class="line">// 设置密码</span><br><span class="line">passwd elasticsearch</span><br><span class="line">// 更改文件的所属用户</span><br><span class="line">chown -R elasticsearch filename</span><br><span class="line">// 切换用户</span><br><span class="line">su elasticsearch</span><br><span class="line">// 解压</span><br><span class="line">tar -zxf XXX.tar.gz</span><br><span class="line">// 后台启动</span><br><span class="line">./elasticsearch -d</span><br><span class="line">// 修改密码，为多个用户分别设置密码</span><br><span class="line">bin/elasticsearch-setup-passwords interactive</span><br></pre></td></tr></table></figure></li><li><p>验证:，浏览器访问<a href="http://ip:9200输入帐号密码后返回json串表示启动成功。" target="_blank" rel="noopener">http://ip:9200输入帐号密码后返回json串表示启动成功。</a></p></li></ul><h3 id="1-2-安装遇到的问题"><a href="#1-2-安装遇到的问题" class="headerlink" title="1.2 安装遇到的问题"></a>1.2 安装遇到的问题</h3><h4 id="1-2-1-外网无法访问"><a href="#1-2-1-外网无法访问" class="headerlink" title="1.2.1 外网无法访问"></a>1.2.1 外网无法访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim config/elasticsearch.yml</span><br><span class="line">// 增加下面配置</span><br><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><h4 id="1-2-2-启动报错"><a href="#1-2-2-启动报错" class="headerlink" title="1.2.2 启动报错"></a>1.2.2 启动报错</h4><ul><li><p>system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk。 因为Centos6不支持SecComp，而ES5.2.1默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。解决方法：在elasticsearch.yml中配置bootstrap.system_call_filter为false，注意要在Memory下面:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>max number of threads [1024] for user [elasticsearch] is too low, increase to at least [4096] 最大线程数[1024]太低，至少增加到[4096]。 修改/etc/security/limits.d/90-nproc.conf文件里面1024为4096</p></li><li><p>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 最大虚拟内存区域vm.max_map_count [65530]太低，至少增加到[262144]</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">// 增加下面配置</span><br><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure></li><li><p>max file descriptors [65535] for elasticsearch process is too low, increase to at least[65536]。由于给帐号的最大打开文件个数或者最大打开线程数的限制，一直会报错，因此改一下限制(/etc/security/limits.conf)即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 增加下面配置</span><br><span class="line"> * soft nofile 65536</span><br><span class="line"> * hard nofile 131072</span><br><span class="line"> * soft nproc 2048</span><br><span class="line"> * hard nproc 4096</span><br><span class="line"> // 退出帐号重新登录(退出重新登录生效)</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、常用语法"><a href="#二、常用语法" class="headerlink" title="二、常用语法"></a>二、常用语法</h2><h3 id="2-1-基本操作"><a href="#2-1-基本操作" class="headerlink" title="2.1 基本操作"></a>2.1 基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># &lt;REST Verb&gt; http://localhost:9200/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</span><br><span class="line"># &lt;請求類型&gt;   &lt;请求地址&gt;/&lt;索引名&gt;/&lt;文档类型&gt;/&lt;文档ID&gt;</span><br><span class="line"># 数据库：数据库  表   行    列</span><br><span class="line"># el：   索引    类型 文档  字段</span><br><span class="line"># 检查集群的健康 Authorization 從/獲取</span><br><span class="line">GET /_cat/health?v</span><br><span class="line"># 查看索引返回：health status index uuid pri rep docs.count docs.deleted store.size pri.store.size 表明我们还没有索引在集群中</span><br><span class="line">GET /_cat/indices?v</span><br><span class="line"># 集群中的节点列表</span><br><span class="line">GET /_cat/nodes?v</span><br><span class="line"># 创建一个索引叫做&quot;customer&quot;</span><br><span class="line">PUT /customer?pretty</span><br><span class="line"># 索引一个简单的customer文档到customer索引，external类型，ID是1</span><br><span class="line">PUT /customer/external/1?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 删除一个索引</span><br><span class="line">DELETE /customer?pretty</span><br><span class="line"># 删除全部索引</span><br><span class="line">DELETE /_all</span><br><span class="line"># 删除 多个索引</span><br><span class="line">DELETE /customer,customer1,customer2</span><br><span class="line"># 删除 模糊匹配</span><br><span class="line">DELETE /customer*</span><br><span class="line"># 删除一个文档</span><br><span class="line">DELETE /customer/external/2?pretty</span><br></pre></td></tr></table></figure><h3 id="2-2-search查询条件详解"><a href="#2-2-search查询条件详解" class="headerlink" title="2.2 search查询条件详解"></a>2.2 search查询条件详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 查询出所有问题文档匹配某个查询</span><br><span class="line">GET /centent/_search?q=title:123</span><br><span class="line"># 有多少文档匹配某个查询</span><br><span class="line">GET /centent/_search?q=title:123*&amp;size=0</span><br><span class="line"># 有没有文档匹配某个查询(terminated_early)</span><br><span class="line">GET /centent/_search?q=title:1234*&amp;size=0&amp;terminate_after=1</span><br><span class="line"># match和term的区别：match查询的时候,elasticsearch会根据你给定的字段提供合适的分析器,而term查询不会有分析器分析的过程，match查询相当于模糊匹配,只包含其中一部分关键词就行</span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_source&quot;: false,</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;title&quot; : &quot;123&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 查询全部</span><br><span class="line">GET /book/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 排序</span><br><span class="line">GET /book/_search </span><br><span class="line">&#123;&quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;name&quot; : &quot; java&quot;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">    &quot;sort&quot;: [</span><br><span class="line">        &#123; &quot;price&quot;: &quot;desc&quot; &#125;</span><br><span class="line">    ]&#125;</span><br><span class="line"># 分页</span><br><span class="line">GET  /book/_search </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">&#125;</span><br><span class="line"># 指定返回的字段</span><br><span class="line">GET /book/_search </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;, &quot;studymodel&quot;]</span><br><span class="line">&#125;</span><br><span class="line"># 匹配指定条件查询</span><br><span class="line">GET /test_index/_search </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;test_field&quot;: &quot;test&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-返回数据详解"><a href="#2-3-返回数据详解" class="headerlink" title="2.3 返回数据详解"></a>2.3 返回数据详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 97, #请求耗时多少毫秒</span><br><span class="line">  &quot;timed_out&quot; : false, #是否超时。默认情况下没有超时机制，也就是客户端等待Elasticsearch搜索结束（无论执行多久），提供超时机制的话，Elasticsearch则在指定时长内处理搜索，在指定时长结束的时候，将搜索的结果直接返回（无论是否搜索结束）。指定超时的方式是传递参数，参数单位是：毫秒-ms。秒-s。分钟-m。</span><br><span class="line">  &quot;_shards&quot; : &#123; # 分片</span><br><span class="line">    &quot;total&quot; : 1, #请求发送到多少个shard上</span><br><span class="line">    &quot;successful&quot; : 1, #成功返回搜索结果的shard</span><br><span class="line">    &quot;skipped&quot; : 0, #停止服务的shard</span><br><span class="line">    &quot;failed&quot; : 0 #失败的shard</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123; #匹配记录数</span><br><span class="line">    &quot;total&quot; : &#123; #返回了多少结果</span><br><span class="line">      &quot;value&quot; : 3,</span><br><span class="line">      &quot;relation&quot; : &quot;eq&quot; # 关系</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot; : 1.0, #搜索结果中，最大的相关度分数，相关度越大分数越高，_score越大，排位越靠前</span><br><span class="line">    &quot;hits&quot; : [ #搜索到的结果集合，默认查询前10条数据。</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;centent&quot;, #数据所在索引</span><br><span class="line">        &quot;_type&quot; : &quot;centent&quot;, #数据所在类型</span><br><span class="line">        &quot;_id&quot; : &quot;4&quot;, #数据的id</span><br><span class="line">        &quot;_score&quot; : 1.0, #数据的搜索相关度分数</span><br><span class="line">        &quot;_source&quot; : &#123; # 数据的具体内容。</span><br><span class="line">          &quot;id&quot; : 4,</span><br><span class="line">          &quot;title&quot; : &quot;***&quot;,</span><br><span class="line">          &quot;content&quot; : &quot;***&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在linux环境装了一个elasticsearch，遇到了好几个问题，还有一些笔记，记录一下，后面以后安装的时候方便快速解决。</summary>
    
    
    
    <category term="tool" scheme="https://gaoqisen.github.io/categories/tool/"/>
    
    
    <category term="elasticsearch" scheme="https://gaoqisen.github.io/tags/elasticsearch/"/>
    
  </entry>
  
</feed>
