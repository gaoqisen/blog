<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Learning Record</title>
  
  <subtitle>Welcome to Gao Qisen&#39;s blog.</subtitle>
  <link href="https://gaoqisen.github.io/atom.xml" rel="self"/>
  
  <link href="https://gaoqisen.github.io/"/>
  <updated>2021-06-06T02:09:13.026Z</updated>
  <id>https://gaoqisen.github.io/</id>
  
  <author>
    <name>Gao Qisen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《代码整洁之道》</title>
    <link href="https://gaoqisen.github.io/book/TheCleanCoder.html"/>
    <id>https://gaoqisen.github.io/book/TheCleanCoder.html</id>
    <published>2021-06-05T02:10:11.000Z</published>
    <updated>2021-06-06T02:09:13.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-专业主义"><a href="#第一章-专业主义" class="headerlink" title="第一章 专业主义"></a>第一章 专业主义</h3><h4 id="1-1清楚你要什么"><a href="#1-1清楚你要什么" class="headerlink" title="1.1清楚你要什么"></a>1.1清楚你要什么</h4><p>清楚自己负责的是什么，并为自己收拾残局</p><h4 id="1-2-担当责任"><a href="#1-2-担当责任" class="headerlink" title="1.2 担当责任"></a>1.2 担当责任</h4><p>自己写的代码要对它负责，如果有bug需要自己去负责，不要推卸责任。并且需要想清楚为什么会有这个bug，现在如何更好的解决这个bug，以及以后如何防止相同的事情发生</p><h4 id="1-3-职业道德"><a href="#1-3-职业道德" class="headerlink" title="1.3  职业道德"></a>1.3  职业道德</h4><ol><li>需要了解自己的领域：必须精通设计模式、设计原则、方法（结构化分析、瀑布模型等）、实践（测试驱动开发、面向对象设计、持续集成）、工件（UML图、结构图）。</li><li>坚持学习：与时俱进，学习不同的语言</li><li>练习：歌手练习声音、医生联系手术缝合、音乐家练习音阶</li><li>合作：一起编程、一起计划、一起练习、一起设计、一起合作。也需要学会独处</li><li>辅导：辅导新人的同时自己也会受益</li><li>了解业务领域：如果不了解业务是写不出好的程序的，需要花时间去了解业务</li><li>与顾客保持一致：雇主的问题就是你的问题。必须弄清楚问题，并找到最佳解决方案。</li><li>谦虚：专业人士都知道自己也会摔跟头，不要因别人犯错了就对之横加贬损，因为自己很可能就是下一个犯错的人。如果遇到挫折最好的办法就是一笑而过，并在上面长个心眼</li></ol><h3 id="第二章-说“不”"><a href="#第二章-说“不”" class="headerlink" title="第二章 说“不”"></a>第二章 说“不”</h3><p>能就是能，不能就是不能。不要说“试试看”。– 尤达</p><h4 id="2-1-对抗角色"><a href="#2-1-对抗角色" class="headerlink" title="2.1 对抗角色"></a>2.1 对抗角色</h4><p>竭尽所能的捍卫自身的目标，如果无法完成任务就要勇于说“不”，也要勇于对抗，不能为达目的不择手段。“为什么”远不如“事实”重要。为什么是一个细节问题。不能因为各种原因而去省略重要的步骤</p><h4 id="2-2-高风险是时刻"><a href="#2-2-高风险是时刻" class="headerlink" title="2.2 高风险是时刻"></a>2.2 高风险是时刻</h4><p>最要说“不”的时候就是那些高风险的时刻。越是关键时刻，“不”字就越具有价值</p><h4 id="2-3-要有团队精神"><a href="#2-3-要有团队精神" class="headerlink" title="2.3 要有团队精神"></a>2.3 要有团队精神</h4><p>有团队精神的人，不会永远说是。那些事情做得到，那些事情做不到一定要分清楚，做不到的事情一定要讲出来，不能自信过头。</p><ol><li>试试看： 没有“试试看”这回事，尝试的意思就是“付出额外的精力”</li><li>消极对抗：一辆火车冲向大家，只有你一个人有所察觉，你可以选择自己轻轻抽身到马路边，眼睁睁看着其他人被车碾过，也可以选择大喊：“车来了，快离开”</li></ol><h4 id="2-4-说“是”的成本"><a href="#2-4-说“是”的成本" class="headerlink" title="2.4 说“是”的成本"></a>2.4 说“是”的成本</h4><p>大多数情况下，我们都希望说是。一个故事：部门招标1个月时间做一个系统，然后a公司中标了。b成员负责项目的开发，时间特别赶b成员同意做此项目。他没日没夜的加班，没有全部用硬编码方式完成了这个项目，自己还沾沾自喜的认为干了一件特别了不起的事情。结果之后部门来了个新领导砍掉了这个项目，而去在项目开发期间还加了一些其他的功能。</p><h4 id="2-5-如何写出好代码"><a href="#2-5-如何写出好代码" class="headerlink" title="2.5 如何写出好代码"></a>2.5 如何写出好代码</h4><p>有可能写出好的代码吗？有可能坚守专业主义的精神吗？在项目特别赶的情况下就可以硬编码，不管设计原则吗？其实想要写出好的代码就需要学会如何说“不”。</p><h3 id="第三章-说“是”"><a href="#第三章-说“是”" class="headerlink" title="第三章 说“是”"></a>第三章 说“是”</h3><h4 id="3-1-承诺用语"><a href="#3-1-承诺用语" class="headerlink" title="3.1 承诺用语"></a>3.1 承诺用语</h4><p>做出承诺的步骤</p><ol><li>口头上说</li><li>心里认真对待做出的承诺</li><li>真正付诸行动</li></ol><h5 id="3-1-1-识别“缺乏承诺”的征兆"><a href="#3-1-1-识别“缺乏承诺”的征兆" class="headerlink" title="3.1.1 识别“缺乏承诺”的征兆"></a>3.1.1 识别“缺乏承诺”的征兆</h5><ol><li>需要/应当：我需要减肥。有人应当负责某某事情</li><li>希望/但愿：希望明天能完成任务。但愿明天有时间</li><li>让我们：让我们把事情做完</li></ol><h5 id="3-1-2-真正的承诺是怎样的"><a href="#3-1-2-真正的承诺是怎样的" class="headerlink" title="3.1.2 真正的承诺是怎样的"></a>3.1.2 真正的承诺是怎样的</h5><p>我将在…之前…完成任务。</p><ol><li>之所以没有成功，是因为我寄需求于某某去做这件事：比如这件事依赖于其他团队，这种情况应该提前就采取行动，提前预估风险</li><li>之所以没有成功，是因为我不太确信是否正的能够完成：即使目标无法完成，你任然要不留余力的前进，离目标要更近一些</li><li>之所以没有成功，是因为有些时候我真的无能为力：遇到这种情况的时候要及时向承诺对象发出预警<strong>越夸越好</strong>！</li></ol><h4 id="3-2-学习如何说“是”"><a href="#3-2-学习如何说“是”" class="headerlink" title="3.2 学习如何说“是”"></a>3.2 学习如何说“是”</h4><ol><li>“试试”的另一面：试试意味着“仍然有余力可施”</li><li>坚守原则：彻底不要出现“如果…或许…”，也不要冒险放弃原则，比如不写测试用例等。专业人士对自己的能力极限了如指掌，清楚的知道如果保持效率的加班能持续多久，也明白要付出的代价</li></ol><p>专人人士不需要对所有请求都回答“是”。不过，他们应该努力寻找创新的方法，尽可能做到有求必应。如果给出了肯定的回答，就要使用正式的承诺。</p><h3 id="第四章-编码"><a href="#第四章-编码" class="headerlink" title="第四章 编码"></a>第四章 编码</h3><h4 id="4-1-做好准备"><a href="#4-1-做好准备" class="headerlink" title="4.1 做好准备"></a>4.1 做好准备</h4><ol><li>代码必须能够正常工作</li><li>代码必须能够帮助你解决客户提出的问题</li><li>代码必须和现有的系统结合的天衣无缝</li><li>其他程序必须能看懂你写的代码</li></ol><ul><li>凌晨3点写出的代码：疲劳的时候千万不要写代码，要确保自己已经将睡眠、健康和生活方式调整到最好的状况</li><li>焦虑时写下的代码：焦虑的时候建议可以花点时间让自己安静下来，不要硬逼自己写代码，不然很容易写出以后不得不抛弃的代码</li></ul><h4 id="4-2-流态区"><a href="#4-2-流态区" class="headerlink" title="4.2 流态区"></a>4.2 流态区</h4><p>高效率状态会出现“绝无错误”的误区，这种状态会为了追求所谓的速度理性思考的能力会下降。建议可以结对编程</p><ul><li>音乐：听音乐并没有帮助“我”专注编码，反而会消耗一部分脑力资源</li><li>中断：中断无法避免，发生这种情况的时候要想一下，自己也可能回去打扰别人，乐于助人的态度就是专注的态度。</li></ul><h4 id="4-3-阻塞"><a href="#4-3-阻塞" class="headerlink" title="4.3 阻塞"></a>4.3 阻塞</h4><p>无法写出代码的时候建议结对编程会有意想不到的收获</p><ul><li>创造性输入：广泛阅读各种资料来激励自己去创造</li></ul><h4 id="4-4-调试"><a href="#4-4-调试" class="headerlink" title="4.4 调试"></a>4.4 调试</h4><p>真正调试的时候往往是大于编码的时间的，建议使用“测试驱动开发”可以有效的减少调试时间。医生不喜欢重新打开病人的胸腔去修复此前犯下的错误、律师不喜欢复杂之前搞砸过的案子、同样写代码如果写的更多的是bug也是不专业的</p><h4 id="4-5-保持节奏"><a href="#4-5-保持节奏" class="headerlink" title="4.5 保持节奏"></a>4.5 保持节奏</h4><p>知道何止应该离开一会： 当遇到问题感到疲倦的时候可以离开一会，调整一下精力后才会更好。</p><h4 id="4-6-进度延迟"><a href="#4-6-进度延迟" class="headerlink" title="4.6 进度延迟"></a>4.6 进度延迟</h4><p>管理延迟的诀窍： 早期检测和保持透明</p><ol><li>期望：如果计划的是12天开发周期，那么不要期望自己能10天完成，否则期望会导致大麻烦。不要让其他任何人对此抱有期望</li><li>盲目冲刺：快速冲刺是做不到的，要明确的告诉老板，让他们不要有这种期望</li><li>加班加点：如果没有加班失败的后备方案，建议不要同意接受加班方案</li><li>交付失误：明知道没有完成任务却说完成了任务</li><li>定义完成：要说清楚完成的情况，是代码编写完成了还是自测完成，还是对接完成了</li></ol><h4 id="4-7-帮助"><a href="#4-7-帮助" class="headerlink" title="4.7 帮助"></a>4.7 帮助</h4><ol><li>帮助他人： 互相帮助是每个程序员的指责所在，要以能帮助他人为荣</li><li>接受让人的帮助：如果有人向你伸出援手，要诚挚接受，心怀感激的接受帮助并诚意合作。不要应该自己压力大而推开伸来的援手。</li><li>辅导：向深资导师寻求辅导也是程序员的专业指责</li></ol><h3 id="第五章-测试驱动开发"><a href="#第五章-测试驱动开发" class="headerlink" title="第五章 测试驱动开发"></a>第五章 测试驱动开发</h3><h4 id="5-1-此事已有定论"><a href="#5-1-此事已有定论" class="headerlink" title="5.1 此事已有定论"></a>5.1 此事已有定论</h4><p>TDD不仅仅是一种用于缩短编码周期的简单技巧。结论很清楚，每个开发人员都需要掌握TDD</p><h4 id="5-2-TDD的三项法则"><a href="#5-2-TDD的三项法则" class="headerlink" title="5.2 TDD的三项法则"></a>5.2 TDD的三项法则</h4><ol><li>在写好失败的单元测试之前，不要写任何产品代码</li><li>只要有一个单元测试失败了就不要写测试代码了，无法通过编译的也是失败的情况</li><li>产品代码恰好能够让当前失败的单元测试代码通过即可，无需多写</li></ol><h4 id="5-3-TDD的优势"><a href="#5-3-TDD的优势" class="headerlink" title="5.3 TDD的优势"></a>5.3 TDD的优势</h4><ol><li>确定性： 代码有任何修改，都需要运行全部测试</li><li>缺陷注入率：有不少研究称TDD能显著较低缺陷</li><li>勇气：看到有坏味道的代码就可以马上修改，应该TDD给你了勇气</li><li>文档：单元测试就是文档，每个单元测试都是一个调用示例</li><li>设计：遵循三项法则能够产生一种驱动力，促使你做出松耦合的设计</li></ol><h4 id="5-4-局限"><a href="#5-4-局限" class="headerlink" title="5.4 局限"></a>5.4 局限</h4><p>在某些情况下的三项法则是不切实际的，这种情况很少，如果弊大于利就不要使用它</p><h3 id="第六章-练习"><a href="#第六章-练习" class="headerlink" title="第六章 练习"></a>第六章 练习</h3><h4 id="6-1-引子"><a href="#6-1-引子" class="headerlink" title="6.1 引子"></a>6.1 引子</h4><p>没门编程语言都它的hello world。这也是第一个练习，练习能够带来协调的开发节奏。无论是搏斗还是编程，速度都来源于练习</p><h4 id="6-2-编程柔道场"><a href="#6-2-编程柔道场" class="headerlink" title="6.2 编程柔道场"></a>6.2 编程柔道场</h4><ol><li>卡塔：类似于编程小游戏，训练自己</li><li>自由练习：不限制形式的搏击</li></ol><h4 id="6-3-自身经验拓展"><a href="#6-3-自身经验拓展" class="headerlink" title="6.3 自身经验拓展"></a>6.3 自身经验拓展</h4><ol><li>开源：可以在开源网址上去贡献代码</li><li>练习的职业道德：不要在上班的时候进行练习，老板的职责不包括避免你的技术落伍</li></ol><p>无论何时，专业人士都需要练习。</p><h3 id="第七章-验收测试"><a href="#第七章-验收测试" class="headerlink" title="第七章 验收测试"></a>第七章 验收测试</h3><h4 id="7-1-需求的沟通"><a href="#7-1-需求的沟通" class="headerlink" title="7.1 需求的沟通"></a>7.1 需求的沟通</h4><ol><li>过早精细化：经常愿意花大代价追求这种不现实的精确性<ul><li>不确定原则：需求完成的越精细，就越容易被忽视。业务想看到和开发看到的不一致</li><li>预估焦虑：需求是一定会变化的，追求精确性是徒劳的</li></ul></li><li>迟来的模糊性：需求的不确定性会让开发和测试都搞错需求</li></ol><h4 id="7-2-验收测试"><a href="#7-2-验收测试" class="headerlink" title="7.2 验收测试"></a>7.2 验收测试</h4><ol><li>完成的定义：不同的团队的完成对定义是不相同的</li><li>沟通：验收测试的目的是沟通、澄清、精确化。开发方、业务方、测试方都要达成共识</li><li>自动化：验收测试都应该自动进行，手动执行的都要考虑成本</li><li>额外工作：大量的测试用例不是额外的工作，只有确定了细节指标才可以避免开发误入岐途</li><li>验收测试什么时候写，由谁写：通常会交给业务分析人员、QA或者开发人员。如果是开发人员尽量不让写代码的人和开发的人是同一个人</li><li>开发人员的角色：开发人员有责任吧验收测试与系统联系起来，让测试通过</li><li>测试的协商与被动推进：测试也是普通人，也会犯错误。如果发现测试用例有问题要及时沟通改进</li><li>验收测试和单元测试：验收测试是业务方写给业务方的。单元测试是程序员写给程序员的。</li><li>图形界面及其他复杂因素：尽可能减少GUI测试，GUI测试越多后期维护的难度就越大</li><li>持续集成：持续集成不应该失败，如果失败了团队所有人应该都要停止干活，先让测试先通过</li></ol><h3 id="第八章-测试策略"><a href="#第八章-测试策略" class="headerlink" title="第八章 测试策略"></a>第八章 测试策略</h3><h4 id="8-1-QA应该找不到任何错误"><a href="#8-1-QA应该找不到任何错误" class="headerlink" title="8.1 QA应该找不到任何错误"></a>8.1 QA应该找不到任何错误</h4><p>开发小组应该把【QA找不到任何错误】当成努力的目标</p><ol><li>QA也是团队的一部分：他是团队中需求定义者和特性描述者</li><li>需求规约定义者：编写针对极端情况、边界状态、异常路径的测试</li></ol><h4 id="8-2-自动化测试金字塔"><a href="#8-2-自动化测试金字塔" class="headerlink" title="8.2 自动化测试金字塔"></a>8.2 自动化测试金字塔</h4><p>人工探索式测试 &gt; 系统测试 &gt; 集成测试 &gt; 组件测试 &gt; 单元测试</p><ol><li>单元测试：程序员自己编写的测试，应该要接近100%的覆盖率，通常要达到90%以上</li><li>组件测试： 针对系统的各个组件编写的，封装了业务规则（QA 和业务人员编写）</li><li>集成测试：对组件很多的大型系统才有意义</li><li>系统测试： 对整个集成完毕的系统进行的自动化测试包含吞吐率和性能测试等</li><li>人工探索式测试： 确保在人工操作下表现良好，同时有创造性的尽可能多的找到“古怪之处”</li></ol><h3 id="第九章-时间管理"><a href="#第九章-时间管理" class="headerlink" title="第九章 时间管理"></a>第九章 时间管理</h3><h4 id="9-1-会议"><a href="#9-1-会议" class="headerlink" title="9.1 会议"></a>9.1 会议</h4><p>会议是必须的、会议浪费了大量的时间</p><ol><li>拒绝： 理智的使用时间，谨慎的选择需要参加的会议，礼貌的拒绝一些不必要的会议</li><li>离席：如果你明白继续待在会议室会浪费时间可以找合适的机会商量如何离席</li><li>确认议程与目标：务必弄清楚议题是什么，花多长时间，取得什么成果</li><li>立会：每个人回答不超过1分钟（昨天干了什么，今天打算干什么，遇到了什么问题）</li><li>迭代计划会议：会议的节奏要快，每个任务应该限制在5-10分钟之内，如果不够应该另选时间专人专门讨论</li><li>迭代回顾和demo展示： 看最新的工作成果的demo可以在最后一周的最后一天下班前45分钟召开，前20分钟回顾，后25分钟展示</li><li>争论/反对：如果观点无法在5-30分钟之内达成一致，就永远无法达成一致，出路是用数据说话</li></ol><h4 id="9-2-注意力点数"><a href="#9-2-注意力点数" class="headerlink" title="9.2 注意力点数"></a>9.2 注意力点数</h4><p>注意力是稀缺的资源如果注意力用光了需要1个小时或更多的时间去补充，可以在注意力不够的时候做其他事情。</p><ol><li>睡眠：充足的睡眠可以保证好的注意力</li><li>咖啡因：适当的咖啡可以保持注意力</li><li>恢复： 注意力耗尽可以自己沉思一会，或者小睡一会</li><li>肌肉注意力：转移注意力到肌肉注意力上面可以提升心智注意力</li></ol><h4 id="9-3-时间拆分和番茄工作法"><a href="#9-3-时间拆分和番茄工作法" class="headerlink" title="9.3 时间拆分和番茄工作法"></a>9.3 时间拆分和番茄工作法</h4><p>给自己设定25分钟，25分钟之内无论什么干扰都需要在25分钟之后在处理，没4个番茄时间段之后休息30分钟</p><h4 id="9-4-要避免的行为"><a href="#9-4-要避免的行为" class="headerlink" title="9.4 要避免的行为"></a>9.4 要避免的行为</h4><p>专业开发人员会评估每个任务的优先级，排除个人的喜好和需要，按照正式的紧急程度来执行任务</p><h4 id="9-5-死胡同"><a href="#9-5-死胡同" class="headerlink" title="9.5 死胡同"></a>9.5 死胡同</h4><p>比如选择了走不通的技术道路越是坚持浪费的时间就越多，专业的开发人员会保持开放的头脑来听取其他意见 ，即使走到尽头，他们仍然有其他选择</p><h4 id="9-6-泥潭"><a href="#9-6-泥潭" class="headerlink" title="9.6 泥潭"></a>9.6 泥潭</h4><p>专业人员时刻留意显露出来的泥潭，然后各种努力，尽快脱身。在泥潭中继续前进时不易察觉的，要及时修正设计。</p><h3 id="第十章-预估"><a href="#第十章-预估" class="headerlink" title="第十章 预估"></a>第十章 预估</h3><h4 id="10-1-什么是预估"><a href="#10-1-什么是预估" class="headerlink" title="10.1 什么是预估"></a>10.1 什么是预估</h4><p>开发认为预估是猜测，业务认为预估是承诺</p><ol><li>承诺：如果你承诺某事，就必须按时完成，不兑现承诺就是一种欺骗</li><li>预估：它不包含任何承诺</li><li>暗示性承诺：试试看就是暗示性承诺，尽量不要使用</li></ol><h4 id="10-2-PERT"><a href="#10-2-PERT" class="headerlink" title="10.2 PERT"></a>10.2 PERT</h4><p>一种避免乐观的项目估计的合理方法</p><h4 id="10-3-预估任务"><a href="#10-3-预估任务" class="headerlink" title="10.3 预估任务"></a>10.3 预估任务</h4><p>一组人集合起来重复进行讨论-预估的过程，知道意见统一</p><ol><li>亮手指： 用大家的手指精细预估</li><li>规划扑克：用成员的扑克点数进行预估</li><li>关联预估：任务写在卡片上按照规则进行预估</li><li>三元预估： 用三种预估得出概率分布的一种方法</li></ol><h4 id="10-4-大数定律"><a href="#10-4-大数定律" class="headerlink" title="10.4 大数定律"></a>10.4 大数定律</h4><p>把大任务分成多个小任务，分开预估在加总，结果会比单独评估大任务要准确很多</p><h3 id="第十一章-压力"><a href="#第十一章-压力" class="headerlink" title="第十一章 压力"></a>第十一章 压力</h3><h4 id="11-1-避免压力"><a href="#11-1-避免压力" class="headerlink" title="11.1 避免压力"></a>11.1 避免压力</h4><ol><li>承诺：如果没有兑现承诺导致业务失败的压力</li><li>保持整洁：代码设计的整洁可以避免压力，混乱会降低速度，导致工期延误、承诺失信</li><li>危机中的纪律：当困境降临时，不要改好的行为。如：赶工期的时候要保证代码质量</li></ol><h4 id="11-2-应对压力"><a href="#11-2-应对压力" class="headerlink" title="11.2 应对压力"></a>11.2 应对压力</h4><ol><li>不要惊慌失措：放松下来，多想一下问题，努力寻找就会带来好的结果</li><li>沟通：请求团队其他成员或者主管，避免产生惊恐</li><li>依靠你的纪律原则：战胜压力的方式就是依靠你已经知道的切实有效的东西-纪律</li><li>需求帮助：结对编程可以制止你的精神错乱</li></ol><h3 id="第十二章-协作"><a href="#第十二章-协作" class="headerlink" title="第十二章 协作"></a>第十二章 协作</h3><h4 id="12-1-程序员与人"><a href="#12-1-程序员与人" class="headerlink" title="12.1 程序员与人"></a>12.1 程序员与人</h4><ol><li>程序员与雇主：要端正态度，准守规章制度</li><li>程序员与程序员<ul><li>代码个体所有：自己的代码自己维护和其他同事不沟通，拥有大量重复的代码</li><li>协作性的代码共有权：打破隔断，相互合作</li><li>结对：结对编程是复查代码最好的方式</li></ul></li></ol><p>一定要学会交流–和大家交流</p><h3 id="第十三章-团队与项目"><a href="#第十三章-团队与项目" class="headerlink" title="第十三章 团队与项目"></a>第十三章 团队与项目</h3><h4 id="13-1-只是简单混合吗"><a href="#13-1-只是简单混合吗" class="headerlink" title="13.1 只是简单混合吗"></a>13.1 只是简单混合吗</h4><ol><li>有凝聚力的团队<ul><li>发酵期：一起计划、一起解决问题、一起面对问题、一起搞定一切</li><li>团队和项目，何者为先：专业的开发组织把项目分配给有凝聚力的团队</li></ul></li><li>如何管理有凝聚力的团队：可以给团队设置目标值</li></ol><h3 id="第十四章-辅导、学徒期与技艺"><a href="#第十四章-辅导、学徒期与技艺" class="headerlink" title="第十四章 辅导、学徒期与技艺"></a>第十四章 辅导、学徒期与技艺</h3><p>软件学徒期</p><ol><li>大师：一半拥有10年以上的从业经验，他们懂得如何领导和协调多个团队，他们是熟练的设计师和架构师</li><li>熟练工：能胜任工作，并且精力充沛，他们会学习如何在团队中卓越的工作和成为团队的领导者</li><li>学徒/实习生：刚开始进入自己的职业生涯，他们需要熟练工的督导。他们应该至少持续一年的实习期</li></ol><p>技艺中包含着价值观、原则、技术、态度、正见。工匠知道何时该说不，他们懂得如何做出承诺，成熟的工匠才能算是专业人士。</p><p>​         </p>]]></content>
    
    
    <summary type="html">整理了一下代码整洁之道的每章的大致内容，加深一下影像。</summary>
    
    
    
    <category term="book" scheme="https://gaoqisen.github.io/categories/book/"/>
    
    
    <category term="code" scheme="https://gaoqisen.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>五一成都</title>
    <link href="https://gaoqisen.github.io/life/chengdu.html"/>
    <id>https://gaoqisen.github.io/life/chengdu.html</id>
    <published>2021-05-03T13:30:11.000Z</published>
    <updated>2021-06-01T13:03:37.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在五一假期来临的前一天决定了去成都。这次的成员有我、妈妈、堂弟。</p><h3 id="出行方式"><a href="#出行方式" class="headerlink" title="出行方式"></a>出行方式</h3><p>两种方式：跟团、自游。考虑了一下时间，也想到不用急急忙忙的安排时间去玩。于是确定了座火车去成都。</p><h3 id="出现路线"><a href="#出现路线" class="headerlink" title="出现路线"></a>出现路线</h3><p>初略计划路线: 春熙路 &gt; 锦里 &gt; 宽窄巷子 &gt; 青城山 &gt; 都江堰。之后沙大大贡献了一张手写攻略。将路线改为春熙路 &gt; 锦里 &gt; 宽窄巷子 &gt; 熊猫基地 &gt; 青城山 &gt; 都江堰。 </p><h3 id="车票问题"><a href="#车票问题" class="headerlink" title="车票问题"></a>车票问题</h3><p>路线确定好后就是购买车票，这个时间订票就比较困难了，看了一圈12306都没有合适的票。之后看到有个火车票在17:40出发，11:47到达成都东站(买票时是成都东站，订票成功之后就是成都站)，于是和妈妈沟通之后果断购买了该车次的火车票。</p><h3 id="住宿问题"><a href="#住宿问题" class="headerlink" title="住宿问题"></a>住宿问题</h3><p>火车票定好之后，就是住宿的问题，由于5月1日晚上11:47才到站。所以必须先定好住宿的地方，下火车之后就可以直接休息了。订票的几个关键点就是东站附近，价格适中，我们三个人住宿开始计划的是订两个房间，我和我堂弟一间，我妈妈一间。然后就开始下载app（携程旅行、美团），在里面搜索符合自己条件的酒店/民宿。花了两个小时也还是没有找到合适的。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="准备前"><a href="#准备前" class="headerlink" title="准备前"></a>准备前</h3><p>由于票是定在下午5点40的，因此上午还是有大把的时间可以准备的。于是上午我整理了一下房间，把该洗的衣服都洗好了。快10点多的时候我堂弟就拉着行李箱抵达到了我住的地方，12点左右的时候我妈妈带了一包炒黄豆（吃多了放屁的那种），还有一包炸熟了的腊肉和一箱牛奶出现在了楼下。（前一天晚上就跟我妈妈说不要带东西，去玩的时候带东西背着很累，作为老一辈勤俭持家的典范，她还是义无反顾的带上了），我也是像往常一样数落了一番。</p><h3 id="看房子"><a href="#看房子" class="headerlink" title="看房子"></a>看房子</h3><p>一看时间还早我们也没有吃午饭，于是商量之后决定先去买房子的地方（三亚湾）去看下，到了三亚湾去吃了个沙县小吃，然后围着还没修好的小区外面走了一圈。还没修好的小区看着总觉得破破烂烂的，工地旁边的车子停放的乱七八糟，凹凸不平的马路也没有休整，只有快交房的3期才看着像房子的样子。绕着整个小区走一圈还是有点费劲的，何况正午的太阳正是最热的时候，我的衬衫后背都全部汗湿了。买了瓶水之后我们就回到我住的地方了，休息了半个多小时（玩手机）我们就是出发去北站坐火车了。</p><h3 id="火车出发了"><a href="#火车出发了" class="headerlink" title="火车出发了"></a>火车出发了</h3><p>在车站玩了1小时的手机之后，17:40分的时候我们从重庆北站正式出发了。之后就是长达5小时的火车之旅，一路上有人下车，有人上车。有人侃侃而谈，有人沉默不语。一会有美丽的风景从眼前呼啸而过，一会有深不可测的隧道让人短暂沉默。在车上除了玩手机，就是把头撇向窗口。天黑了之后就只剩下玩手机和焦急看看还有多久才能到达终点。大概8点的时候我们拿出了在楼下买好的酸菜面，泡上了我妈妈炸好的腊肉也加了一些炒好的黄豆。于是我正儿八经的坐在椅子上津津有味的吃了起来，我估计坐在我对面的一个大兄弟一定也想来一碗。在吃的时候我问我堂弟和妈妈要吃吗？他们都说不饿，于是我就自己先泡了吃。吃了一半的时候我堂弟也去泡了面。我问我妈妈要吃吗，她还是说不饿。在堂弟泡好快吃的时候我说“妈妈我给你泡吧!”, 这次她没有说不饿，于是我去加好了水（准备把腊肉放在里面一起泡的，她说干吃好吃一些），泡好之后她也静静有味的吃了起来。现在想起来她是不是早就饿了，还是其他什么原因呢？我想不明白。我们打扫完小桌子之后，又安静的等待火车抵达的那一刻了。9点左右对面的大兄弟在咨询了盒饭25元一份之后果断的选择了7元一碗的泡面，他在津津有味的吃泡面的时候，却不知道吃饱了的我也是一点也吃不下了。我看向了黑漆漆的窗外，好像没有方向一样，不知道终点在哪里。</p><h3 id="东站？"><a href="#东站？" class="headerlink" title="东站？"></a>东站？</h3><p>晚上11点47我们抵达了终点成都站，下车后我妈妈开始拍照片。我就给我们定好的名宿老板打电话。“你好，我到成都东站了。”，“好的，你们直接在a酒店来”，“是b酒店吗？”，“不是”，“是c d e酒店吗？”，“不是，你们是在成都东站吗”，“稍等我看下地图”。好家伙，我们总算发现火车抵达的是成都站，住宿的地方是在成都东站。问了下老板怎么去东站，老板说假期的地铁往后延迟了，可以去做地铁，还不算晚。本来我们应该飞一般的奔向地铁的，奈何我们当中没有一个人着急，慢慢悠悠的走到的地铁里面，支付宝切换为成都扫码后就上了地铁。我堂弟没满18岁用不了支付宝去买票花了10分钟（其实没有这么久，可能只有5分钟吧！可是我分明觉得买了很久，哈哈～～～）。坐上车的那一刻，突然感觉终点好远，之后就是长达1小时的地铁之旅。</p><h3 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h3><p>在12点的时候我们实实在在到达了终点，名宿老板带我们过了一个红绿灯和一条马路之后就到小区门口了，进小区大门的时候还需要登记刷脸才能入住，刷脸还总是不过，我骂了句垃圾系统，大概也是10分钟左右才进到小区里面吧！洗漱之后就是快速的躺下入睡 了。我堂弟还睡的比较香，我还是日常失眠，睡不着，隔壁有人神经病一样的敲墙壁，迷迷糊糊的不知道从几点开始还是睡着了几个小时（五一假期的第一天过去了）。</p><h3 id="熊猫基地"><a href="#熊猫基地" class="headerlink" title="熊猫基地"></a>熊猫基地</h3><p>第二天醒来的洗漱完成之后，处理碗肥肠粉就就去做公交车了。有直达熊猫基地的车10元每人，做这个车子的人还是挺多的，一路上都没有座位，这是一趟直达的公交车，路途中间一共停留了两次。在快要到熊猫基地的时候堵了一会车，那个时候已经9点多了。在快要下公交车的时候就已经看到人山人海了，之后我们就找入口进去。在进去的时候整个广场上都排满了，人挤人。这是我第一次经历这么多人排队的时候。之前最多的时候也就是排队买票，但是这次真的是特别的挤。人太多了工作人员就会进行限流，拦住人群让前面的人先走一会。每次放人进去的时候每个人都想快一步进去，就会听到有人说“在挤就要发生踩踏事件了，不要挤了”。在这样经历了3次之后，我们总算进到了正式排队的地方（很多栏杆隔开像迷宫迷宫一样的广场，用来限流）。之后等待了20多分钟，总算是进到了熊猫基地里面。在里面看了一下官方推荐的地图就先去了天鹅湖围着天鹅湖走了一圈，看到了一只天鹅，我妈妈去拍了一张照片。这个时候的天气已经热起来了，我的衬衫已经汗湿了紧紧的贴着我的皮肤。而我们也满怀期待的在这个陌生的环境行走，想要去看大熊猫，小熊猫。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
    
    
    <summary type="html">五一假期已经过去大半的时间，在假期期间去了成都旅游了一圈。乘着还没有忘记所有的事情，回忆一下这个成都之旅。</summary>
    
    
    
    <category term="life" scheme="https://gaoqisen.github.io/categories/life/"/>
    
    
    <category term="life" scheme="https://gaoqisen.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>审核流学习</title>
    <link href="https://gaoqisen.github.io/java/view_flow.html"/>
    <id>https://gaoqisen.github.io/java/view_flow.html</id>
    <published>2021-02-06T06:23:52.000Z</published>
    <updated>2021-05-31T14:31:05.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、案例分析"><a href="#一、案例分析" class="headerlink" title="一、案例分析"></a>一、案例分析</h2><ol><li>有两个审核组（审核组1、审核组2）、每组有两个审核成员（审核组1- a，b。审核组2- c，d）</li><li>当有数据需要审核初始化审核组的时候，如数据a需要审核组1和审核组2进行审核。则初始化两条审核信息</li><li>初始数据只有审核组1的成员可以查看并且审核，审核组1审核通过之后审核组2才能查看和审核数据到审核数据。审核组2审核的时候，审核组1只能查看并不能操作审核数据。</li><li>当前用户去查询列表的时候，需要先去查找自己的数据权限。如果有权限则进行展示。（代办事项）</li></ol><p>sql初始化成功之后，进行代码开发。</p><h2 id="二、接口设计"><a href="#二、接口设计" class="headerlink" title="二、接口设计"></a>二、接口设计</h2><h3 id="2-1-创建审核流程接口（初始化审核流）"><a href="#2-1-创建审核流程接口（初始化审核流）" class="headerlink" title="2.1 创建审核流程接口（初始化审核流）"></a>2.1 创建审核流程接口（初始化审核流）</h3><ol><li>逻辑：根据审核类型关联flow_review_rule、flow_rule_group、flow_review_group获取审核类型所需要的审核组并创建审核流程</li><li>入参: 审核唯一编码、审核类型、用户ID…</li></ol><h3 id="2-2-流程列表查询接口（代办事项）"><a href="#2-2-流程列表查询接口（代办事项）" class="headerlink" title="2.2 流程列表查询接口（代办事项）"></a>2.2 流程列表查询接口（代办事项）</h3><ol><li>入参:  产品编码、用户ID、开始时间和结束时间</li><li>逻辑：<ol><li>通过用户ID去查询用户所在的审核组，如果没有审核组则直接返还空数据</li><li>通过审核组和业务类型分页获取当前用户可以审核的流程审核表里面的数据</li><li>用业务类型获取业务系统的dubbo接口</li><li>通过dubbo接口和分页获取的审核唯一编码泛化调用业务系统，获取业务系统的列表数据</li><li>组装审核信息后返还给前端</li></ol></li></ol><p>通用的业务审核列表。只是展示需要审核的数据</p><h3 id="2-3-流程审核查询（查看审核情况）"><a href="#2-3-流程审核查询（查看审核情况）" class="headerlink" title="2.3 流程审核查询（查看审核情况）"></a>2.3 流程审核查询（查看审核情况）</h3><ol><li>入参: 审核唯一编码、业务类型</li><li>逻辑: 通过审核唯一编码查询审核流程表和审核流程记录表并组装数据后返回给前端</li></ol><h3 id="2-4-流程审核接口（判断是否有审核权限）"><a href="#2-4-流程审核接口（判断是否有审核权限）" class="headerlink" title="2.4 流程审核接口（判断是否有审核权限）"></a>2.4 流程审核接口（判断是否有审核权限）</h3><ol><li>入参: 审核唯一编码、审核人员ID、审核结果、驳回资料等、当前审核流程ID、审核类型</li><li>逻辑：<ol><li>判断审核情况是通过还是拒绝，如果是拒绝则通过审核类型调用业务系统（用户中心or订单中心）审核接口进行拒绝操作。</li><li>如果是通过则判断当前审核流程是否是最后一个审核流程，如果是最后一个流程则通过审核类型调用业务系统（用户中心or订单中心）审核接口进行审核。</li><li>修改流程表里面当前流程流状态</li><li>在审核流程记录表里面添加记录</li></ol></li></ol><p>审核通过、审核拒绝时调用</p><h3 id="2-5-流程数据修改接口（判断是否有权限修改）"><a href="#2-5-流程数据修改接口（判断是否有权限修改）" class="headerlink" title="2.5 流程数据修改接口（判断是否有权限修改）"></a>2.5 流程数据修改接口（判断是否有权限修改）</h3><h2 id="三、数据库表设计"><a href="#三、数据库表设计" class="headerlink" title="三、数据库表设计"></a>三、数据库表设计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- 用户和组的关联表</span><br><span class="line">create table flow_group_user(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    group_id bigint(20) not null comment &apos;组ID&apos;,</span><br><span class="line">    user_id bigint(20) not null comment &apos;用户ID&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;用户和组的关联表&apos;;</span><br><span class="line">-- 审核组</span><br><span class="line">create table flow_review_group(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    name varchar(100) not null comment &apos;审核组名称&apos;,</span><br><span class="line">    `desc` varchar(300) default null comment &apos;审核组名称&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;审核组&apos;;</span><br><span class="line">-- 审核表（一条审核记录对应多条审核操作操作记录）为了展示所有的审核详情</span><br><span class="line">create table flow_review(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    review_no bigint(20) not null comment &apos;审核码&apos;,</span><br><span class="line">    rule_id bigint(20) not null comment &apos;规则ID&apos;,</span><br><span class="line">    review_status varchar(2) not null comment &apos;审核状态 0-待审核,1-审核中,2-审核成功,3-审核失败&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;审核表&apos;;</span><br><span class="line"></span><br><span class="line">-- 审核操作记录表</span><br><span class="line">create table flow_review_operate(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    review_no bigint(20) not null comment &apos;审核码&apos;,</span><br><span class="line">    review_parent_id bigint(20) not null comment &apos;审核父ID&apos;,</span><br><span class="line">    review_status varchar(2) not null comment &apos;审核状态 0-待审核,1-审核成功,2-审核失败&apos;,</span><br><span class="line">    `desc` varchar(300) default null comment &apos;审核描述&apos;,</span><br><span class="line">    review_group_id bigint(20) not null comment &apos;审核组ID&apos;,</span><br><span class="line">    review_user_id bigint(20) not null comment &apos;审核用户ID&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;审核操作记录表&apos;;</span><br><span class="line">-- 审核规则</span><br><span class="line">create table flow_review_rule(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    name bigint(50) not null comment &apos;名称&apos;,</span><br><span class="line">    `type` varchar(2) not null comment &apos;类型: 0-用户,1-订单,2-实名制&apos;,</span><br><span class="line">    `desc` varchar(300) default null comment &apos;描述&apos;,</span><br><span class="line">    request_type varchar(2) not null comment &apos;请求类型1-dubbo,2-http&apos;,</span><br><span class="line">    class_name varchar(300) default null comment &apos;类名&apos;,</span><br><span class="line">    class_method varchar(300) default null comment &apos;类方法&apos;,</span><br><span class="line">    class_method_args varchar(300) default null comment &apos;类方法参数&apos;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;审核规则&apos;;</span><br><span class="line">-- 规则和组关联表</span><br><span class="line">create table flow_rule_group(</span><br><span class="line">    id bigint(20) auto_increment key comment &apos;自增ID&apos;,</span><br><span class="line"></span><br><span class="line">    group_id bigint(20) not null comment &apos;组ID&apos;,</span><br><span class="line">    rule_id bigint(20) not null comment &apos;规则ID&apos;,</span><br><span class="line">    is_modify varchar(2) not null comment &apos;是否修改0-不修改, 1-修改&apos;,</span><br><span class="line">    is_review varchar(2) not null comment &apos;请求审核0-不审核, 1-审核&apos;,</span><br><span class="line"></span><br><span class="line">    create_user_id bigint(20) comment &apos;创建用户ID&apos;,</span><br><span class="line">    create_date timestamp null default current_timestamp comment &apos;创建时间&apos;,</span><br><span class="line">    modify_user_id bigint(20) comment &apos;修改用户ID&apos;,</span><br><span class="line">    modify_date timestamp null default current_timestamp on update current_timestamp comment &apos;修改时间&apos;</span><br><span class="line">) comment &apos;规则和组关联表&apos;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">学习一下审核流，整理一下思路</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="Java flow" scheme="https://gaoqisen.github.io/tags/Java-flow/"/>
    
  </entry>
  
  <entry>
    <title>简单的权限管理小工具详细设计</title>
    <link href="https://gaoqisen.github.io/java/webCenter2.0.html"/>
    <id>https://gaoqisen.github.io/java/webCenter2.0.html</id>
    <published>2020-12-09T12:50:11.000Z</published>
    <updated>2020-12-13T02:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 通用的核心类</span><br><span class="line">webcenter-core</span><br><span class="line">// 提供的接口</span><br><span class="line">webcenter-api</span><br><span class="line">// 只要的业务逻辑，项目通过集成core、api、admin即可实现简单的单系统权限框架</span><br><span class="line">webcenter-admin</span><br><span class="line">// 审核流，项目集成core、api、admin、review接口实现审核流功能</span><br><span class="line">webcenter-review</span><br><span class="line">// 控制台，项目通过集成core、api、admin、console即可实现web中心的单点登录功能</span><br><span class="line">webcenter-console</span><br><span class="line">// 提供ui页面</span><br><span class="line">webcenter-webpage</span><br></pre></td></tr></table></figure><h2 id="二、项目流程"><a href="#二、项目流程" class="headerlink" title="二、项目流程"></a>二、项目流程</h2><p><img src="https://gaoqisen.github.io/GraphBed/202012/20201212175908.png" alt="https://gaoqisen.github.io/GraphBed/202012/20201212175908.png"></p><p>一个用户多个角色</p><p>一个部门，多个角色(包含当前部门和当前部门子部门的所有权限)</p><p>一个用户一个部门，一个角色(用户拥有所有角色的并集权限)</p><p>一个角色多个菜单和权限<br><img src="https://gaoqisen.github.io/GraphBed/202012/20201212180556.png" alt="https://gaoqisen.github.io/GraphBed/202012/20201212180556.png"></p><h2 id="三、功能点"><a href="#三、功能点" class="headerlink" title="三、功能点"></a>三、功能点</h2><h3 id="webcenter-admin"><a href="#webcenter-admin" class="headerlink" title="webcenter-admin"></a>webcenter-admin</h3><ol><li>权限管理</li><li>用户管理</li><li>角色管理</li><li>菜单管理</li><li>流程审核</li></ol><h3 id="webcenter-console"><a href="#webcenter-console" class="headerlink" title="webcenter-console"></a>webcenter-console</h3><h4 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h4><p>用于给系统初始化client_id等参数，其它自系统必须通过初始化的参数进行系统的配置。</p><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>主要是进行接口的管理，给进行权限的控制，防止没有权限的用户进行接口的攻击</p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>用户体系都用同一套。用户通过单点登录获取用户和权限信息等。</p><h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h4><p>给角色可以添加不同系统的不同菜单，和不同的权限</p><h4 id="菜单管理"><a href="#菜单管理" class="headerlink" title="菜单管理"></a>菜单管理</h4><p>菜单管理实现增加系统ID参数，通过系统ID区分不同的系统有不同的菜单。</p><h2 id="四、实现方式"><a href="#四、实现方式" class="headerlink" title="四、实现方式"></a>四、实现方式</h2><ol><li>通过导入依赖和增加数据库即可实现，简单的登陆注册、权限管理等</li><li>以一种插件的方式去集成</li></ol><h2 id="五、接口详细设计"><a href="#五、接口详细设计" class="headerlink" title="五、接口详细设计"></a>五、接口详细设计</h2><h3 id="5-1-webcenter-admin"><a href="#5-1-webcenter-admin" class="headerlink" title="5.1 webcenter-admin"></a>5.1 webcenter-admin</h3><p>用户的增删改查</p><p>角色的增删改查</p><p>菜单的增删改查</p><p>权限的查询（增加通过系统启动的时候初始化到数据库）</p><p>登录接口</p><p>退出接口</p><p>密码修改接口</p><p>菜单查询接口</p><p>验证码获取接口</p><h2 id="5-2-webcenter-console"><a href="#5-2-webcenter-console" class="headerlink" title="5.2 webcenter-console"></a>5.2 webcenter-console</h2><p>单点登录接口(登录后返回用户的权限、菜单等信息)</p><p>退出接口</p><p>系统的增删改查接口</p><p>菜单通过系统区分</p><p>用户角色的权限分配区分系统</p><h2 id="5-3-webcenter-review"><a href="#5-3-webcenter-review" class="headerlink" title="5.3 webcenter-review"></a>5.3 webcenter-review</h2>]]></content>
    
    
    <summary type="html">GQS-WEBCENTER, 一个轻量级的WEB中心。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java springBoot" scheme="https://gaoqisen.github.io/tags/java-springBoot/"/>
    
  </entry>
  
  <entry>
    <title>开发中一些常见的需要避免的问题</title>
    <link href="https://gaoqisen.github.io/java/codeIssue.html"/>
    <id>https://gaoqisen.github.io/java/codeIssue.html</id>
    <published>2020-12-05T08:22:40.000Z</published>
    <updated>2021-01-17T21:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、接口重放问题"><a href="#一、接口重放问题" class="headerlink" title="一、接口重放问题"></a>一、接口重放问题</h2><h3 id="1-1-影响"><a href="#1-1-影响" class="headerlink" title="1.1 影响"></a>1.1 影响</h3><p>同一个接口调用多次（请求原封不动的多次发送）导致出现重复数据。</p><h3 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2 解决办法"></a>1.2 解决办法</h3><p>利用时间戳(判断时间必须当前时间的60s以内)＋随机串（通过redis进行缓存校验查询，判断随机串是否出现过）</p><h2 id="二、平行越权问题"><a href="#二、平行越权问题" class="headerlink" title="二、平行越权问题"></a>二、平行越权问题</h2><h3 id="2-1-影响"><a href="#2-1-影响" class="headerlink" title="2.1 影响"></a>2.1 影响</h3><p>攻击者可以执行同级别的其它用户可以执行的权限，比如攻击者可以自己登陆之后修改其它用户的信息等</p><h3 id="2-2-解决办法"><a href="#2-2-解决办法" class="headerlink" title="2.2 解决办法"></a>2.2 解决办法</h3><p>每个阶段都通过cookie和sessin等进行用户身份的校验</p><h2 id="三、短信轰炸问题"><a href="#三、短信轰炸问题" class="headerlink" title="三、短信轰炸问题"></a>三、短信轰炸问题</h2><h3 id="3-1-影响"><a href="#3-1-影响" class="headerlink" title="3.1 影响"></a>3.1 影响</h3><ol><li>公司短信发送多余，产生经济损失。2. 造成用户收到垃圾短信</li></ol><h3 id="3-2-解决办法"><a href="#3-2-解决办法" class="headerlink" title="3.2 解决办法"></a>3.2 解决办法</h3><p>短信频率限制（1分钟获取一次等），添加图形验证码（防止爬虫通过接口发送验证码）</p><h2 id="四、铭感信息隐藏"><a href="#四、铭感信息隐藏" class="headerlink" title="四、铭感信息隐藏"></a>四、铭感信息隐藏</h2><p>隐藏手机号码、邮箱等敏感信息</p><h2 id="五、分布式锁"><a href="#五、分布式锁" class="headerlink" title="五、分布式锁"></a>五、分布式锁</h2><h3 id="5-1-数据库锁"><a href="#5-1-数据库锁" class="headerlink" title="5.1 数据库锁"></a>5.1 数据库锁</h3><h4 id="5-1-1-乐观锁"><a href="#5-1-1-乐观锁" class="headerlink" title="5.1.1 乐观锁"></a>5.1.1 乐观锁</h4><p>乐观锁一般都乐观的认为数据不会被锁，</p><ol><li><p>在读取数据的时候把数据的版本号一起读出，更新数据的时候使用数据版本号进行数据的更新，如果更新失败了则重新读取数据后再次更新如: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tablesname set data = #&#123;data&#125;, version = #&#123;version&#125; +1 where id = #&#123;id&#125; and version = #&#123;version&#125;</span><br></pre></td></tr></table></figure></li><li><p>也是增加一个字段用来保存时间戳，查询数据的时候把时间戳也查询出来。更新的是判断时间戳是否是一致的</p></li></ol><h4 id="5-1-2-悲观锁"><a href="#5-1-2-悲观锁" class="headerlink" title="5.1.2 悲观锁"></a>5.1.2 悲观锁</h4><p>悲观锁是悲观的认为所有的数据都会出现被锁的情况，故有表锁、行锁、读锁、写锁等，直接数据库层面的锁属于重量级的锁</p><h3 id="5-2-redis锁"><a href="#5-2-redis锁" class="headerlink" title="5.2 redis锁"></a>5.2 redis锁</h3><p>利用redis的setnx去增加锁(setnx只有当key在redis中不存在的时候才能设置成功)，通过expire去释放锁来实现。在代码中判断setnx是否成功，如果成功了则表示锁是空闲状态，否则锁处于占用状态</p><p>l</p><h3 id="5-3-redission"><a href="#5-3-redission" class="headerlink" title="5.3 redission"></a>5.3 redission</h3><h3 id="5-4-zookeeper"><a href="#5-4-zookeeper" class="headerlink" title="5.4 zookeeper"></a>5.4 zookeeper</h3><h2 id="六、分布式事务"><a href="#六、分布式事务" class="headerlink" title="六、分布式事务"></a>六、分布式事务</h2>]]></content>
    
    
    <summary type="html">在开发中经常会遇到的一些问题，都是公司Master强调需要注意的地方。在开发中也要避免这种情况。这里整理一下，加深自己的记忆力。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://gaoqisen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java一些常用的类</title>
    <link href="https://gaoqisen.github.io/java/commom.html"/>
    <id>https://gaoqisen.github.io/java/commom.html</id>
    <published>2020-08-16T12:50:11.000Z</published>
    <updated>2021-06-06T07:35:52.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BeanCopier"><a href="#BeanCopier" class="headerlink" title="BeanCopier"></a>BeanCopier</h2><p>拷贝两个对象,网上资料显示: BeanCopier的性能是PropertyUtils (apache-common)的504倍。PropertyUtils的性能是BeanUtils(apache-common)的1.71倍,因此对象的拷贝尽量使用BeanCopier。注意属性没有提供set方法，只是提供了get方法是会报错的，无法复制属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝对象， 在create对象的时候会出现性能瓶颈，可以将创建的过程放在缓存中，方便直接获取</span></span><br><span class="line">BeanCopier copier = BeanCopier.create(FromEntity.class, ToEntity.class, <span class="keyword">false</span>);  </span><br><span class="line">ToEntity to = <span class="keyword">new</span> ToEntity();  </span><br><span class="line">copier.copy(from, to, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 总条数</span></span><br><span class="line"><span class="keyword">int</span> totalRow = <span class="number">101</span>;</span><br><span class="line"><span class="comment">// 每页记录数</span></span><br><span class="line"><span class="keyword">int</span> pageSize = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 总页数</span></span><br><span class="line"><span class="keyword">int</span> totalPage = (totalRow - <span class="number">1</span>) / pageSize + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; totalPage; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> start = i * pageSize;</span><br><span class="line"><span class="keyword">int</span> end = Math.min((i + <span class="number">1</span>) * pageSize, totalRow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分页助手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PageTemplateHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 总条数</span></span><br><span class="line">        <span class="keyword">int</span> totalRow = <span class="number">50</span>;</span><br><span class="line">        <span class="comment">// 每页记录数</span></span><br><span class="line">        <span class="keyword">int</span> pageSize = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 总页数</span></span><br><span class="line">        <span class="keyword">int</span> totalPage = (totalRow - <span class="number">1</span>) / pageSize + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; totalPage; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> total = execute(i + <span class="number">1</span>, pageSize);</span><br><span class="line">            <span class="keyword">if</span>(total != totalPage) &#123;</span><br><span class="line">                totalRow = total;</span><br><span class="line">                totalPage = (totalRow - <span class="number">1</span>) / pageSize + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法,引入函数式方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initTemplage</span><span class="params">(PageTemplateHelper pageTemplate)</span> </span>&#123;</span><br><span class="line">  pageTemplate.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">initTemplage((start, end) -&gt; &#123;</span><br><span class="line">  System.out.println(start, end);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="AOP注解"><a href="#AOP注解" class="headerlink" title="AOP注解"></a>AOP注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Before 切入点开始处切入内容</span></span><br><span class="line"><span class="comment">// @After 切入点结尾处切入内容</span></span><br><span class="line"><span class="comment">// @AfterReturning 切入点return内容之后切入内容</span></span><br><span class="line"><span class="comment">// @Around在切入点前后切入内容，并自己控制何时执行切入点自身的内容</span></span><br><span class="line"><span class="comment">// @AfterThrowing用来处理当切入内容部分抛出异常之后的处理逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line">     <span class="keyword">try</span>&#123;  </span><br><span class="line">         doBefore();<span class="comment">//对应@Before注解的方法切面逻辑  </span></span><br><span class="line">         method.invoke();  </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">         doAfter();<span class="comment">//对应@After注解的方法切面逻辑  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     doAfterReturning();<span class="comment">//对应@AfterReturning注解的方法切面逻辑  </span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(Exception e)&#123;  </span><br><span class="line">      doAfterThrowing();<span class="comment">//对应@AfterThrowing注解的方法切面逻辑  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录一些新的语法和自己不经常使用的方法，方便自己以后使用</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java base" scheme="https://gaoqisen.github.io/tags/java-base/"/>
    
  </entry>
  
  <entry>
    <title>一些面试题</title>
    <link href="https://gaoqisen.github.io/study/interview.html"/>
    <id>https://gaoqisen.github.io/study/interview.html</id>
    <published>2020-07-18T06:43:40.000Z</published>
    <updated>2020-08-11T18:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、索引问题"><a href="#一、索引问题" class="headerlink" title="一、索引问题"></a>一、索引问题</h2><h3 id="1-1-从数据结构角度"><a href="#1-1-从数据结构角度" class="headerlink" title="1.1 从数据结构角度"></a>1.1 从数据结构角度</h3><ol><li>B+Tree索引: 适用于查找范围内的数据</li><li>hash索引: 适用于随机访问的场合，查找每条数据的时间都是一样的。</li><li>Fulltext索引: 查找文本中的关键字。</li><li>R-Tree索引: 查询比较接近的数据</li></ol><h3 id="1-2-物理存储角度"><a href="#1-2-物理存储角度" class="headerlink" title="1.2 物理存储角度"></a>1.2 物理存储角度</h3><ol><li><p>聚集索引: 表数据按照索引的顺序来存储</p><p>InnoDB的主键使用的就是聚簇索引，MyISAM不管是主键还是二级索引都是使用的非聚簇索引。</p></li><li><p>非聚集索引: 表数据存储顺序与索引的顺序无关</p></li></ol><h3 id="1-3-逻辑角度"><a href="#1-3-逻辑角度" class="headerlink" title="1.3 逻辑角度"></a>1.3 逻辑角度</h3><ol><li>主键索引:  </li><li>普通索引和单列索引: 唯一的任务就是加快数据的访问速度</li><li>多列索引: 符合最左原则: key index(a,b,c)相当于创建了三个索引a,ab,abc。不支持bc索引。</li><li>唯一索引: 允许有空值，索引列的值必须唯一</li><li>空间索引</li></ol><h3 id="1-2-聚簇索引"><a href="#1-2-聚簇索引" class="headerlink" title="1.2 聚簇索引"></a>1.2 聚簇索引</h3><h2 id="二、Mysql的引擎对比"><a href="#二、Mysql的引擎对比" class="headerlink" title="二、Mysql的引擎对比"></a>二、Mysql的引擎对比</h2><h3 id="2-1-InnoDB"><a href="#2-1-InnoDB" class="headerlink" title="2.1 InnoDB"></a>2.1 InnoDB</h3><p>支持事务、支持外键、支持崩溃修复能力和并发控制、支持行级锁和表级锁</p><h3 id="2-2-MyISAM"><a href="#2-2-MyISAM" class="headerlink" title="2.2 MyISAM"></a>2.2 MyISAM</h3><p>插入速度快、空间和内存使用比较低、只支持表级锁。不支持事务，安全性不高</p><h2 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h2><p>单独学习: <a href="https://gaoqisen.github.io/java/classloader.html">https://gaoqisen.github.io/java/classloader.html</a></p><h2 id="四、HashMap原理"><a href="#四、HashMap原理" class="headerlink" title="四、HashMap原理"></a>四、HashMap原理</h2><ol><li><p>通过key的hashCode经过扰动函数处理过后得到hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扰动函数: 使用扰动函数可以减少碰撞，防止不同的hashcode的高位不同但低位相同导致的hash冲突</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// key.hashCode(): 返回的就是散列值就是hashcode</span></span><br><span class="line">  <span class="comment">// ^: 的意思就是按位异或</span></span><br><span class="line">  <span class="comment">// &gt;&gt;&gt;: 无符号右移，忽略符号位，空位用0补齐</span></span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>通过(n-1)&amp;hash判断当前元素存在的位置，如果当前位置已经存在值则对比key是否一样，如果一样就替换值，如果不一样就通过拉链法解决冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">// 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line"><span class="comment">// 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">       <span class="comment">// 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，这里的相同指的是hashCode以及equals</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">       <span class="comment">// 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line"><span class="comment">// // 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>拉链法: 将链表和数组结合，如果遇到hash冲突就将值放到链表中</p><p>JDK1.8: 当链表的长度大于阀值(默认8)之后，将链表转为了红黑树减少搜索时间。</p></blockquote><h2 id="五、排序算法原理"><a href="#五、排序算法原理" class="headerlink" title="五、排序算法原理"></a>五、排序算法原理</h2><p>Arrays.sort(list.toArray());源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    legacyMergeSort(a);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// Tim优化后的归并排序</span></span><br><span class="line">    ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-legacyMergeSort-a-源码"><a href="#5-1-legacyMergeSort-a-源码" class="headerlink" title="5.1 legacyMergeSort(a)源码"></a>5.1 legacyMergeSort(a)源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** To be removed in a future release. 在以后的版本中会删除*/</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">legacyMergeSort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">      Object[] aux = a.clone();</span><br><span class="line">      mergeSort(aux, a, <span class="number">0</span>, a.length, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>mergeSort(aux, a, 0, a.length, 0);归并算法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Object[] src,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Object[] dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> low,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> high,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> off)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> length = high - low;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果数组长度小于INSERTIONSORT_THRESHOLD(7),直接用插入排序</span></span><br><span class="line">      <span class="comment">// Insertion sort on smallest arrays</span></span><br><span class="line">      <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class="line">                       ((Comparable) dest[j-<span class="number">1</span>]).compareTo(dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">                  swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">      <span class="comment">// Recursively sort halves of dest into src</span></span><br><span class="line">      <span class="keyword">int</span> destLow  = low;</span><br><span class="line">      <span class="keyword">int</span> destHigh = high;</span><br><span class="line">      low  += off;</span><br><span class="line">      high += off;</span><br><span class="line">      <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      mergeSort(dest, src, low, mid, -off);</span><br><span class="line">      mergeSort(dest, src, mid, high, -off);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class="line">      <span class="comment">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class="line">      <span class="keyword">if</span> (((Comparable)src[mid-<span class="number">1</span>]).compareTo(src[mid]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          System.arraycopy(src, low, dest, destLow, length);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Merge sorted halves (now in src) into dest</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=<span class="number">0</span>)</span><br><span class="line">              dest[i] = src[p++];</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              dest[i] = src[q++];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-ComparableTimSort-sort源码"><a href="#5-2-ComparableTimSort-sort源码" class="headerlink" title="5.2 ComparableTimSort.sort源码"></a>5.2 ComparableTimSort.sort源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本质是插入排序和归并排序的结合体</span></span><br><span class="line">  <span class="comment">// 1.是稳定的排序算法，最坏时间复杂度为O(N*log(N))</span></span><br><span class="line"><span class="comment">// 2.对小块进行插入排序，然后进行归并排序</span></span><br><span class="line"><span class="comment">// TimSort算法是由Tim Peters在2002提出并首先实现在了phtyon中，是结合了合并排序（merge sort）和插入排序（insertion sort）的一种高效稳定的算法。算法原理看这里 https://blog.csdn.net/yangzhongblog/article/details/8184707</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Object[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 保证数组的合法性</span></span><br><span class="line"><span class="keyword">assert</span> a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">      <span class="comment">// 对于只有0|1个元素的数组，不需要进行排序</span></span><br><span class="line">      <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">          <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line"><span class="comment">// 如果数组长度小于32个则调用binarySort，二分插入排序</span></span><br><span class="line">      <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">        <span class="comment">// 计算数组头部递增或递减的的序列长度，如果是递减，则翻转，保持升序</span></span><br><span class="line">          <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line">        <span class="comment">// 使用二叉插入排序对在initRunLen后的元素进行排序</span></span><br><span class="line">          binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * March over the array once, left to right, finding natural runs,</span></span><br><span class="line"><span class="comment">       * extending short natural runs to minRun elements, and merging runs</span></span><br><span class="line"><span class="comment">       * to maintain stack invariant.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ComparableTimSort ts = <span class="keyword">new</span> ComparableTimSort(a, work, workBase, workLen);</span><br><span class="line">      <span class="comment">// 计算最小run的长度</span></span><br><span class="line"><span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// Identify next run</span></span><br><span class="line">        <span class="comment">// 计算当前排序的run的长度，如果为递减数组则翻转</span></span><br><span class="line">          <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">        <span class="comment">// 如果当前run的长度小于minRun，则进行扩展，在扩展过程中使用二叉排序来排序扩展的的元素</span></span><br><span class="line">          <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">              <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">              binarySort(a, lo, lo + force, lo + runLen);</span><br><span class="line">              runLen = force;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">          <span class="comment">// 将此run放入栈中</span></span><br><span class="line">        ts.pushRun(lo, runLen);</span><br><span class="line">        <span class="comment">// 执行合并逻辑，合并的时候也做了一些优化</span></span><br><span class="line">          ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Advance to find next run</span></span><br><span class="line">          lo += runLen;</span><br><span class="line">          nRemaining -= runLen;</span><br><span class="line">      &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">      <span class="keyword">assert</span> lo == hi;</span><br><span class="line"><span class="comment">// 保证最后的run都被合并</span></span><br><span class="line">      ts.mergeForceCollapse();</span><br><span class="line">      <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>binarySort原码(二叉插入排序)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">      <span class="keyword">if</span> (start == lo)</span><br><span class="line">          start++;</span><br><span class="line">      <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">          Comparable pivot = (Comparable) a[start];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">          <span class="keyword">int</span> left = lo;</span><br><span class="line">          <span class="keyword">int</span> right = start;</span><br><span class="line">          <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * Invariants:</span></span><br><span class="line"><span class="comment">           *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">           *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">              <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (pivot.compareTo(a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                  right = mid;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  left = mid + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">           * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">           * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">           * first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">           * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">          <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">          <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">          &#125;</span><br><span class="line">          a[left] = pivot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="六、ConcurrentHashMap原理"><a href="#六、ConcurrentHashMap原理" class="headerlink" title="六、ConcurrentHashMap原理"></a>六、ConcurrentHashMap原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 不允许插入空值，否则报错空指针</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">      <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 更新元素是使用的CAS机制，需要不断尝试，直到成功为止</span></span><br><span class="line">      <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f：链表或红黑二叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。</span></span><br><span class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 判断Node[]数组是否初始化，没有则进行初始化操作</span></span><br><span class="line">          <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">              tab = initTable();</span><br><span class="line">        <span class="comment">// 通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                           <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                  <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 检查到内部正在移动元素（Node[] 数组扩容）</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// //帮助它扩容</span></span><br><span class="line">              tab = helpTransfer(tab, f);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 锁住链表或红黑二叉树的头结点</span></span><br><span class="line">              <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 判断f是否是链表的头结点</span></span><br><span class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果fh&gt;=0 是链表节点</span></span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表所有节点</span></span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                              K ek;</span><br><span class="line">                            <span class="comment">// 如果节点存在，则更新value</span></span><br><span class="line">                              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                  ((ek = e.key) == key ||</span><br><span class="line">                                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                  oldVal = e.val;</span><br><span class="line">                                  <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                      e.val = value;</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                            <span class="comment">// 不存在则在链表尾部添加新节点。</span></span><br><span class="line">                              Node&lt;K,V&gt; pred = e;</span><br><span class="line">                              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                  pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                  <span class="keyword">break</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                    <span class="comment">// TreeBin是红黑二叉树节点</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                          Node&lt;K,V&gt; p;</span><br><span class="line">                          binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 添加树节点</span></span><br><span class="line">                          <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                         value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                              oldVal = p.val;</span><br><span class="line">                              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                  p.val = value;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">                  <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                      treeifyBin(tab, i);</span><br><span class="line">                  <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                      <span class="keyword">return</span> oldVal;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 将当前ConcurrentHashMap的size数量+1</span></span><br><span class="line">      addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li><p>判断Node[]数组是否初始化，没有则进行初始化操作</p></li><li><p>通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。</p></li><li><p>检查到内部正在扩容，如果正在扩容，就帮助它一块扩容。</p></li><li><p>如果f!=null，则使用synchronized锁住f元素（链表/红黑二叉树的头元素）<br> 4.1 如果是Node(链表结构)则执行链表的添加操作。<br> 4.2 如果是TreeNode(树型结果)则执行树添加操作。</p></li><li><p>判断链表长度已经达到临界值8 就需要把链表转换为树结构。</p></li></ol><h2 id="七、秒杀库存问题"><a href="#七、秒杀库存问题" class="headerlink" title="七、秒杀库存问题"></a>七、秒杀库存问题</h2><ol><li>前端限制(防止普通用户): 用户只能请求一次，一次之后按钮变灰。限制用户只能在10分钟之内只能提交一次等，大概拦住了80%的请求。</li><li>防止接口重复调用(防止程序员写for循环): 同一个uid限制访问频度，60秒内请求的接口返回相同的页面(页面缓存)</li><li>后端限流: 异步处理、消息队列、并发限制.对于超过系统负载的请求，可以选择直接拒绝，以此来对系统进行保护，保证在极限压力的情况下，系统有合理范围内的处理能力</li><li>下单减库存: 用户下单的时候就减库存，这种情况会出现用户下单了但是不支付的情况</li><li>付款减库存: 用户支付之后减库存，这种情况会出现多个人下单了，但是付款的时候没有库存了。</li><li>预扣库存: 用户下单之后预先减去库存，之后提示用户2分钟之内进行付款，如果不支付就回滚数据不进行库存减少。</li><li>防止多并发时数据错误问题: 修改库存的时候，判断当前取回的库存在修改的时候是否一致。“Compare And Set”（CAS）</li></ol><h2 id="八、数据库锁"><a href="#八、数据库锁" class="headerlink" title="八、数据库锁"></a>八、数据库锁</h2><p>悲观锁: 认为别的线程会修改值</p><p>乐观锁: 认为别的线程不会修改值（cas）</p><p>如何防止锁表，数据库死锁问题</p><h2 id="九、如何自己实现削峰填谷、限流等"><a href="#九、如何自己实现削峰填谷、限流等" class="headerlink" title="九、如何自己实现削峰填谷、限流等"></a>九、如何自己实现削峰填谷、限流等</h2><p>令牌桶算法</p><h2 id="十、事务级别"><a href="#十、事务级别" class="headerlink" title="十、事务级别"></a>十、事务级别</h2><ol><li>未提交</li><li>已提交</li><li>可重复读</li><li>序列化</li></ol><h2 id="十一、消息队列积压500万条数据如何处理"><a href="#十一、消息队列积压500万条数据如何处理" class="headerlink" title="十一、消息队列积压500万条数据如何处理"></a>十一、消息队列积压500万条数据如何处理</h2><p>只能操作临时扩容，以更快的速度去消费数据</p><h2 id="十二、方法重写的注解的区别"><a href="#十二、方法重写的注解的区别" class="headerlink" title="十二、方法重写的注解的区别"></a>十二、方法重写的注解的区别</h2><ol><li><em>一般来说，写与不写没什么区别，JVM可以自识别</em> </li><li><em>写的情况下：即说明子类要覆盖基类的方法，基类必须存在方法 （控制类型public,protected，返回值，参数列表类型）与子类方法完成一致的方法，否则会报错（找不到被Override的方法）。</em>  </li><li><em>在不写@Override注解的情况下，当基类存在与子类各种条件都符合的方法时实现覆盖；如果条件不符合时，则是当成新定义的方法使用。</em> </li><li><em>所以如果想覆盖基类方法时，最好还是写上@Override注解，这样有利于编译器帮助检查错误</em></li></ol><h2 id="十三、Springboot和Spring的区别"><a href="#十三、Springboot和Spring的区别" class="headerlink" title="十三、Springboot和Spring的区别"></a>十三、Springboot和Spring的区别</h2><p>SpringBoot是在Spring上面封装的，简化了xml配置，使开发、测试、部署更加方便。SpringBoot有如下特点：</p><ol><li>嵌入式tomcat等</li><li>提供starters简化构建配置</li><li>尽可能自动化配置spring</li><li>使用java -jar 独立运行jar</li></ol><p>SpringBoot是基于Spring的一套快速开发整合包。</p><h2 id="十四、Web攻击"><a href="#十四、Web攻击" class="headerlink" title="十四、Web攻击"></a>十四、Web攻击</h2><h3 id="14-1-DDOS"><a href="#14-1-DDOS" class="headerlink" title="14.1 DDOS"></a>14.1 DDOS</h3><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS）分布式拒绝服务攻击、 发送大量的正确请求到服务端，让服务端收到海量的数据后处理不过来导致服务无法使用。</p><h3 id="14-2-CSRF"><a href="#14-2-CSRF" class="headerlink" title="14.2 CSRF"></a>14.2 CSRF</h3><p>跨站请求伪造（Cross-site request forgery，CSRF）。跨站点请求伪造。通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。</p><p>防范措施: </p><ol><li>检查referer首部字段，检查这个首部字段并要求请求来源的地址在同一个域名下</li><li>添加校验token，不通过cookie进行校验</li><li>输入验证码，重要接口增加验证码验证，用户输入正确验证码后方可操作，让用户明白自己当前的操作。</li></ol><h3 id="14-3-XSS攻击"><a href="#14-3-XSS攻击" class="headerlink" title="14.3 XSS攻击"></a>14.3 XSS攻击</h3><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。是最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><p>防范措施: </p><ol><li>将cookie设置为HttpOnly可以防止JavaScript脚本调用</li><li>过滤特殊字符,例如将script转为其它字符</li></ol><h3 id="14-4-SQL注入"><a href="#14-4-SQL注入" class="headerlink" title="14.4 SQL注入"></a>14.4 SQL注入</h3><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成</p><p>防范措施: </p><ol><li>mysql关键字过滤，不允许用户输入sql关键字</li><li>使用预编译sql语句，没有拼接的过程</li><li>mybatis使用#{}传入数据</li></ol><h2 id="十五、Redis的List是如何实现的"><a href="#十五、Redis的List是如何实现的" class="headerlink" title="十五、Redis的List是如何实现的"></a>十五、Redis的List是如何实现的</h2><p>是使用的链表数据结构存储的数据。</p><ul><li>版本3.2之前<ul><li>压缩列表ziplist</li><li>双向列表linked list</li></ul></li><li>版本3.2之后<ul><li>快速列表quicklist</li></ul></li></ul><h2 id="十六、程序运行慢生产如何调试"><a href="#十六、程序运行慢生产如何调试" class="headerlink" title="十六、程序运行慢生产如何调试"></a>十六、程序运行慢生产如何调试</h2><ol><li>查看数据库是否有锁表，如果有锁表排查是否是程序导致的，并kill掉锁表线程</li><li>查看服务器CPU是否过高，如果CPU过高可以通过jtask查看</li><li>判断程序是一直慢还是突然慢，通过nginx日志筛选是否有第三方恶意工具网站</li><li>排查程序是sql执行慢，还是程序逻辑处理太多。sql慢就进行sql优化，程序逻辑太多的话就进行缓存处理</li></ol><h2 id="十七、集群环境中功能Session如何实现共享"><a href="#十七、集群环境中功能Session如何实现共享" class="headerlink" title="十七、集群环境中功能Session如何实现共享"></a>十七、集群环境中功能Session如何实现共享</h2><ol><li>利用公共的区域存储session例如用redis存储session实现sesison共享</li><li>多台服务器的sesison进行同步比如多台tomcat的session进行同步</li><li>利用新的机制鉴权，不用cookie-session机制。</li></ol><h2 id="十八、什么是线程安全，非线程安全"><a href="#十八、什么是线程安全，非线程安全" class="headerlink" title="十八、什么是线程安全，非线程安全"></a>十八、什么是线程安全，非线程安全</h2><p>多个线程去操作同一个数据不会出现问题叫线程安全，会出现问题就是非线程安全</p><p><a href="https://github.com/gaoqisen/notes/blob/master/java/threadSecurity.md" target="_blank" rel="noopener">https://github.com/gaoqisen/notes/blob/master/java/threadSecurity.md</a></p><h2 id="十九、说一下观察者模式"><a href="#十九、说一下观察者模式" class="headerlink" title="十九、说一下观察者模式"></a>十九、说一下观察者模式</h2><p><a href="https://github.com/gaoqisen/notes/blob/master/patterm/observe.md" target="_blank" rel="noopener">https://github.com/gaoqisen/notes/blob/master/patterm/observe.md</a></p><h2 id="二十、Vue原理"><a href="#二十、Vue原理" class="headerlink" title="二十、Vue原理"></a>二十、Vue原理</h2><p>双向数据绑定的mvvm模式</p><p><a href="https://github.com/gaoqisen/notes/blob/master/web/vueBase.md" target="_blank" rel="noopener">https://github.com/gaoqisen/notes/blob/master/web/vueBase.md</a></p><h2 id="二十一、范式"><a href="#二十一、范式" class="headerlink" title="二十一、范式"></a>二十一、范式</h2><p>第一范式: 数据库表中的任何属性都是原子性的, 不可再分</p><p>第二范式:数据表里的非主属性都要和这个数据表的候选键有完全依赖关系. </p><p>第三范式: 在满足 2NF 的同时, 数据表中的非属性与候选键不存在传递依赖性.</p><h2 id="二十二、参考"><a href="#二十二、参考" class="headerlink" title="二十二、参考"></a>二十二、参考</h2><ol><li>hashmap: <a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></li><li>Arrays.sort: <a href="https://my.oschina.net/u/3286119/blog/2055991" target="_blank" rel="noopener">https://my.oschina.net/u/3286119/blog/2055991</a></li><li>ConCurrentHashMap: <a href="https://www.jianshu.com/p/d10256f0ebea" target="_blank" rel="noopener">https://www.jianshu.com/p/d10256f0ebea</a></li><li>redis list: <a href="https://zhuanlan.zhihu.com/p/102422311" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102422311</a></li><li>范式: <a href="https://bigmorebig.github.io/2019/08/07/SQL进阶/" target="_blank" rel="noopener">https://bigmorebig.github.io/2019/08/07/SQL%E8%BF%9B%E9%98%B6/</a></li><li>攻击: <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/攻击技术.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md</a></li></ol>]]></content>
    
    
    <summary type="html">最近面试了，遇到了好多不是很熟悉的面试题，故记录下来。</summary>
    
    
    
    <category term="study" scheme="https://gaoqisen.github.io/categories/study/"/>
    
    
    <category term="study" scheme="https://gaoqisen.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载的学习</title>
    <link href="https://gaoqisen.github.io/java/classloader.html"/>
    <id>https://gaoqisen.github.io/java/classloader.html</id>
    <published>2020-07-10T08:22:26.000Z</published>
    <updated>2020-07-14T06:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>类加载过程</p><p><img src="https://gaoqisen.github.io/GraphBed/202007/20200710125152.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200710125152.png"></p><ol><li><p>加载: 通过类加载器查找和导入Class文件</p></li><li><p>链接: 把类的二进制数据合并到JRE中</p><ul><li>验证：检查载入class文件数据的正确性，为了确保当前的Class文件符合java虚拟机的要求，并且不会危害虚拟机自身的安全（文件格式验证、元数据验证、字节码验证、符号引用验证）</li><li>准备：给类变量(被static修饰的变量)分配内存,实例变量在实例变量初始化的时候会随对象一起分配在堆中。</li><li>解析: 将符号引用(javap反编译的就是符号引用)转化为直接引用(是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄)的过程</li></ul></li><li><p>初始化: 类的静态变量，静态代码块等执行，类的构造器初始化操作等。虚拟机定义了5种会触发初始化的场景。</p><ul><li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行初始化，则要先触发初始化；    </p></li><li><p>使用java.lang.reflect包中的方法对类进行反射调用的时候；</p></li><li><p>初始化类时，若发现其父类还没有初始化，则先触发父类的初始化；</p></li><li><p>虚拟机启动的时候，虚拟机会先初始化用户指定的包含main()方法的那个类 </p></li><li><p>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p></li></ul></li></ol><h2 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h2><blockquote><p>加载阶段是开发期相对来说可控性比较强，该阶段既可以使用系统提供的类加载器完成，也可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式</p></blockquote><h3 id="2-1-加载过程"><a href="#2-1-加载过程" class="headerlink" title="2.1 加载过程"></a>2.1 加载过程</h3><ol><li>通过全限定名称取此类的二进制字节流</li><li>将字节流的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成这个class对象作为方法区数据的访问入口</li></ol><h3 id="2-2-JVM内置的ClassLoader"><a href="#2-2-JVM内置的ClassLoader" class="headerlink" title="2.2 JVM内置的ClassLoader"></a>2.2 JVM内置的ClassLoader</h3><ul><li>BootstrpClassLoader: 启动类加载器，顶层的加载器，c++实现，负责加载JAVA_HOME/lib目录下面的jar包和类或者被 <code>-Xbootclasspath</code>参数指定路径下的类</li><li>ExtensionClassLoader: 扩展类加载器，主要加载JAVA_HOME/lib/ext目录下面的jar包和类或者<code>java.ext.dirs</code>系统变量指定的jar包</li><li>AppClassLoader: 应用程序类加载器，面向用户的加载器，加载当前应用的classpath下的所有jar包和类。</li></ul><h3 id="2-3-双亲委派模型"><a href="#2-3-双亲委派模型" class="headerlink" title="2.3 双亲委派模型"></a>2.3 双亲委派模型</h3><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都不愿意干活，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这就是传说中的双亲委派模式。</p><p><img src="https://gaoqisen.github.io/GraphBed/202007/20200710162520.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200710162520.png"></p><ul><li><p>优势:</p><ol><li>避免重复的类加载，如果父类已经加载了子类就不会再次加载。</li><li>保证Java核心API不被篡改。比如黑客自定义了java.lang.String类，有了双亲委派模型后自定义的java.lang.String类就永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。</li></ol></li><li><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双亲委派模型的工作过程源码</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">            <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            <span class="comment">//父类加载器无法完成类加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If still not found, then invoke findClass in order to find the class</span></span><br><span class="line">            <span class="comment">//子加载器进行类加载 </span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        <span class="comment">//判断是否需要链接过程，参数传入</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-破坏双亲委派模型-深入理解java虚拟机"><a href="#2-4-破坏双亲委派模型-深入理解java虚拟机" class="headerlink" title="2.4 破坏双亲委派模型(深入理解java虚拟机)"></a>2.4 破坏双亲委派模型(深入理解java虚拟机)</h3><ul><li><p>向前兼容:  由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。</p></li><li><p>基础类调用用户的代码: 双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢? 这并非是不可能的事情，一个典型的例子便是JNDI服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能“认识”之些代码，该怎么办？为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI，JDBC，JCE，JAXB和JBI等。</p></li></ul><h2 id="三、自定义类加载器"><a href="#三、自定义类加载器" class="headerlink" title="三、自定义类加载器"></a>三、自定义类加载器</h2><h3 id="3-1-什么时候会需要自定义类加载器"><a href="#3-1-什么时候会需要自定义类加载器" class="headerlink" title="3.1 什么时候会需要自定义类加载器"></a>3.1 什么时候会需要自定义类加载器</h3><ol><li>加密: 在类需要加密的时候可以自定义类加载器，这样就可以在读取到密文的类之后在解密之后进行类加载</li><li>非标准来源的类: 比如字节码是从网络获取，或者从数据库中读取，就可以指定来源加载类</li><li>动态创建: 根据实际的情况进行进行动态的创建类</li></ol><h3 id="3-2-自定义类加载器"><a href="#3-2-自定义类加载器" class="headerlink" title="3.2 自定义类加载器"></a>3.2 自定义类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(ClassLoader parent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写findClass方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/jasongao/Desktop/People.class"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);</span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class</span></span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过File获取二进制流字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileChannel fc = fis.getChannel();</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);</span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = fc.read(by);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            by.flip();</span><br><span class="line">            wbc.write(by);</span><br><span class="line">            by.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"People"</span>, <span class="keyword">true</span>, customClassLoader);</span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写People类之后，用javac People.java即可生成class文件</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>类加载: <a href="https://juejin.im/post/5a810b0e5188257a5c606a85" target="_blank" rel="noopener">https://juejin.im/post/5a810b0e5188257a5c606a85</a></li><li>双亲委派模型优势: <a href="https://blog.csdn.net/weixin_38055381/article/details/80167881" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38055381/article/details/80167881</a></li><li>破坏双亲委派模型: <a href="https://juejin.im/post/5d7bbea8e51d4561c541a74f" target="_blank" rel="noopener">https://juejin.im/post/5d7bbea8e51d4561c541a74f</a></li><li>线程上下文: <a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">https://blog.csdn.net/yangcheng33/article/details/52631940</a></li></ul>]]></content>
    
    
    <summary type="html">关于类加载的一些学习。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://gaoqisen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>k8s命令记录</title>
    <link href="https://gaoqisen.github.io/linux/kubernetes.html"/>
    <id>https://gaoqisen.github.io/linux/kubernetes.html</id>
    <published>2020-07-02T10:10:11.000Z</published>
    <updated>2020-07-12T00:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、来源"><a href="#一、来源" class="headerlink" title="一、来源"></a>一、来源</h2><ul><li>Infrastructure as a Service 基础设施即服务(IaaS)</li><li>platform as a Service 平台即服务(PaaS)</li><li>Software as a Service 软件即服务(SaaS)</li></ul><h2 id="一、名词介绍"><a href="#一、名词介绍" class="headerlink" title="一、名词介绍"></a>一、名词介绍</h2><ul><li><p><strong>kubernetes</strong>: 开源的 Docker 容器编排系统，它可以调度计算集群的节点，动态管理上面的作业，保证它们按用户期望的状态运行。通过使用「labels」和「pods」的概念，Kubernetes 将应用按逻辑单元进行分组，方便管理和服务发现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">优势:</span><br><span class="line">1. 快速创建、部署、扩展应用</span><br><span class="line">2. 开发和运行相分离，资源隔离，资源利用更高效</span><br><span class="line">3. 无缝对接新的功能</span><br><span class="line">4. 节省资源，优化硬件资源的使用</span><br><span class="line">5. 自动重启、自动部署、自动复制、自动扩缩容</span><br><span class="line">6. 模块化、插件化、可挂载、可组合</span><br><span class="line">7. 持续开发、集成和部署</span><br><span class="line">8. 开发，测试和生产环境一致性</span><br><span class="line">9. 分布式，弹性，微服务化</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>pods</strong>: 是一组紧密关联的容器集合，它们共享 IPC(进程间通信)、Network(网络) 和 UTS namespace(UTS 命名空间是 Linux 命名空间的一个子系统，主要作用是完成对容器 Hostname 和 Domain 的隔离，同时保存内核名称、版本、以及底层体系结构类型等信息)，是 Kubernetes 调度的基本单位。</p></li><li><p><strong>labels</strong>: 键值对(key/value)标签，可以被关联到如 Pod 这样的对象上，主要作用是给用户一个直观的感受，比如这个 Pod 是用来放置数据库的</p></li><li><p><strong>GUI</strong>: 用户图形界面，可以是 Web 用户界面，比如使用 <code>kubernetes-dashboard</code> 组件，用户可以通过 Dashboard 在 Kubernetes 集群中部署容器化的应用，可以查看集群中应用的运行情况，同时也能够基于 Dashboard 创建或修改部署、任务、服务等 Kubernetes 的资源。通过部署向导，用户能够对部署进行扩缩容，进行滚动更新、重启 Pod 和部署新应用。当然，通过 Dashboard 也能够查看 Kubernetes 资源的状态</p></li><li><p><strong>kube-apiserver</strong>: 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</p></li><li><p><strong>Kubernetes Master</strong>:  Kubernetes 集群主节点，主要由 <code>kube-apiserver</code>、<code>kube-scheduler</code>、<code>kube-controller-manager</code>、<code>etcd</code> 四个模块组成</p></li><li><p><strong>kubernetes Node</strong>: Kubernetes 集群子节点，主要由 <code>kubelet</code>、<code>kube-proxy</code>、<code>runtime</code> 三个模块组成</p></li><li><p><strong>kubeadm</strong>: kubernetes 的集群安装工具，能够快速安装 kubernetes 集群，安装 kubernetes 主要是安装它的各个镜像，而 kubeadm 已经为我们集成好了运行 kubernetes 所需的基本镜像。但由于国内的网络原因，在搭建环境时，无法拉取到这些镜像。此时我们只需要修改为阿里云提供的镜像服务即可解决该问题。</p></li><li><p><strong>kubelet</strong>: 运行在cluster所有节点上,负责启动POD和容器</p></li><li><p><strong>kubectl</strong>: kebenetes的命令行工具,通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件</p></li></ul><h2 id="二、集群安装"><a href="#二、集群安装" class="headerlink" title="二、集群安装"></a>二、集群安装</h2><h3 id="2-1-安装必备工具"><a href="#2-1-安装必备工具" class="headerlink" title="2.1 安装必备工具"></a>2.1 安装必备工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h3 id="2-2-kubeadm安装"><a href="#2-2-kubeadm安装" class="headerlink" title="2.2 kubeadm安装"></a>2.2 kubeadm安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 导出配置文件</span></span><br><span class="line">kubeadm config print init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所需镜像</span></span><br><span class="line">kubeadm config images list --config kubeadm.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line">kubeadm config images pull --config kubeadm.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装主节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定了初始化时需要使用的配置文件，其中添加 --upload-certs 参数可以在后续执行加入节点时自动分发证书文件。追加的 tee kubeadm-init.log 用以输出日志</span></span><br><span class="line">kubeadm init --config=kubeadm.yml --upload-certs | tee kubeadm-init.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装子节点</span></span><br><span class="line">kubeadm join 192.168.81.110:6443 --token abcdef.0123456789abcdef --discovery-token-ca-cert-hash sha256:3eac1be34c9e324279ebd843087e7dd002b3102c7d14313aec490cd73b4138ad</span><br></pre></td></tr></table></figure><h3 id="2-3-常用命令"><a href="#2-3-常用命令" class="headerlink" title="2.3 常用命令"></a>2.3 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看kubernetes api版本</span></span><br><span class="line">kubectl api-versions</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看命名空间</span></span><br><span class="line">kubectl get namespace</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在主节点查看是否安装成功，检查node状态</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Pods 状态</span></span><br><span class="line">watch kubectl get pods -n kube-system -o wide</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看组件运行状态</span></span><br><span class="line">kubectl get cs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出如下</span></span><br><span class="line">  NAME                 STATUS    MESSAGE             ERROR</span><br><span class="line">  scheduler            Healthy   ok  # 调度服务，主要作用是将 POD 调度到 Node</span><br><span class="line">  controller-manager   Healthy   ok  # 自动化修复服务，主要作用是 Node 宕机后自动修复 Node 回到正常的工作状态</span><br><span class="line">  etcd-0               Healthy   &#123;"health":"true"&#125; # 服务注册与发现</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查master状态</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 kubectl 命令创建两个监听 80 端口的 Nginx Pod（Kubernetes 运行容器的最小单元）</span></span><br><span class="line">kubectl run nginx --image=nginx --replicas=2 --port=80</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pods状态</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经部署的服务</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经发布的服务</span></span><br><span class="line">kubectl get services</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用负载均衡模式发布服务，让用户可以访问</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --type=LoadBalancer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务详情</span></span><br><span class="line">kubectl describe service kubia-web-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已经部署的服务</span></span><br><span class="line">kubectl delete deployment nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已经发布的服务</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署根据配置文件里面列出来的内容，升级现有的,内容可以只写需要升级的属性</span></span><br><span class="line">kubectl apply -f filename.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署先删除所有现有的东西，重新根据yaml文件生成新的</span></span><br><span class="line">kubectl create -f filename.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过ingress查看</span></span><br><span class="line">kubectl get ingress</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑ingress信息</span></span><br><span class="line">kubectl edit ingress nginx-web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除ingress</span></span><br><span class="line">kubectl delete ingress nginx-web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ingress资源</span></span><br><span class="line">kubectl get pods -n ingress-nginx -o wide</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过创建的svc可以看到已经把ingress-nginx service在主机映射的端口</span></span><br><span class="line">kubectl get svc -n ingress-nginx</span><br></pre></td></tr></table></figure><h2 id="三、部署"><a href="#三、部署" class="headerlink" title="三、部署"></a>三、部署</h2><ul><li>tomcat</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建该对象所使用的 Kubernetes API 的版本。通过kubectl api-versions可以查看版本</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建的对象的类型: Deployment、Job、Ingress、Service、Pod</span></span><br><span class="line">kind: Deployment</span><br><span class="line"><span class="meta">#</span><span class="bash"> Pod的一些meta信息，比如名称、namespace、标签等信息</span></span><br><span class="line">metadata:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 资源的名字，在同一个namespace中必须唯一</span></span><br><span class="line">  name: tomcat-app</span><br><span class="line"><span class="meta">#</span><span class="bash"> Pod中容器的详细定义</span></span><br><span class="line">spec:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 定义标签选择器</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      # 容器标签的名字，发布 Service 时，selector 需要和这里对应</span><br><span class="line">      app: tomcat</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 副本数量</span></span><br><span class="line">  replicas: 2</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Pod的定义</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      # Pod的label</span><br><span class="line">      labels:</span><br><span class="line">        app: tomcat</span><br><span class="line">    # 指定该资源的内容</span><br><span class="line">    spec:</span><br><span class="line">      # 容器</span><br><span class="line">      containers:</span><br><span class="line">      - name: tomcat</span><br><span class="line">        image: tomcat:8.5.43</span><br><span class="line">        # 镜像拉取策略: Always不管镜像是否存在都会进行一次拉取,Never不管镜像是否存在都不会进行拉取,IfNotPresent:只有镜像不存在时，才会进行镜像拉取注意</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat-http</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8080</span><br><span class="line">      targetPort: 8080</span><br><span class="line"><span class="meta">  #</span><span class="bash"> ClusterIP, NodePort, LoadBalancer</span></span><br><span class="line">  type: ClusterIP</span><br><span class="line">  selector:</span><br><span class="line">    app: tomcat</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.k8s.io/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-web</span><br><span class="line">  annotations:</span><br><span class="line">    # 指定 Ingress Controller 的类型</span><br><span class="line">    kubernetes.io/ingress.class: "nginx"</span><br><span class="line">    # 指定我们的 rules 的 path 可以使用正则表达式</span><br><span class="line">    nginx.ingress.kubernetes.io/use-regex: "true"</span><br><span class="line">    # 连接超时时间，默认为 5s</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"</span><br><span class="line">    # 后端服务器回转数据超时时间，默认为 60s</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"</span><br><span class="line">    # 后端服务器响应超时时间，默认为 60s</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"</span><br><span class="line">    # 客户端上传文件，最大大小，默认为 20m</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-body-size: "10m"</span><br><span class="line">    # URL 重写</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /</span><br><span class="line">spec:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 路由规则</span></span><br><span class="line">  rules:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 主机名，只能是域名，修改为你自己的</span></span><br><span class="line">  - host: k8s.test.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path:</span><br><span class="line">        backend:</span><br><span class="line">          # 后台部署的 Service Name</span><br><span class="line">          serviceName: tomcat-http</span><br><span class="line">          # 后台部署的 Service Port</span><br><span class="line">          servicePort: 8080</span><br></pre></td></tr></table></figure><h2 id="四、深入学习"><a href="#四、深入学习" class="headerlink" title="四、深入学习"></a>四、深入学习</h2><h3 id="介绍说明"><a href="#介绍说明" class="headerlink" title="介绍说明"></a>介绍说明</h3><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>Horizoontal Pod Autoscaling(HPA): 扩容缩</p><p>StatefulSet: 解决有服务状态服务的问题</p><p>DameonSet: 确保全部挥、或者一些Node上运行一个Pod副本。比如没有node上都安装一个logstash</p><p>Job: 负责批处理任务，只执行一次的任务。如备份等。</p><h3 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h3><h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><p>ReplicaSets(RC): 滚动更新</p><p>Horizoontal Pod Autoscaling(HPA): 扩容缩</p><p>StatefulSet: 解决有服务状态服务的问题</p><p>DameonSet: 确保全部挥、或者一些Node上运行一个Pod副本。比如没有node上都安装一个logstash</p><p>Job: 负责批处理任务，只执行一次的任务。如备份等。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>service</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h3 id="HELM"><a href="#HELM" class="headerlink" title="HELM"></a>HELM</h3><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3>]]></content>
    
    
    <summary type="html">k8s命令记录。</summary>
    
    
    
    <category term="linux" scheme="https://gaoqisen.github.io/categories/linux/"/>
    
    
    <category term="k8s" scheme="https://gaoqisen.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>线程安全的学习</title>
    <link href="https://gaoqisen.github.io/java/threadSecurity.html"/>
    <id>https://gaoqisen.github.io/java/threadSecurity.html</id>
    <published>2020-07-01T10:22:26.000Z</published>
    <updated>2020-07-09T17:16:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、线程安全与非线程安全"><a href="#一、线程安全与非线程安全" class="headerlink" title="一、线程安全与非线程安全"></a>一、线程安全与非线程安全</h2><p>非线程安全: ArrayList、HashMap、StringBuilder。</p><p>线程安全: <del>Vector</del>、<del>HashTable</del>(ConcurrentHashMap)、StringBuffer</p><ul><li>HashMap与ConcurrentHashMap的区别<ol><li>ConcurrentHashMap是线程安全的，HashMap不是线程安全的</li><li>ConcurrentHashMap对桶数组进行了分段，HashMap没有。</li><li>ConcurrentHashMap在每个分段上都用锁进行保护，从而让锁更精细一些，并发性能要好一些。HashMap没有锁机制。</li></ol></li></ul><blockquote><p> 在主线程中new了一个非线程安全的ArrayList，然后开1000个线程分别向这个ArrayList里面添加元素，每个线程添加100个元素，等所有线程执行完成后查看list的总数。之后又new一个Vector用同样的方法查看数量，对比结果。例子:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList与Vector测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程不安全</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadHandleArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程安全</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadHandleVector();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadHandleVector</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> Vector();</span><br><span class="line">        <span class="comment">// 用来让主线程等待threadCount个子线程执行完毕</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="string">"线程"</span>+ (i+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                        list.add(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadHandleArrayList</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">// 用来让主线程等待threadCount个子线程执行完毕</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="string">"线程"</span>+ (i+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                        list.add(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个线程操作同一个对象的话就需要使用线程安全的对象，如果在线程内部new的对象则完全没必要使用线程安全的，如果使用了反而会造成性能影响因为线程安全的加了锁的。</p><h2 id="二、-死锁"><a href="#二、-死锁" class="headerlink" title="二、 死锁"></a>二、 死锁</h2><h3 id="2-1-什么是线程死锁"><a href="#2-1-什么是线程死锁" class="headerlink" title="2.1 什么是线程死锁"></a>2.1 什么是线程死锁</h3><p>定义: 如果多个线程在操作同一个对象的时候相互等待，在没有人为干预的情况下无法打破这种僵局。这种情况就是死锁。例如，某计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object a = <span class="keyword">new</span> Object();</span><br><span class="line">        Object b = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"线程1"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"给对象a加锁并访问对象b"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"获取对象b"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"线程2"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"给对象b加锁并访问对象a"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"获取对象a"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-产生的原因"><a href="#2-2-产生的原因" class="headerlink" title="2.2 产生的原因"></a>2.2 产生的原因</h3><ul><li>系统资源的竞争: 系统中有一些资源有限，多线程去处理的时候经常处理资源不够的情况。在线程的运行中，会因为争抢资源而陷入僵局，只有对不可剥夺的资源进行竞争才可能产生死锁。</li><li>线程顺序不对: 在运行的线程中由于顺序不对也会造成死锁。如: 线程1和2同时使用资源1和2，线程1在没有释放的情况下去获取资源2，线程2在没有释放的情况下去获取资源1。就会造成死锁。或者进程A等待进程B发的消息，进程B又在等待进程A 发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</li></ul><h3 id="2-3-必要条件"><a href="#2-3-必要条件" class="headerlink" title="2.3 必要条件"></a>2.3 必要条件</h3><ol><li><strong>互斥条件</strong>：一个资源，或者说一个锁只能被一个线程所占用，当一个线程首先获取到这个锁之后，在该线程释放这个锁之前，其它线程均是无法获取到这个锁。</li><li><strong>占有且等待</strong>：一个线程已经获取到一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁。</li><li><strong>不可剥夺条件</strong>：任何一个线程都无法强制获取别的线程已经占有的锁</li><li><strong>循环等待条件</strong>：线程A拿着线程B的锁，线程B拿着线程A的锁</li></ol><h3 id="2-3-如何避免"><a href="#2-3-如何避免" class="headerlink" title="2.3 如何避免"></a>2.3 如何避免</h3><p>死锁必须满足以上的4个条件，只要其中一个条件不满足就不好产生死锁。</p><ul><li>加锁顺序: 线程按照相同的顺序加锁。</li><li>加锁时限: 线程获取锁的过程中限制一定的时间，如果给定时间内获取不到，就算了，别勉强自己。这需要用到Lock的一些API</li><li>死锁检测: 死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。每当一个线程获得了锁，就在一个数据结构中记录一下如：线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）<ul><li>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。</li><li>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</li></ul></li></ul><h3 id="2-4-死锁检测"><a href="#2-4-死锁检测" class="headerlink" title="2.4 死锁检测"></a>2.4 死锁检测</h3><ul><li><p>jstack: 是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。<strong>线程快照</strong>是当前java虚拟机内每一条线程<strong>正在执行</strong>的<strong>方法堆栈</strong>的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如<code>线程间死锁</code>、<code>死循环</code>、<code>请求外部资源导致的长时间等待</code>等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">JasonGaodeMacBook-Air:~ jasongao$ jps  // 找到当前执行任务的进程号</span><br><span class="line">2770 App</span><br><span class="line">67397 DeathLock</span><br><span class="line">67396 Launcher</span><br><span class="line">65497 KotlinCompileDaemon</span><br><span class="line">64299</span><br><span class="line">67434 Jps</span><br><span class="line">64463 RemoteMavenServer36</span><br><span class="line">JasonGaodeMacBook-Air:~ jasongao$ jstack 67397  // 执行jstack命令查看当前进程堆栈信息</span><br><span class="line">2020-07-01 14:54:34</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.211-b12 mixed mode):</span><br><span class="line"></span><br><span class="line">"Attach Listener" #15 daemon prio=9 os_prio=31 tid=0x00007fc13b802000 nid=0x360b waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"DestroyJavaVM" #14 prio=5 os_prio=31 tid=0x00007fc13b8e9800 nid=0x1003 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"线程2" #13 prio=5 os_prio=31 tid=0x00007fc13b8e9000 nid=0x5503 waiting for monitor entry [0x0000700001555000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.gaoqisen.threadcecurity.DeathLock$2.run(DeathLock.java:34)</span><br><span class="line">- waiting to lock &lt;0x00000007aad54eb0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000007aad54ec0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">"线程1" #12 prio=5 os_prio=31 tid=0x00007fc13a050800 nid=0x5303 waiting for monitor entry [0x0000700001452000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.gaoqisen.threadcecurity.DeathLock$1.run(DeathLock.java:17)</span><br><span class="line">- waiting to lock &lt;0x00000007aad54ec0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000007aad54eb0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">JNI global references: 1432</span><br><span class="line"></span><br><span class="line">// 线程死锁信息</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"线程2":</span><br><span class="line">  waiting to lock monitor 0x00007fc13b83dca8 (object 0x00000007aad54eb0, a java.lang.Object),</span><br><span class="line">  which is held by "线程1"</span><br><span class="line">"线程1":</span><br><span class="line">  waiting to lock monitor 0x00007fc13b839c08 (object 0x00000007aad54ec0, a java.lang.Object),</span><br><span class="line">  which is held by "线程2"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"线程2":</span><br><span class="line">at com.gaoqisen.threadcecurity.DeathLock$2.run(DeathLock.java:34)</span><br><span class="line">- waiting to lock &lt;0x00000007aad54eb0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000007aad54ec0&gt; (a java.lang.Object)</span><br><span class="line">"线程1":</span><br><span class="line">at com.gaoqisen.threadcecurity.DeathLock$1.run(DeathLock.java:17)</span><br><span class="line">- waiting to lock &lt;0x00000007aad54ec0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000007aad54eb0&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure></li><li><p>jconsole: 是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。在命令行中敲入jconsole命令，会自动弹出以下对话框，选择进程67397，并点击“Connect”。</p><p><img src="https://gaoqisen.github.io/GraphBed/202007/20200701150151.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200701150151.png"></p></li></ul><p>  点击Threads后再点击Detect Deadlock</p><p>  <img src="https://gaoqisen.github.io/GraphBed/202007/20200701150311.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200701150311.png"></p><p>之后就可以查看死锁信息了。</p><p><img src="https://gaoqisen.github.io/GraphBed/202007/20200701150506.png" alt="https://gaoqisen.github.io/GraphBed/202007/20200701150506.png"></p><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><ul><li>死锁： <a href="https://www.cnblogs.com/sthu/p/9660914.html" target="_blank" rel="noopener">https://www.cnblogs.com/sthu/p/9660914.html</a></li><li>线程安全：<a href="https://blog.csdn.net/xiao__gui/article/details/8934832" target="_blank" rel="noopener">https://blog.csdn.net/xiao__gui/article/details/8934832</a></li><li>死锁的4个必要条件: <a href="https://blog.csdn.net/rabbit_in_android/article/details/50530960" target="_blank" rel="noopener">https://blog.csdn.net/rabbit_in_android/article/details/50530960</a></li></ul>]]></content>
    
    
    <summary type="html">关于线程安全的一些学习。</summary>
    
    
    
    <category term="Lock thread" scheme="https://gaoqisen.github.io/categories/Lock-thread/"/>
    
    
    <category term="thread" scheme="https://gaoqisen.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://gaoqisen.github.io/study/algorithm.html"/>
    <id>https://gaoqisen.github.io/study/algorithm.html</id>
    <published>2020-06-30T12:43:40.000Z</published>
    <updated>2020-07-20T06:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul><li>数据结构: 存储数据的不同方式如：数组、链表、</li><li>算法: 同一个问题的不同解决方法,算法往往是针对特定数据结构的</li><li>时间测量：计算算法时间差、幅度不够循环来凑(扩大数据量)</li><li>空间测算: 数据占用的空间越小越好</li><li>时间复杂度(Big O): 时间复杂度为O(n)随着处理数据量的增加，处理时间也会增加。时间复杂度为O(1)表示随着处理数据的规模增大但是处理的时间没有变化。</li><li>对数器: 检查算法是否正确，用足够多的样本和正确的算法计算结果样本去对比被验证的算法结果(用已有的排序算法和自己写的排序算法都去处理数据，之后将处理的结果对比一下是否一致)</li><li>O(1): 表示操作一次之后就可以获取目标元素</li><li>O(n): 表示要检查n个元素来搜索目标</li><li>O(log n): 从数组的中间选择一个随机点进行查找，然后重复这个过程</li><li>O(n2): 一个算法时bai间的消耗是和其计du算步数成平方增长的</li></ul><h2 id="二、排序算法"><a href="#二、排序算法" class="headerlink" title="二、排序算法"></a>二、排序算法</h2><h3 id="2-1-选择排序O-n2"><a href="#2-1-选择排序O-n2" class="headerlink" title="2.1 选择排序O(n2)"></a>2.1 选择排序O(n2)</h3><p>先找到最小的数字然后把它放在列表的最前面。最简单最没用的排序算法，有优化空间,不稳定(没用)。原理是找到最小的数把它放在最前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序算法，每次找到最小的数字放在最前面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minVal = i;</span><br><span class="line">            <span class="comment">// 找到最小数字的下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[minVal]) &#123;</span><br><span class="line">                    minVal = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将最小的数字放在最前面</span></span><br><span class="line">            <span class="keyword">int</span> tmp = arr[minVal];</span><br><span class="line">            arr[minVal] = arr[i];</span><br><span class="line">            arr[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-冒泡排序"><a href="#2-2-冒泡排序" class="headerlink" title="2.2 冒泡排序"></a>2.2 冒泡排序</h3><p>从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">80</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = j-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[index] &gt; a[j]) &#123;</span><br><span class="line">                    swap(a, index, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == (a.length - <span class="number">1</span>))&#123;</span><br><span class="line">                System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(a[i]+ <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        a[start] = a[end];</span><br><span class="line">        a[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-插入排序"><a href="#2-3-插入排序" class="headerlink" title="2.3 插入排序"></a>2.3 插入排序</h3><p>插入排序是一种简单直观的排序算法。它的基本思想是拿到当前值之后往前面的正确位置移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">80</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 通过当前值和前面的值比较，并把当前值放到恰当的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; a[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(a, j, j-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        a[start] = a[end];</span><br><span class="line">        a[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == (a.length - <span class="number">1</span>))&#123;</span><br><span class="line">                System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(a[i]+ <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-希尔排序"><a href="#2-4-希尔排序" class="headerlink" title="2.4 希尔排序"></a>2.4 希尔排序</h3><p>将数组分为几段处理，不如15个数组元素分为每4个一组进行插入排序，之后在进行2个一组插入排序，之后在进行1个一组进行插入排序就可以了。这样缩短了数字之间的插入排序。希尔排序是不常用的排序方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">80</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// knuth序列</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( h &lt;= a.length / <span class="number">3</span>) &#123;</span><br><span class="line">            h = h*<span class="number">3</span> +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = h; gap &gt; <span class="number">0</span>; gap = (gap -<span class="number">1</span>)/<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; gap -<span class="number">1</span> ; j-=gap) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j] &lt; a[j-gap]) &#123;</span><br><span class="line">                        swap(a, j, j-gap);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        a[start] = a[end];</span><br><span class="line">        a[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == (a.length - <span class="number">1</span>))&#123;</span><br><span class="line">                System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(a[i]+ <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-快速排序"><a href="#2-5-快速排序" class="headerlink" title="2.5 快速排序"></a>2.5 快速排序</h3><ul><li><p>单轴排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序: 采用不断的比较和移动来实现排序</span></span><br><span class="line"><span class="comment">// 对于给定的一组记录，选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，</span></span><br><span class="line"><span class="comment">// 将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序</span></span><br><span class="line"><span class="comment">// 后的正确位置,然后再用同样的方法递归地排序划分的两部分，直到序列中的所有记录均有序为止。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        print(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        partition(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针指向左边的第一个值</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="comment">// 已右边的数为基数(轴)</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[right];</span><br><span class="line">        <span class="comment">// 右边的指针就是right-1</span></span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当左边的值小于右边值的时候</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 从左往右找大于或者基数的数字，并移动到arr.length-1的位置</span></span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; arr[i] &lt;= temp) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                arr[j--] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从有右往左找小于或者等于基数的数字，并移动数字到i++的位置</span></span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; arr[j] &gt; temp)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">                arr[i++] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基数放在i的位置</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">// 递归循环轴左边的值</span></span><br><span class="line">        partition(arr, left, i-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归循环轴右边的值</span></span><br><span class="line">        partition(arr, i+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        a[start] = a[end];</span><br><span class="line">        a[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == (a.length - <span class="number">1</span>))&#123;</span><br><span class="line">                System.out.print(a[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(a[i]+ <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>双轴快排</li></ul><p>从两边同时查找</p><h3 id="2-6-计数排序"><a href="#2-6-计数排序" class="headerlink" title="2.6 计数排序"></a>2.6 计数排序</h3><p>用于统计有特别多的重复数据的时候，比如2万个学生的年龄分布等。非比较排序。 </p><h3 id="2-7-基数排序"><a href="#2-7-基数排序" class="headerlink" title="2.7 基数排序"></a>2.7 基数排序</h3><p>通过每个数字的个位、十位、百位等进行计数排序之后就可以了</p>]]></content>
    
    
    <summary type="html">一些algorithm学习，后期自己努力的方向。</summary>
    
    
    
    <category term="study" scheme="https://gaoqisen.github.io/categories/study/"/>
    
    
    <category term="algorithm" scheme="https://gaoqisen.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>GC学习笔记</title>
    <link href="https://gaoqisen.github.io/java/gc.html"/>
    <id>https://gaoqisen.github.io/java/gc.html</id>
    <published>2020-06-28T08:30:19.000Z</published>
    <updated>2020-07-14T08:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gaoqisen.github.io/GraphBed/202006/20200627172523.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200627172523.png"></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ol><li>serial(新): 一个CPU或一条GC线程进行垃圾回收,会出现STW。采用复制算法</li><li>parNew(新): serial的多线程版本,多条gc线程去回收(降低gc时间)。采用复制算法</li><li>parallel shavenge(新): 并行的多线程(追求CPU吞吐量)。采用复制算法</li><li>serial old(老): 单线程收集。标记-整理算法</li><li>parallel old(老): 多线程回收(追求CPU吞吐量)。标记-整理算法</li><li>CMS(老): 多线程回收(追求最短停顿时间)。标记-清除算法</li><li>G1(java9默认): 没有分代概念，将java堆分为相同的Region，回收最多垃圾数据的Regio</li><li>ZGC: java11, 暂停时间不超过10ms,支持 4TB,JDK13 到了 16TB!</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> JDK版本默认垃圾收集器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Serial Old（老年代）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Serial Old（老年代）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jdk1.9 默认垃圾收集器G1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jdk10 默认垃圾收集器G1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前使用的是哪种回收策略，-XX:+Use后面的就是 -XX:+PrintGCDetails 亦可通过打印的GC日志的新生代、老年代名称判断</span></span><br><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><h2 id="二、垃圾回收算法"><a href="#二、垃圾回收算法" class="headerlink" title="二、垃圾回收算法"></a>二、垃圾回收算法</h2><h3 id="2-1-标记-清除"><a href="#2-1-标记-清除" class="headerlink" title="2.1 标记-清除"></a>2.1 标记-清除</h3><p>首先标记出所有需要回收的对象,在标记完成后统一回收所有被标记的 对象。它是最基础的收集算法,后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题: 1. 效率问题。2. 空间问题(标记清除后会产生大量不连续的碎片)</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200627174125.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200627174125.png"></p><h3 id="2-2-标记-整理"><a href="#2-2-标记-整理" class="headerlink" title="2.2 标记-整理"></a>2.2 标记-整理</h3><p>根据老年代的特点特出的一种标记算法,标记过程仍然与“标记-清除”算法一样,但后续步骤不是直接<br>对可回收对象回收,而是让所有存活的对象向一端移动,然后直接清理掉端边界以外的内存</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200627173653.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200627173653.png"></p><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><p>为了解决效率问题,“复制”收集算法出现了。它可以将内存分为大小相同的两块,每次使用其中的一 块。当这一块的内存使用完后,就将还存活的对象复制到另一块去,然后再把使用的空间一次清理掉。 这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200627174302.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200627174302.png"></p><h3 id="2-4-分代收集"><a href="#2-4-分代收集" class="headerlink" title="2.4 分代收集"></a>2.4 分代收集</h3><p>当前虚拟机的垃圾收集都采用分代收集算法,只是根据对象存活周期的不 同将内存分为几块。一般将java堆分为新生代和老年代,这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中,每次收集都会有大量对象死去,所以可以选择复制算法,只需要付出少量对象的复制 成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的,而且没有额外的空间对它进行分配担保,所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h2 id="三、垃圾收集器详解"><a href="#三、垃圾收集器详解" class="headerlink" title="三、垃圾收集器详解"></a>三、垃圾收集器详解</h2><h3 id="3-1-serial"><a href="#3-1-serial" class="headerlink" title="3.1 serial"></a>3.1 serial</h3><p>Serial(串行新生代)，serial old(老年代)收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是 一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收 集工作,更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” ),直到它收集结束。</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200630101205.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200630101205.png"></p><p>Serial收集器由于没有线程交互的开销,可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择,简单而且高效。</p><h3 id="3-2-parNew"><a href="#3-2-parNew" class="headerlink" title="3.2 parNew"></a>3.2 parNew</h3><p>ParNew收集器其实就是Serial收集器的多线程版本,除了使用多线程进行垃圾收集外,其余行为(控制参数、收集算法、回收策略等等)和Serial收集器完全一样。新生代采用复制算法,老年代采用标记-整理算法。它是许多运行在Server模式下的虚拟机的首要选择,除了Serial收集器外,只有它能与CMS收集器(真 正意义上的并发收集器,后面会介绍到)配合工作。新生代采用复制算法,老年代采用标记-整理算法。</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200630101848.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200630101848.png"></p><h3 id="3-3-Parallel-Scavenge"><a href="#3-3-Parallel-Scavenge" class="headerlink" title="3.3 Parallel Scavenge"></a>3.3 Parallel Scavenge</h3><p>Parallel Scavenge 收集器类似于ParNew 收集器。Parallel Scavenge收集器关注点是吞吐量(高效率的利用CPU)。CMS等垃圾收集器的关注点更多的是 用户线程的停顿时间(提高用户体验)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时 间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量,如 果对于收集器运作不太了解的话,手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一 个不错的选择。</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200630101848.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200630101848.png"></p><h3 id="3-4-Serial-Old"><a href="#3-4-Serial-Old" class="headerlink" title="3.4 Serial Old"></a>3.4 Serial Old</h3><p>Serial收集器的老年代版本,它同样是一个单线程收集器。它主要有两大用途:一种用途是在JDK1.5以<br>及以前的版本中与Parallel Scavenge收集器搭配使用,另一种用途是作为CMS收集器的后备方案。</p><h3 id="3-5-Parallel-Old"><a href="#3-5-Parallel-Old" class="headerlink" title="3.5 Parallel Old"></a>3.5 Parallel Old</h3><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源 的场合,都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h3 id="3-6-CMS"><a href="#3-6-CMS" class="headerlink" title="3.6 CMS"></a>3.6 CMS</h3><p>Concurrent Mark Sweep 收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合<br>在注重用户体验的应用上使用。是HotSpot虚拟机第一款真正意义上的并发收集器,它第一次实 现了让垃圾收集线程与用户线程(基本上)同时工作， “标记-清除”算法实现。运行分为四个步骤初始标记、并发标记、重新标记、并发清除:</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200630103223.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200630103223.png"></p><ul><li><p>初始标记: 暂停所有线程，记录所有与根(root)对象相连的对象，速度特别快</p></li><li><p>并发标记: 同时开启GC和用户线程,用一个闭包结构去记录可达对象。但在这个阶段结束,这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域,所以 GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p>重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变 动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段的时间稍⻓,远远比 并发标记阶段时间短</p></li><li><p>并发清除: 开启用户线程,同时GC线程开始对为标记的区域做清扫。</p></li></ul><p>  优点: 并发收集，低停顿。</p><p>  缺点: 对CPU资源敏感，无法处理浮动垃圾，标记清除算法会导致大量空间碎片。</p><h3 id="3-7-G1"><a href="#3-7-G1" class="headerlink" title="3.7 G1"></a>3.7 G1</h3><p>java9默认的收集器是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器.<br>以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。筛选回收进化特征：</p><ul><li>并行与并发:G1能充分利用CPU、多核环境下的硬件优势,使用多个CPU(CPU或者CPU核心)来缩 短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作,G1收集器仍 然可以通过并发的方式让java程序继续执行。</li><li>分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆,但是还是保留了分代的概 念。</li><li>空间整合:与CMS的“标记–清理”算法不同,G1从整体来看是基于“标记整理”算法实现的收集 器;从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿:这是G1相对于CMS的另一个大优势,降低停顿时间是G1 和 CMS 共同的关注点, 但G1 除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个⻓度为M 毫秒的时间片段内。</li></ul><p>G1收集器在后台维护了一个优先列表,每次根据允许的收集时间,优先选择回收价值最大的Region(这 也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式, 保证了GF收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)，G1收集过程。</p><ul><li>初始标记 标记与GC Roots直接关联的对象,停止所有用户线程,只启动一条初始标记线程,这个过程很快.</li><li>并发标记 进行全面的可达性分析,开启一条并发标记线程与用户线程并行执行.这个过程比较长.</li><li>最终标记 标记出并发标记过程中用户线程新产生的垃圾.停止所有用户线程,并使用多条最终标记线程并行执行.</li><li>筛选回收 回收废弃的对象.此时也需要停止一切用户线程,并使用多条筛选回收线程并行执行.</li></ul><h3 id="3-8-ZGC"><a href="#3-8-ZGC" class="headerlink" title="3.8 ZGC"></a>3.8 ZGC</h3><p>ZGC是从JDK11中引入的一种新的<strong>支持弹性伸缩</strong>和<strong>低延迟</strong>垃圾收集器，ZGC可以工作在KB~TB的内存之下，作为一种并发的垃圾收集器，ZGC保证应用延迟不会超过10毫秒(即便在堆内存很大的情况下)，在JDK11中是以实验阶段的特性被发布出来的，到JDK13时，ZGC可以支持到16TB的堆内存，并且可以将<strong>未提交的内存归还给操作系统</strong>。</p><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><ul><li>垃圾回收算法: <a href="https://www.jianshu.com/p/114bf4d9e59e" target="_blank" rel="noopener">https://www.jianshu.com/p/114bf4d9e59e</a></li><li>垃圾收集器: <a href="https://cloud.tencent.com/developer/article/163396" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/163396</a></li><li>ZGC: <a href="https://zhuanlan.zhihu.com/p/43608166" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43608166</a></li></ul>]]></content>
    
    
    <summary type="html">学习一下GC的垃圾回收算法，以及现有的垃圾回收器。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java gc" scheme="https://gaoqisen.github.io/tags/java-gc/"/>
    
  </entry>
  
  <entry>
    <title>对象的引用学习笔记</title>
    <link href="https://gaoqisen.github.io/java/reference.html"/>
    <id>https://gaoqisen.github.io/java/reference.html</id>
    <published>2020-06-27T02:31:19.000Z</published>
    <updated>2021-05-31T13:08:37.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的强、软、弱、虚引用"><a href="#对象的强、软、弱、虚引用" class="headerlink" title="对象的强、软、弱、虚引用"></a>对象的强、软、弱、虚引用</h2><ul><li><p>强引用（只要有引用指向就不会被回收）一个对象被强引用时，就算抛出OOM异常也不会被GC回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// M写finalize方法，在垃圾回收的时候会被调用. 垃圾回收的线程和main主线程那个先执行，不可控。</span></span><br><span class="line">        M m = <span class="keyword">new</span> M();  <span class="comment">// 强引用</span></span><br><span class="line">        m = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();  <span class="comment">// 显示调用垃圾回收</span></span><br><span class="line">        System.out.println(m);  <span class="comment">// 输出 null</span></span><br><span class="line">        System.in.read();  <span class="comment">// 阻塞main线程，给垃圾回收线程时间去执行. 如果重写了finalize方法的话，就会执行该方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>软引用（堆空间不够的时候，gc会去回收），可用来实现内存敏感的高速缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 在内存中，内存中开辟了一块10m的空间。m执行了SoftReference对象，SoftReference软引用指向了10m的内存数据</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; m = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]);</span><br><span class="line">        System.out.println (m.get());  <span class="comment">// 获取对象地址</span></span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);  <span class="comment">// 给gc回收时间</span></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置堆空间最大为20m的时候，前面m的软引用已经有10m的数据了。[-Xmx20M]</span></span><br><span class="line">        <span class="comment">// 这个时候在new一个硬引用的b有15m，这个时候堆空间不够20m，故gc会把软引用的数据清理掉。</span></span><br><span class="line">        <span class="comment">// 在输出m的对象地址就为空</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">12</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 软引用特别适合作缓存</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>弱引用（只要执行gc就会被回收），弱引用可以和一个引用队列(ReferenceQueue)联合使用,如果弱引用所引用的对象被垃圾回收,Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 弱引用</span></span><br><span class="line">       WeakReference&lt;M&gt; m = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> M());</span><br><span class="line">  </span><br><span class="line">       System.out.println(m.get());</span><br><span class="line">       System.gc(); <span class="comment">// gc回收时直接回收弱引用</span></span><br><span class="line">       System.out.println(m.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>虚引用（一直不会被引用，jvm会使用），虚引用主要用来跟踪对象被垃圾回收的活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用来管理直接内存（在对象被垃圾回收之后会执行一些操作）</span></span><br><span class="line">        <span class="comment">// 看m对象有没有指向堆外内存(不归gc管理的)，如果后指向，则清理堆外内存。</span></span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> M(), QUEUE);</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 垃圾回收线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Reference&lt;? extends M&gt; poll = QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"虚引用被jvm回收"</span> + poll);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>虚引用与软引用和弱引用的一个区别在于: 虚引用必须和引用队列(ReferenceQueue)联合使用。当 垃 圾回收器准备回收一个对象时,如果发现它还有虚引用,就会在回收对象的内存之前,把这个虚引 用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用,来了解被引 用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列,那么就可以在所引用 的对象的内存被回收之前采取必要的行动。</p></blockquote><blockquote><p>对象传值的三种方式：1. 通过方法的参数。2. 通过静态变量。3.通过ThreadLocal</p></blockquote><ul><li><p>ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程私有的， 只有在同一个线程里面才可以拿到值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;People&gt; th = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"th: "</span> + th.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在当前线程的map对象里面放 map.set(this, value);</span></span><br><span class="line">            <span class="comment">// set的时候Entry继承了WeakReference，防止内存泄漏。弱引用，只要没有对象指向</span></span><br><span class="line">            th.set(<span class="keyword">new</span> People());</span><br><span class="line">            <span class="comment">// 不用了一定要remove，不然也会内存泄漏</span></span><br><span class="line">            th.remove();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>学习网址: <a href="https://www.bilibili.com/video/BV1HD4y1Q71y?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1HD4y1Q71y?p=8</a></p>]]></content>
    
    
    <summary type="html">JDK1.2之前如果reference类型的数据存储的数值代表的是另一块内存的起始地址,就称这块内存代表一个引用。JDK1.2以后,Java对引用的概念进行了扩充,将引用分为强引用、软引用、弱引用、虚引用四种(引用 强度逐渐减弱)</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java reference" scheme="https://gaoqisen.github.io/tags/java-reference/"/>
    
  </entry>
  
  <entry>
    <title>filebeat学习笔记</title>
    <link href="https://gaoqisen.github.io/tool/filebeat.html"/>
    <id>https://gaoqisen.github.io/tool/filebeat.html</id>
    <published>2020-06-26T12:10:11.000Z</published>
    <updated>2020-07-11T02:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Filebeat是一个日志文件托运工具，在你的服务器上安装客户端后，filebeat会监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh中存放。filebeat是一个轻量级的logstash，当你需要收集信息的机器配置或资源并不是特别多时，使用filebeat来收集日志。日常使用中，filebeat十分稳定。</p><p>logstash 功能虽然强大，但是基于ruby的配置语法、依赖jdk、消耗系统资源等弊端，使得考虑其他方式来替换logstash，filebeat则是一个完美的替代者</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><ul><li><p>最新下载地址: <a href="https://www.elastic.co/cn/downloads/beats/filebeat" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/beats/filebeat</a></p></li><li><p>解压文件夹：</p></li><li><p>启动: sudo ./filebeat -e -c filebeat.yml</p></li><li><p>docker安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mac:</span><br><span class="line">    brew install filebeat</span><br><span class="line">linux:</span><br><span class="line">    wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">    tar -zxvf filebeat-7.3.1-linux-x86_64.tar.gz</span><br><span class="line">    nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;  // 后台启动将所有标准输出及标准错误输出到/dev/null空设备，即没有任何输出</span><br><span class="line">docker:</span><br><span class="line">    docker pull docker.elastic.co/beats/filebeat:7.3.1</span><br><span class="line">    docker tag docker.elastic.co/beats/filebeat:7.3.1 filebeat</span><br><span class="line">    docker run -d --name logstash 10.45.53.221:5000/filebeat </span><br><span class="line">    docker run --name filebeat -d --link logstash -v ~/elk/yaml/filebeat.yml:/usr/share/filebeat/filebeat.yml -v ~/elk/logs/:/home/logs/ filebeat   // 启动filebeat并关联logstash</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、配置文件"><a href="#三、配置文件" class="headerlink" title="三、配置文件"></a>三、配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">filebeat.yml</span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- paths:</span><br><span class="line">    - /home/user/elk/logs/order/*.log</span><br><span class="line">  multiline:</span><br><span class="line">      pattern: ^\d&#123;4&#125;</span><br><span class="line">      negate: true</span><br><span class="line">      match: after</span><br><span class="line">  fields:</span><br><span class="line">    doc_type: order</span><br><span class="line">- paths:</span><br><span class="line">    - /home/user/elk/logs/customer/*.log</span><br><span class="line">  multiline:</span><br><span class="line">      pattern: ^\d&#123;4&#125;</span><br><span class="line">      negate: true</span><br><span class="line">      match: after</span><br><span class="line">  fields:</span><br><span class="line">    doc_type: customer</span><br><span class="line">output.logstash: # 输出地址</span><br><span class="line">  hosts: [&quot;logstash:5043&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">filebeat学习的一些笔记,还在记录中， 加油！</summary>
    
    
    
    <category term="tool" scheme="https://gaoqisen.github.io/categories/tool/"/>
    
    
    <category term="filebeat" scheme="https://gaoqisen.github.io/tags/filebeat/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch学习</title>
    <link href="https://gaoqisen.github.io/tool/elasticsearch.html"/>
    <id>https://gaoqisen.github.io/tool/elasticsearch.html</id>
    <published>2020-06-25T08:11:32.000Z</published>
    <updated>2020-07-11T02:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h2 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h2><ul><li>下载安装包地址: <a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></li><li><p>修改config/elasticsearch.yml配置</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 集群名称</span><br><span class="line">cluster.name: web-application</span><br><span class="line"># ------------------------------------ Node ------------------------------------</span><br><span class="line"># 节点名称</span><br><span class="line">node.name: node-1</span><br><span class="line"># 增加一个自定义属性</span><br><span class="line">#node.attr.rack: r1</span><br><span class="line"># ----------------------------------- Paths ------------------------------------</span><br><span class="line"># 存储数据的目录(用逗号分隔)</span><br><span class="line">#path.data: /path/to/data</span><br><span class="line"># 日志路径</span><br><span class="line">#path.logs: /path/to/logs</span><br><span class="line"># ----------------------------------- Memory -----------------------------------</span><br><span class="line"># 启动时锁定内存:</span><br><span class="line">#bootstrap.memory_lock: true</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br><span class="line"># ---------------------------------- Network -----------------------------------</span><br><span class="line"># 设置外网可以访问</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"># 自定义端口</span><br><span class="line">#http.port: 9200</span><br><span class="line"># --------------------------------- Discovery ----------------------------------</span><br><span class="line">#</span><br><span class="line"># 启动后去发现list里面主机节点是否启动 默认列表[&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span><br><span class="line">#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]</span><br><span class="line"># 初始化主节点</span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;]</span><br><span class="line"># ---------------------------------- Gateway -----------------------------------</span><br><span class="line"># 整个集群启动之后</span><br><span class="line">#gateway.recover_after_nodes: 3</span><br><span class="line"># ---------------------------------- Various -----------------------------------</span><br><span class="line"># 删除索引时需要显示名称</span><br><span class="line">#action.destructive_requires_name: true</span><br><span class="line"># 启动输入密码访问</span><br><span class="line">xpack.security.transport.ssl.enabled: true</span><br><span class="line">xpack.security.enabled: true</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>操作命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 增加elasticsearch用户</span><br><span class="line">adduser elasticsearch</span><br><span class="line">// 设置密码</span><br><span class="line">passwd elasticsearch</span><br><span class="line">// 更改文件的所属用户</span><br><span class="line">chown -R elasticsearch filename</span><br><span class="line">// 切换用户</span><br><span class="line">su elasticsearch</span><br><span class="line">// 解压</span><br><span class="line">tar -zxf XXX.tar.gz</span><br><span class="line">// 后台启动</span><br><span class="line">./elasticsearch -d</span><br><span class="line">// 修改密码，为多个用户分别设置密码</span><br><span class="line">bin/elasticsearch-setup-passwords interactive</span><br></pre></td></tr></table></figure></li><li><p>验证:，浏览器访问<a href="http://ip:9200输入帐号密码后返回json串表示启动成功。" target="_blank" rel="noopener">http://ip:9200输入帐号密码后返回json串表示启动成功。</a></p></li></ul><h3 id="1-2-安装遇到的问题"><a href="#1-2-安装遇到的问题" class="headerlink" title="1.2 安装遇到的问题"></a>1.2 安装遇到的问题</h3><h4 id="1-2-1-外网无法访问"><a href="#1-2-1-外网无法访问" class="headerlink" title="1.2.1 外网无法访问"></a>1.2.1 外网无法访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim config/elasticsearch.yml</span><br><span class="line">// 增加下面配置</span><br><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><h4 id="1-2-2-启动报错"><a href="#1-2-2-启动报错" class="headerlink" title="1.2.2 启动报错"></a>1.2.2 启动报错</h4><ul><li><p>system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk。 因为Centos6不支持SecComp，而ES5.2.1默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。解决方法：在elasticsearch.yml中配置bootstrap.system_call_filter为false，注意要在Memory下面:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>max number of threads [1024] for user [elasticsearch] is too low, increase to at least [4096] 最大线程数[1024]太低，至少增加到[4096]。 修改/etc/security/limits.d/90-nproc.conf文件里面1024为4096</p></li><li><p>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 最大虚拟内存区域vm.max_map_count [65530]太低，至少增加到[262144]</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">// 增加下面配置</span><br><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure></li><li><p>max file descriptors [65535] for elasticsearch process is too low, increase to at least[65536]。由于给帐号的最大打开文件个数或者最大打开线程数的限制，一直会报错，因此改一下限制(/etc/security/limits.conf)即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 增加下面配置</span><br><span class="line"> * soft nofile 65536</span><br><span class="line"> * hard nofile 131072</span><br><span class="line"> * soft nproc 2048</span><br><span class="line"> * hard nproc 4096</span><br><span class="line"> // 退出帐号重新登录(退出重新登录生效)</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、常用语法"><a href="#二、常用语法" class="headerlink" title="二、常用语法"></a>二、常用语法</h2><h3 id="2-1-基本操作"><a href="#2-1-基本操作" class="headerlink" title="2.1 基本操作"></a>2.1 基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># &lt;REST Verb&gt; http://localhost:9200/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</span><br><span class="line"># &lt;請求類型&gt;   &lt;请求地址&gt;/&lt;索引名&gt;/&lt;文档类型&gt;/&lt;文档ID&gt;</span><br><span class="line"># 数据库：数据库  表   行    列</span><br><span class="line"># el：   索引    类型 文档  字段</span><br><span class="line"># 检查集群的健康 Authorization 從/獲取</span><br><span class="line">GET /_cat/health?v</span><br><span class="line"># 查看索引返回：health status index uuid pri rep docs.count docs.deleted store.size pri.store.size 表明我们还没有索引在集群中</span><br><span class="line">GET /_cat/indices?v</span><br><span class="line"># 集群中的节点列表</span><br><span class="line">GET /_cat/nodes?v</span><br><span class="line"># 创建一个索引叫做&quot;customer&quot;</span><br><span class="line">PUT /customer?pretty</span><br><span class="line"># 索引一个简单的customer文档到customer索引，external类型，ID是1</span><br><span class="line">PUT /customer/external/1?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 删除一个索引</span><br><span class="line">DELETE /customer?pretty</span><br><span class="line"># 删除全部索引</span><br><span class="line">DELETE /_all</span><br><span class="line"># 删除 多个索引</span><br><span class="line">DELETE /customer,customer1,customer2</span><br><span class="line"># 删除 模糊匹配</span><br><span class="line">DELETE /customer*</span><br><span class="line"># 删除一个文档</span><br><span class="line">DELETE /customer/external/2?pretty</span><br></pre></td></tr></table></figure><h3 id="2-2-search查询条件详解"><a href="#2-2-search查询条件详解" class="headerlink" title="2.2 search查询条件详解"></a>2.2 search查询条件详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 查询出所有问题文档匹配某个查询</span><br><span class="line">GET /centent/_search?q=title:123</span><br><span class="line"># 有多少文档匹配某个查询</span><br><span class="line">GET /centent/_search?q=title:123*&amp;size=0</span><br><span class="line"># 有没有文档匹配某个查询(terminated_early)</span><br><span class="line">GET /centent/_search?q=title:1234*&amp;size=0&amp;terminate_after=1</span><br><span class="line"># match和term的区别：match查询的时候,elasticsearch会根据你给定的字段提供合适的分析器,而term查询不会有分析器分析的过程，match查询相当于模糊匹配,只包含其中一部分关键词就行</span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_source&quot;: false,</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;title&quot; : &quot;123&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 查询全部</span><br><span class="line">GET /book/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 排序</span><br><span class="line">GET /book/_search </span><br><span class="line">&#123;&quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;name&quot; : &quot; java&quot;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">    &quot;sort&quot;: [</span><br><span class="line">        &#123; &quot;price&quot;: &quot;desc&quot; &#125;</span><br><span class="line">    ]&#125;</span><br><span class="line"># 分页</span><br><span class="line">GET  /book/_search </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">&#125;</span><br><span class="line"># 指定返回的字段</span><br><span class="line">GET /book/_search </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;, &quot;studymodel&quot;]</span><br><span class="line">&#125;</span><br><span class="line"># 匹配指定条件查询</span><br><span class="line">GET /test_index/_search </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;test_field&quot;: &quot;test&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-返回数据详解"><a href="#2-3-返回数据详解" class="headerlink" title="2.3 返回数据详解"></a>2.3 返回数据详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 97, #请求耗时多少毫秒</span><br><span class="line">  &quot;timed_out&quot; : false, #是否超时。默认情况下没有超时机制，也就是客户端等待Elasticsearch搜索结束（无论执行多久），提供超时机制的话，Elasticsearch则在指定时长内处理搜索，在指定时长结束的时候，将搜索的结果直接返回（无论是否搜索结束）。指定超时的方式是传递参数，参数单位是：毫秒-ms。秒-s。分钟-m。</span><br><span class="line">  &quot;_shards&quot; : &#123; # 分片</span><br><span class="line">    &quot;total&quot; : 1, #请求发送到多少个shard上</span><br><span class="line">    &quot;successful&quot; : 1, #成功返回搜索结果的shard</span><br><span class="line">    &quot;skipped&quot; : 0, #停止服务的shard</span><br><span class="line">    &quot;failed&quot; : 0 #失败的shard</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123; #匹配记录数</span><br><span class="line">    &quot;total&quot; : &#123; #返回了多少结果</span><br><span class="line">      &quot;value&quot; : 3,</span><br><span class="line">      &quot;relation&quot; : &quot;eq&quot; # 关系</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot; : 1.0, #搜索结果中，最大的相关度分数，相关度越大分数越高，_score越大，排位越靠前</span><br><span class="line">    &quot;hits&quot; : [ #搜索到的结果集合，默认查询前10条数据。</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;centent&quot;, #数据所在索引</span><br><span class="line">        &quot;_type&quot; : &quot;centent&quot;, #数据所在类型</span><br><span class="line">        &quot;_id&quot; : &quot;4&quot;, #数据的id</span><br><span class="line">        &quot;_score&quot; : 1.0, #数据的搜索相关度分数</span><br><span class="line">        &quot;_source&quot; : &#123; # 数据的具体内容。</span><br><span class="line">          &quot;id&quot; : 4,</span><br><span class="line">          &quot;title&quot; : &quot;***&quot;,</span><br><span class="line">          &quot;content&quot; : &quot;***&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在linux环境装了一个elasticsearch，遇到了好几个问题，还有一些笔记，记录一下，后面以后安装的时候方便快速解决。</summary>
    
    
    
    <category term="tool" scheme="https://gaoqisen.github.io/categories/tool/"/>
    
    
    <category term="elasticsearch" scheme="https://gaoqisen.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>汇编基础</title>
    <link href="https://gaoqisen.github.io/study/assembly.html"/>
    <id>https://gaoqisen.github.io/study/assembly.html</id>
    <published>2020-06-25T02:13:40.000Z</published>
    <updated>2020-07-11T02:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、进制"><a href="#一、进制" class="headerlink" title="一、进制"></a>一、进制</h2><blockquote><p>进制的意思可以理解为用多少个字符去表示数字(10进制就是用10个阿拉伯数字去计数，2进制可以用0和1进行计数)，自己也可以创造出特殊的字符进行计数</p></blockquote><h3 id="1-1-进制的计数"><a href="#1-1-进制的计数" class="headerlink" title="1.1 进制的计数"></a>1.1 进制的计数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一进制，逢1近1</span><br><span class="line">二进制，逢2近1</span><br><span class="line">...</span><br><span class="line">十进制，逢10近1       (0,1,2,3,4,5,6,7,8,9)</span><br><span class="line">...</span><br><span class="line">十六进制，逢16近1 （0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f）</span><br></pre></td></tr></table></figure><blockquote><p>用1-4的进制去表示10进制</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一进制表示（1）1，2，3，4</span></span><br><span class="line">1, 11, 111, 1111</span><br><span class="line"><span class="meta">#</span><span class="bash"> 二进制表示（0，1）0，1，2，3，4, 5, 6, 7</span></span><br><span class="line">0, 1, 10, 11, 100, 101, 110, 111</span><br><span class="line"><span class="meta">#</span><span class="bash"> 三进制表示(0，1，2) 0，1，2，3，4, 5, 6, 7, 8, 9</span></span><br><span class="line">0, 1, 2, 10, 11, 12, 20, 21, 22</span><br><span class="line"><span class="meta">#</span><span class="bash"> 四进制表示(0, 1, 2, 3)0，1，2，3，4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line">0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22</span><br><span class="line"><span class="meta">#</span><span class="bash"> 六进制表示(0, 1, 2, 3, 4, 5 ... 16)</span></span><br><span class="line">0, 1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24</span><br></pre></td></tr></table></figure><h3 id="1-2-进制的运算"><a href="#1-2-进制的运算" class="headerlink" title="1.2 进制的运算"></a>1.2 进制的运算</h3><h4 id="1-2-1-8进制的加法表"><a href="#1-2-1-8进制的加法表" class="headerlink" title="1.2.1 8进制的加法表"></a>1.2.1 8进制的加法表</h4><table><thead><tr><th>1+1=2</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1+2=3</td><td>2+2=4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1+3=4</td><td>2+3=5</td><td>3+3=6</td><td></td><td></td><td></td><td></td></tr><tr><td>1+4=5</td><td>2+4=6</td><td>3+4=7</td><td>4+4=10</td><td></td><td></td><td></td></tr><tr><td>1+5=10</td><td>2+5=7</td><td>3+5=10</td><td>4+5=11</td><td>5+5=12</td><td></td><td></td></tr><tr><td>1+6=7</td><td>2+6=10</td><td>3+6=11</td><td>4+6=12</td><td>5+6=13</td><td>6+6=14</td><td></td></tr><tr><td>1+7=10</td><td>2+7=11</td><td>3+7=12</td><td>4+7=13</td><td>5+7=14</td><td>6+7=15</td><td>7+7=16</td></tr></tbody></table><h4 id="1-2-2-8进制的乘法表"><a href="#1-2-2-8进制的乘法表" class="headerlink" title="1.2.2 8进制的乘法表"></a>1.2.2 8进制的乘法表</h4><table><thead><tr><th>1*1=1</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1*2=2</td><td>2*2=4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1*3=3</td><td>2*3=6</td><td>3*3=11</td><td></td><td></td><td></td><td></td></tr><tr><td>1*4=4</td><td>2*4=10</td><td>3*4=14</td><td>4*4=20</td><td></td><td></td><td></td></tr><tr><td>1*5=5</td><td>2*5=12</td><td>3*5=17</td><td>4*5=24</td><td>5*5=31</td><td></td><td></td></tr><tr><td>1*6=6</td><td>2*6=14</td><td>3*6=22</td><td>4*6=30</td><td>5*6=36</td><td>6*6=44</td><td></td></tr><tr><td>1*7=7</td><td>2*7=16</td><td>3*7=5</td><td>4*7=34</td><td>5*7=43</td><td>6*7=52</td><td>7*7=61</td></tr></tbody></table><h4 id="1-2-3-8进制的加法"><a href="#1-2-3-8进制的加法" class="headerlink" title="1.2.3 8进制的加法"></a>1.2.3 8进制的加法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 运算的本质就是计数</span><br><span class="line"> 236</span><br><span class="line">+215  # 5+6等于13近1余3，3+4等于4加上之前的1为5，</span><br><span class="line">-----</span><br><span class="line"> 453</span><br></pre></td></tr></table></figure><h4 id="1-2-4-8进制的减法"><a href="#1-2-4-8进制的减法" class="headerlink" title="1.2.4 8进制的减法"></a>1.2.4 8进制的减法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 325</span><br><span class="line">-216  # 个位数5-6不够向前借1位就是15-6为7，十位数2被借了一位就是1-1位0，百位3-2位1</span><br><span class="line">-----</span><br><span class="line"> 107</span><br></pre></td></tr></table></figure><h4 id="1-2-5-8进制的乘法"><a href="#1-2-5-8进制的乘法" class="headerlink" title="1.2.5 8进制的乘法"></a>1.2.5 8进制的乘法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   123</span><br><span class="line">  *456  # 3*6为22进2余2，2*6为14加上之前的2为进1余6,1*6为6加上之前的1为7</span><br><span class="line">------</span><br><span class="line">   762  # 3*5为17进1余7，2*5为12加上之前的1为进1余3，1*5为5加上之前的1为6</span><br><span class="line">  637   # 3*4为14近1余4，2*4为10加上之前的1为近1余1，1*4为4加上之前的1为5</span><br><span class="line"> 514    # 2+0为2，6+7为15进1余5，7+3+4+1为17近1余7，6+1+1为10近1余0，5+1为6</span><br><span class="line">------</span><br><span class="line"> 60752</span><br></pre></td></tr></table></figure><h4 id="1-2-6-8进制的除法"><a href="#1-2-6-8进制的除法" class="headerlink" title="1.2.6 8进制的除法"></a>1.2.6 8进制的除法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 56</span><br><span class="line">/12  # 除法就是要算乘法，最接近的数字。12*4为50不够，12*5为62多了。因此56/12为4还有余数</span><br><span class="line">－－－</span><br><span class="line"> 4</span><br></pre></td></tr></table></figure><h3 id="1-3-二进制"><a href="#1-3-二进制" class="headerlink" title="1.3 二进制"></a>1.3 二进制</h3><p>计算机使用的就是二进制进行计数的 , 晶体管有电表示1没电表示0。从硬件中看计算机的信号限制在0-2伏低电压(用0表示)和2-5伏高电压(用1表示)的范围。计算机的物理构成是数字电路, 数字电路的基本构成是逻辑门电路，逻辑门电路的理论基础是布尔逻辑运算，而布尔运算的结果只有两种，二进制每一位正好能表示两种布尔运算的结果。故计算机的计算都是二进制</p><p>1个16进制数得用 4个二进制数才能表示，因此32位的计算机的内存地址由8个16进制表示。</p><h3 id="1-4-Byte"><a href="#1-4-Byte" class="headerlink" title="1.4 Byte"></a>1.4 Byte</h3><p>二进制数系统中，每个0或1就是一个位(bit)。字节是常用的计算机存储空间的大小。1个字节(Byte)就等于8个位(bit)。于是在无符号的情况下(没有正负之分),1个字节最大的容量就是2^8-1＝255，00000000 就是0，也就是说一个字节能存0-255这256个数字。如果有符号的话8个位的第一个格子用来表示正号或是负号，那么11111111 就是-2^7=-128，01111111 就是127 。这样算下来也是存储了256位，这就是为什么java中一个字节的大小取值范围是-128~127了。以下计算了java中所有的基本数据类型大小的取值范围（其中浮点类型的e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方）:</p><table><thead><tr><th>类型</th><th>长度字节</th><th>范围</th><th>存储位数</th></tr></thead><tbody><tr><td>byte(字节)</td><td>1</td><td>-128~127</td><td>2^8</td></tr><tr><td>short(短整型)</td><td>2</td><td>-32768~32767</td><td>2^16</td></tr><tr><td>int(整数)</td><td>4</td><td>-2147483648~2147483647</td><td>2^32</td></tr><tr><td>long(长整)</td><td>8</td><td>-9223372036854775808 ~ 9223372036854775807</td><td>2^64</td></tr><tr><td>char(字符)</td><td>2</td><td>0~65535</td><td>2^16</td></tr><tr><td>float(浮点)</td><td>4</td><td>3.402823e+38 ~ 1.401298e-45</td><td>2^32</td></tr><tr><td>double(双精度)</td><td>8</td><td>1.797693e+308~ 4.9000000e-324</td><td>2^64</td></tr><tr><td>boolean(布尔)</td><td>1</td><td>true~false</td><td>2^8</td></tr></tbody></table><p>l</p><p>上面的字节可以看出在计算机中用一个数的最高位来存储符号，正数为0，负数为1。</p><h2 id="二-原码、反码、补码"><a href="#二-原码、反码、补码" class="headerlink" title="二 原码、反码、补码"></a>二 原码、反码、补码</h2><ul><li>原码：将一个整数转换为的二进制就是原码,如: 5的原码为：0000 0101；-5的原码为1000 0101</li><li>反码: 正数的反码就是原码，负数的符号位一定是1其余与原码取反。如：如单字节的5的反码为：0000 0101；-5的反码为1111 1010（为了解决原码做减法的问题, 出现了反码）。</li><li>补码：正数的补码就是原码，负数的符号位一定是1之后反码+1就是补码。如：字节的5的补码为：0000 0101；-5的原码为1111 1011（发现用反码计算减法, 结果的真值部分是正确的.，有问题的就出现在”0”这个特殊的数值上，为了解决这个问题就有了补码）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 例子:1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 原码 0 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 反码 0 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 补码 0 0 0 0  0 0 0 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子:-1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 原码: 1 0 0 0  0 0 0 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 反码: 1 1 1 1  1 1 1 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 补码: 1 1 1 1  1 1 1 1</span></span><br></pre></td></tr></table></figure><ul><li>真值：因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</li></ul><p>计算机中用加法代替了减法省去了减法器( 1-1 = 1+(-1) )，在<strong>计算机中负数的真值是用补码</strong>表示的。因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减， 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 当需要一个减法时就等于加上它的相反数，既然其补码就是其相反数，我们加上其补码不就可以了。, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了</p><h2 id="三、位运算"><a href="#三、位运算" class="headerlink" title="三、位运算"></a>三、位运算</h2><h3 id="3-1-与运算-and-amp"><a href="#3-1-与运算-and-amp" class="headerlink" title="3.1 与运算(and &amp;)"></a>3.1 与运算(and &amp;)</h3><p>两个都为1才为1</p><p><img src="https://raw.githubusercontent.com/gaoqisen/GraphBed/master/202006/20200625163031.png" alt="https://raw.githubusercontent.com/gaoqisen/GraphBed/master/202006/20200625163031.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011 0001</span><br><span class="line">0101 0010</span><br><span class="line">----------</span><br><span class="line">0001 0000</span><br></pre></td></tr></table></figure><h3 id="3-2-或运算-or"><a href="#3-2-或运算-or" class="headerlink" title="3.2 或运算(or |)"></a>3.2 或运算(or |)</h3><p>其中一个为1就为1</p><p><img src="https://raw.githubusercontent.com/gaoqisen/GraphBed/master/202006/20200625163827.png" alt="https://raw.githubusercontent.com/gaoqisen/GraphBed/master/202006/20200625163827.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0101 1101</span><br><span class="line">1001 0001</span><br><span class="line">----------</span><br><span class="line">1101 1101</span><br></pre></td></tr></table></figure><h3 id="3-3-异或-xor"><a href="#3-3-异或-xor" class="headerlink" title="3.3 异或(xor ^)"></a>3.3 异或(xor ^)</h3><p>不相同为1</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200625164434.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200625164434.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1101 0001</span><br><span class="line">1010 0011</span><br><span class="line">----------</span><br><span class="line">0111 0010</span><br></pre></td></tr></table></figure><h3 id="3-4-非-not"><a href="#3-4-非-not" class="headerlink" title="3.4 非(not ~)"></a>3.4 非(not ~)</h3><p>0就是，1就是0，单目运算。反码的过程就是非运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1110 0001</span><br><span class="line">----------</span><br><span class="line">0001 1110</span><br></pre></td></tr></table></figure><h3 id="3-5位运算（移动位）"><a href="#3-5位运算（移动位）" class="headerlink" title="3.5位运算（移动位）"></a>3.5位运算（移动位）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0001 # 10进制数字为1</span><br><span class="line">0000 0010 # 左移动一位，10进制数字为2 (shl &lt;&lt;)高位丢弃，地位补0</span><br><span class="line">0000 0100 # 左移动一位，10进制数字为4 (shl &lt;&lt;)</span><br><span class="line">0000 0010 # 右移动一位，10进制数字为2 (shr &gt;&gt;)地位丢弃，高位正数补0负数补1</span><br></pre></td></tr></table></figure><p>操作位的移动就可以让数字成倍增长。汇编语法: 左移 shl，右移 shr，与 and，或 or，非 not，异或 xor。汇编直接操作的是二进制数据。</p><blockquote><p>补充: 32位计算机和64位计算机的区别在于1. 处理数据的能力，理论上64位处理的数据要比32位高很多。2. 寻址能力。32位系统的最大寻址空间是2的32次方=4294967296（bit）= 4（GB）左右；而64位系统的最大寻址空间为2的64次方=4294967296（bit）的32次方，数值大于1亿GB。也就是意味着32位系统最多只能在4GB内存里找东西，64位系统就最大支持的内存高达亿位数，</p></blockquote><h2 id="四、位运行的加减乘除"><a href="#四、位运行的加减乘除" class="headerlink" title="四、位运行的加减乘除"></a>四、位运行的加减乘除</h2><p>4+5=?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">---------- # 手动算的话0+0为0，1+1进1余0，0+1位1</span><br><span class="line">0000 1001 </span><br><span class="line"></span><br><span class="line"># 计算机执行原理</span><br><span class="line"># 一、4和5异或，不相同为1其他为0，如果不考虑近位，异或就可以计算出结果</span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">---------</span><br><span class="line">0000 0001</span><br><span class="line"></span><br><span class="line"># 二、4和5与运算,两个都为1才为1(判断进位，如果运算结果为0则没有进位)</span><br><span class="line">0000 0100</span><br><span class="line">0000 0101</span><br><span class="line">---------</span><br><span class="line">0000 0100</span><br><span class="line"></span><br><span class="line"># 三、将第二步与运算的结果左移一位</span><br><span class="line">0000 1000</span><br><span class="line"></span><br><span class="line"># 四、将第一步异或出来的结果和第三步左移的结果进行异或，不相同为1其他为0</span><br><span class="line">0000 0001</span><br><span class="line">0000 1000</span><br><span class="line">---------</span><br><span class="line">0000 1001</span><br><span class="line"></span><br><span class="line"># 五，将第一步的结果和第三步的结果进行与运行，判断是否有进位(结果都为0则没有进位)</span><br><span class="line">0000 0001</span><br><span class="line">0000 1000</span><br><span class="line">---------</span><br><span class="line">0000 0000</span><br><span class="line"></span><br><span class="line"># 最终的结果就是最后一个与运算为0的上一个异或运算的结果0000 1001</span><br></pre></td></tr></table></figure><p>4-5 = 4 + (-5)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">---------- # 手动算的话1+0为1，0+1也为1</span><br><span class="line">1111 1111 </span><br><span class="line"></span><br><span class="line"># 计算机执行原理</span><br><span class="line"># 一、4 + (-5)异或，不相同为1其他为0，如果不考虑近位，异或就可以计算出结果</span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">---------</span><br><span class="line">1111 1111</span><br><span class="line"></span><br><span class="line"># 二、4 + (-5)与运算,两个都为1才为1(判断进位，如果运算结果为0则没有进位)</span><br><span class="line">0000 0100</span><br><span class="line">1111 1011</span><br><span class="line">---------</span><br><span class="line">0000 0000</span><br><span class="line"></span><br><span class="line"># 最终的结果就是最后一个与运算为0的上一个异或运算的结果1111 1111</span><br></pre></td></tr></table></figure><p>s</p><p>除法的本质就是减法，减法也是加法，故计算机只会加法。计算机语言的本质就是在进行位运算，都是通过电路实现的。</p><h2 id="五、汇编"><a href="#五、汇编" class="headerlink" title="五、汇编"></a>五、汇编</h2><p>通过指令来代替二进制的编码，用汇编指令就可以给计算机发送一些操作，之后计算机就进行操作。常用工具: Vc6（程序到汇编的理解）,OD，抓包工具，加解密工具</p><h3 id="5-1-寄存器"><a href="#5-1-寄存器" class="headerlink" title="5.1 寄存器"></a>5.1 寄存器</h3><p>CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p><p>早期的x86 CPU的8个寄存器: EAX,EBX,ECX,EDX,EDI,ESI,EBP,ESP</p><h3 id="5-2-内存"><a href="#5-2-内存" class="headerlink" title="5.2 内存"></a>5.2 内存</h3><ul><li><p>堆(heap)</p><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p></li><li><p>栈(stack)</p><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。栈里面通常存储函数里面的局部数据，每个函数被执行到都会新产生一个栈帧并压入到栈里面(入栈),程序执行完成之后就会释放栈帧。如果函数里面还有函数就会产生新的栈帧，指定里面的栈帧执行完成被释放之后，顶层的栈帧才会被释放，由此产生了先进后出的概念。</p></li></ul><h3 id="5-3-汇编指令"><a href="#5-3-汇编指令" class="headerlink" title="5.3 汇编指令"></a>5.3 汇编指令</h3><p>汇编指令是汇编语言中使用的一些操作符和<a href="https://baike.baidu.com/item/助记符/489287" target="_blank" rel="noopener">助记符</a>，还包括一些<a href="https://baike.baidu.com/item/伪指令/4309381" target="_blank" rel="noopener">伪指令</a>（如assume，end），汇编指令同机器指令一一对应。每一种CPU都有自己的汇编指令集。 计算机是通过执行指令来处理数据的，为了指出数据的来源、操作结果的去向及所执行的操作，一条指令一般包含操作码和操作数两部分。 </p><p>加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int add_a_and_b(int a, int b) &#123;</span><br><span class="line">   return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   return add_a_and_b(2, 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc -S example.c 之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_add_a_and_b:</span><br><span class="line">   push   %ebx  # 将 EBX 寄存器里面的值，写入_add_a_and_b这个帧</span><br><span class="line">   mov    %eax, [%esp+8]  # 将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器</span><br><span class="line">   mov    %ebx, [%esp+12] # 将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。</span><br><span class="line">   add    %eax, %ebx   # 将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</span><br><span class="line">   pop    %ebx  # 取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）</span><br><span class="line">   ret  # 用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</span><br><span class="line"></span><br><span class="line">_main:  # 从_main标签开始执行，会在 Stack 上为main建立一个帧</span><br><span class="line">   push   3  # 将运算子放入 Stack，这里就是将3写入main这个帧</span><br><span class="line">   push   2  # 将2写入main这个帧</span><br><span class="line">   call   _add_a_and_b  # 表示调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。</span><br><span class="line">   add    %esp, 8  # 将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</span><br><span class="line">   ret  # main函数运行结束，ret指令退出程序执行</span><br></pre></td></tr></table></figure><h3 id="5-4-内存复制"><a href="#5-4-内存复制" class="headerlink" title="5.4 内存复制"></a>5.4 内存复制</h3><p>在汇编中，当我们需要把内存中的数据从一个地方复制到另一个地方的时候就会用到<br>EDI和ESI</p><p>MOVS指令：移动数据 内存-内存</p><h3 id="5-5-堆栈的指令"><a href="#5-5-堆栈的指令" class="headerlink" title="5.5 堆栈的指令"></a>5.5 堆栈的指令</h3><p>汇编里把一段内存空间定义为一个栈，栈总是先进后出，栈的最大空间为 64K。由于 “栈” 是由高到低使用的，所以新压入的数据的位置更低，ESP 中的指针将一直指向这个新位置，所以 ESP 中的地址数据是动态的。</p><h3 id="5-6-汇编函数"><a href="#5-6-汇编函数" class="headerlink" title="5.6 汇编函数"></a>5.6 汇编函数</h3><p> 当应用程序需要相同代码时，不必多次重新编写代码，有时候最好创建包含代码的单一函数（function），然后可以在程序中的任何位置调用这个函数。函数包含完成特定例程所需的所有代码，而且不需要主程序中任何代码的帮助。数据从主程序传递给函数，然后结果返回给主程序。</p><h3 id="5-7-堆栈传参"><a href="#5-7-堆栈传参" class="headerlink" title="5.7 堆栈传参"></a>5.7 堆栈传参</h3><p>主程序在调用子程序之前，将需要传递的参数依次压入堆栈，子程序从堆栈中取入口参数；子程序调用结束之前，将需要返回的参数依次压入堆栈，主程序在堆栈中取出参数</p><h3 id="5-8-堆栈平衡"><a href="#5-8-堆栈平衡" class="headerlink" title="5.8 堆栈平衡"></a>5.8 堆栈平衡</h3><ul><li><p>如果要返回父程序，则当我们在堆栈中进行堆栈操作的时候，一定要保证在RET这条指令之前，ESP指向的是压入的我们压入的地址</p></li><li><p>如果通过堆栈传递参数了。那么在程序执行完毕后，要平衡因参数导致的堆栈变化</p></li></ul><h2 id="六、-参考"><a href="#六、-参考" class="headerlink" title="六、 参考"></a>六、 参考</h2><ul><li>汇编语言基础: <a href="http://c.biancheng.net/view/3534.html" target="_blank" rel="noopener">http://c.biancheng.net/view/3534.html</a></li><li>原码、反码、补码: <a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a></li><li>汇编: <a href="https://www.bilibili.com/video/BV1ni4y1G7B9?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ni4y1G7B9?p=8</a></li><li>入门: <a href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html</a></li><li>32位计算机和64位计算机的区别: <a href="https://www.jianshu.com/p/d0e95bed5b60" target="_blank" rel="noopener">https://www.jianshu.com/p/d0e95bed5b60</a></li><li>内存复制指令: <a href="https://www.jianshu.com/p/bd0db6f54d81" target="_blank" rel="noopener">https://www.jianshu.com/p/bd0db6f54d81</a></li><li>参数传递：<a href="https://blog.csdn.net/u011640816/article/details/35981783" target="_blank" rel="noopener">https://blog.csdn.net/u011640816/article/details/35981783</a></li><li>堆栈平衡：<a href="https://blog.csdn.net/qq_43573676/article/details/104376354" target="_blank" rel="noopener">https://blog.csdn.net/qq_43573676/article/details/104376354</a></li><li>汇编函数：<a href="https://my.oschina.net/u/2537915/blog/698182" target="_blank" rel="noopener">https://my.oschina.net/u/2537915/blog/698182</a></li></ul>]]></content>
    
    
    <summary type="html">汇编语言的基础入门，学习一些底层知识。</summary>
    
    
    
    <category term="study" scheme="https://gaoqisen.github.io/categories/study/"/>
    
    
    <category term="assembly" scheme="https://gaoqisen.github.io/tags/assembly/"/>
    
  </entry>
  
  <entry>
    <title>logstash安装学习</title>
    <link href="https://gaoqisen.github.io/tool/logstash.html"/>
    <id>https://gaoqisen.github.io/tool/logstash.html</id>
    <published>2020-06-22T10:11:32.000Z</published>
    <updated>2020-07-11T02:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1-描述"><a href="#1-1-描述" class="headerlink" title="1.1 描述"></a>1.1 描述</h3><p>Logstash是用Ruby开发的软件，在配置文件中用{}定义作用域，处理数据的时候主要分3个方面去处理输入、过滤、输出。通过各种渠道去获取数据，在进行加工之后将数据输出的存储的容器。可以作为数据库之间的同步工具，最主要的作用是去获取日志文件结合elasticsearch去进行日志分析。内部主要的处理流程如下：</p><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200623130056.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200623130056.png"></p><h3 id="1-2-官网介绍"><a href="#1-2-官网介绍" class="headerlink" title="1.2 官网介绍"></a>1.2 官网介绍</h3><p>Logstash 是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。</p><h3 id="1-3-实际应用"><a href="#1-3-实际应用" class="headerlink" title="1.3 实际应用"></a>1.3 实际应用</h3><ol><li>数据采集工具(主要用于日志采集)：最常用的就是ELK进行日志的收集，将各个服务中的日志采集后放入elasticsearch里面。之后用kibanna进行日志分析。</li><li>同步数据库(mysql/oracle)中的数据到elasticsearch里面进行快速的文档查找。一般mysql建议用阿里巴巴的canal进行数据同步，这种同步是通过binlog日志进行同步的，不会影响到数据库。如果同步周期比较大，也可以使用logstash进行同步，logstash是通过执行sql语句后将返回数据进行同步的。</li></ol><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><ul><li>下载安装包,地址: <a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/logstash</a></li><li><p>重要的就是配置文件，如下完成mysql到elasticserch的数据同步：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 输入</span><br><span class="line">input &#123;</span><br><span class="line">  jdbc &#123;</span><br><span class="line">    jdbc_driver_library =&gt; &quot;/home/mysql-connector-java-5.1.10.jar&quot;</span><br><span class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&quot;</span><br><span class="line">    jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">    jdbc_password =&gt; &quot;123456&quot;</span><br><span class="line">    # 设置监听间隔 各字段含义（从左至右）分、时、天、月、年，全为*默认含义为每分钟都更新</span><br><span class="line">    schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">    # 查询sql，可以通过更新字段来区分那些是需要更新的</span><br><span class="line">    statement_filepath =&gt; &quot;/home/logstash-7.8.0/config/complete.sql&quot;</span><br><span class="line">    # 记录最后的运行时间，注意目录需要创建好</span><br><span class="line">    last_run_metadata_path =&gt; &quot;/home/logstash-7.8.0/config/logstash_jdbc_last_run_oracle&quot;</span><br><span class="line">    use_column_value =&gt; false</span><br><span class="line">    tracking_column =&gt; &quot;update_time&quot;</span><br><span class="line">    # 分页处理数据</span><br><span class="line">    jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">    jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">    # 类型，对象后面输出的类型</span><br><span class="line">    type =&gt; &quot;complete_corporate&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 过滤</span><br><span class="line">filter &#123;</span><br><span class="line">  # 用ruby解决相差8小时的时区问题, update_time必须要通过statement_filepath配置的sql可以查询出来</span><br><span class="line">  ruby &#123; </span><br><span class="line">      code =&gt; &quot;event.set(&apos;update_time&apos;, event.get(&apos;update_time&apos;).time.localtime + 8*60*60)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">output &#123;</span><br><span class="line">  if[type] == &quot;complete_corporate&quot;&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">      user =&gt; elastic                                                                                                                                                                                         </span><br><span class="line">      password =&gt; elastic</span><br><span class="line">      # 索引名</span><br><span class="line">      index =&gt; &quot;complete_corporate_index&quot;</span><br><span class="line">      # 文档名</span><br><span class="line">      document_type =&gt; &quot;complete_corporate&quot;</span><br><span class="line">      # 文档ID(主键)</span><br><span class="line">      document_id =&gt; &quot;%&#123;body_card_no&#125;&quot; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  # 将数据输出到控制台</span><br><span class="line">  stdout &#123;</span><br><span class="line">      codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 解压缩</span><br><span class="line">tar -zxf xxx.tar.gz</span><br><span class="line">// 指定配置文件启动命令</span><br><span class="line">./logstash -f jdbc_sync.conf</span><br><span class="line">// 后台运行启动命令</span><br><span class="line">nohup ./logstash -f jdbc_sync.conf &amp;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><h3 id="3-1-input，数据的来源"><a href="#3-1-input，数据的来源" class="headerlink" title="3.1 input，数据的来源"></a>3.1 input，数据的来源</h3><ul><li><p>file: 输入为文件类型，通常可以去读取日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">  file&#123;</span><br><span class="line">    #path属性接受的参数是一个数组，其含义是标明需要读取的文件位置</span><br><span class="line">    path =&gt; [‘pathA’，‘pathB’]</span><br><span class="line">    #表示多就去path路径下查看是够有新的文件产生。默认是15秒检查一次。</span><br><span class="line">    discover_interval =&gt; 15</span><br><span class="line">    #排除那些文件，也就是不去读取那些文件</span><br><span class="line">    exclude =&gt; [‘fileName1’,‘fileNmae2’]</span><br><span class="line">    #被监听的文件多久没更新后断开连接不在监听，默认是一个小时。</span><br><span class="line">    close_older =&gt; 3600</span><br><span class="line">    #在每次检查文件列 表的时候， 如果一个文件的最后 修改时间 超过这个值， 就忽略这个文件。 默认一天。</span><br><span class="line">    ignore_older =&gt; 86400</span><br><span class="line">    #logstash 每隔多 久检查一次被监听文件状态（ 是否有更新） ， 默认是 1 秒。</span><br><span class="line">    stat_interval =&gt; 1</span><br><span class="line">    #sincedb记录数据上一次的读取位置的一个index</span><br><span class="line">    sincedb_path =&gt; ’$HOME/. sincedb‘</span><br><span class="line">    #logstash 从什么 位置开始读取文件数据， 默认是结束位置 也可以设置为：beginning 从头开始</span><br><span class="line">    start_position =&gt; ‘beginning’</span><br><span class="line">    #注意：这里需要提醒大家的是，如果你需要每次都从同开始读取文件的话，关设置start_position =&gt; beginning是没有用的，你可以选择sincedb_path 定义为 /dev/null</span><br><span class="line">  &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>jdbc: 输入为数据库，同步数据是可以使用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">  jdbc&#123;</span><br><span class="line">    #jdbc sql server 驱动,各个数据库都有对应的驱动，需自己下载</span><br><span class="line">    jdbc_driver_library =&gt; &quot;/etc/logstash/driver.d/sqljdbc_2.0/enu/sqljdbc4.jar&quot;</span><br><span class="line">    #jdbc class 不同数据库有不同的 class 配置</span><br><span class="line">    jdbc_driver_class =&gt; &quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span><br><span class="line">    #配置数据库连接 ip 和端口，以及数据库    </span><br><span class="line">    jdbc_connection_string =&gt; &quot;jdbc:sqlserver://200.200.0.18:1433;databaseName=test_db&quot;</span><br><span class="line">    #配置数据库用户名</span><br><span class="line">    jdbc_user =&gt;   </span><br><span class="line">    #配置数据库密码</span><br><span class="line">    jdbc_password =&gt;</span><br><span class="line">    #上面这些都不重要，要是这些都看不懂的话，你的老板估计要考虑换人了。重要的是接下来的内容。</span><br><span class="line">    # 定时器 多久执行一次SQL，默认是一分钟</span><br><span class="line">    # schedule =&gt; 分 时 天 月 年  </span><br><span class="line">    # schedule =&gt; * 22  *  *  * 表示每天22点执行一次</span><br><span class="line">    schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">    #是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录</span><br><span class="line">    clean_run =&gt; false</span><br><span class="line">    #是否需要记录某个column 的值,如果 record_last_run 为真,可以自定义我们需要表的字段名称，</span><br><span class="line">    #此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.</span><br><span class="line">    use_column_value =&gt; true</span><br><span class="line">    #如果 use_column_value 为真,需配置此参数. 这个参数就是数据库给出的一个字段名称。当然该字段必须是递增的，可以是 数据库的数据时间这类的</span><br><span class="line">    tracking_column =&gt; create_time</span><br><span class="line">    #是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中</span><br><span class="line">    record_last_run =&gt; true</span><br><span class="line">    #们只需要在 SQL 语句中 WHERE MY_ID &gt; :last_sql_value 即可. 其中 :last_sql_value 取得就是该文件中的值</span><br><span class="line">    last_run_metadata_path =&gt; &quot;/etc/logstash/run_metadata.d/my_info&quot;</span><br><span class="line">    #是否将字段名称转小写。</span><br><span class="line">    #这里有个小的提示，如果你这前就处理过一次数据，并且在Kibana中有对应的搜索需求的话，还是改为true，</span><br><span class="line">    #因为默认是true，并且Kibana是大小写区分的。准确的说应该是ES大小写区分</span><br><span class="line">    lowercase_column_names =&gt; false</span><br><span class="line">    #你的SQL的位置，当然，你的SQL也可以直接写在这里。</span><br><span class="line">    #statement =&gt; SELECT * FROM tabeName t WHERE  t.creat_time &gt; :last_sql_value</span><br><span class="line">    statement_filepath =&gt; &quot;/etc/logstash/statement_file.d/my_info.sql&quot;</span><br><span class="line">    #数据类型，标明你属于那一方势力。单了ES哪里好给你安排不同的山头。</span><br><span class="line">    type =&gt; &quot;my_info&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  #注意：外载的SQL文件就是一个文本文件就可以了，还有需要注意的是，一个jdbc&#123;&#125;插件就只能处理一个SQL语句，</span><br><span class="line">  #如果你有多个SQL需要处理的话，只能在重新建立一个jdbc&#123;&#125;插件。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>beats: 输入为接收端口</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    #接受数据端口</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">    #数据类型</span><br><span class="line">    type =&gt; &quot;logs&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>redis: 输入为redis</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">        host =&gt;&quot;192.168.200.21&quot;</span><br><span class="line">        port =&gt;&quot; 6379&quot;</span><br><span class="line">        db =&gt;&quot;6&quot;</span><br><span class="line">        data_type =&gt;&quot;list&quot;</span><br><span class="line">        key=&quot;demo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-filter，数据的处理"><a href="#3-2-filter，数据的处理" class="headerlink" title="3.2 filter，数据的处理"></a>3.2 filter，数据的处理</h3><ul><li><p>date: 处理时间格式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  date &#123;</span><br><span class="line">   # 解析名为logdate的字段以设置Logstash时间戳</span><br><span class="line">    match =&gt; [ &quot;logdate&quot;, &quot;MMM dd yyyy HH:mm:ss&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>grok: 将非结构化事件数据分析到字段中。 这个工具非常适用于系统日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>dissect: 使用分隔符将非结构化事件数据提取到字段中。 解剖过滤器不使用正则表达式，速度非常快。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  dissect &#123;</span><br><span class="line">    mapping =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;ts&#125; %&#123;+ts&#125; %&#123;+ts&#125; %&#123;src&#125; %&#123;prog&#125;[%&#123;pid&#125;]: %&#123;msg&#125;&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mutate: 使用最频繁的操作，可以对字段进行各种操作，比如重命名、删除、替换、更新等</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter&#123;</span><br><span class="line">    mutate&#123;</span><br><span class="line">        convert =&gt; &#123;&quot;age&quot; =&gt; &quot;integer&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-output，数据的输出"><a href="#3-3-output，数据的输出" class="headerlink" title="3.3 output，数据的输出"></a>3.3 output，数据的输出</h3><ul><li><p>elasticsearch：将数据导入到elasticsearch</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 输出</span><br><span class="line">output &#123;</span><br><span class="line">  if[type] == &quot;complete_corporate&quot;&#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">      user =&gt; elastic                                                                                                                                                                                         </span><br><span class="line">      password =&gt; elastic</span><br><span class="line">      # 索引名 </span><br><span class="line">      index =&gt; &quot;complete_corporate_index&quot;</span><br><span class="line">      # 文档名</span><br><span class="line">      document_type =&gt; &quot;complete_corporate&quot;</span><br><span class="line">      # 文档ID(主键)</span><br><span class="line">      document_id =&gt; &quot;%&#123;body_card_no&#125;&quot; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123;</span><br><span class="line">      codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>jdbc：将数据导入的数据库</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">        driver_jar_path =&gt; &quot;/path/mysql-connector-java-5.1.40.jar&quot;</span><br><span class="line">        driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        connection_string =&gt; &quot;jdbc:mysql://sss:8840/testcase&quot;</span><br><span class="line">        username =&gt; &quot;root&quot;</span><br><span class="line">        password =&gt; &quot;123456&quot;</span><br><span class="line">        statement =&gt; [&quot;INSERT INTO test ( val, name_val, level_val, source_name, version ) VALUES (?,?,?,?,?)&quot;,&quot;code&quot;,&quot;name&quot;,&quot;level&quot;,&quot;source_name&quot;,&quot;current_version&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    stdout &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>redis：将数据导入到redis</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">        host =&gt;&quot;192.168.200.21&quot;</span><br><span class="line">        port =&gt;&quot; 6379&quot;</span><br><span class="line">        db =&gt;&quot;6&quot;</span><br><span class="line">        data_type =&gt;&quot;list&quot;</span><br><span class="line">        key=&quot;demo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>file：将数据生成文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">output&#123;</span><br><span class="line">    if  [type] != &quot;file&quot; &#123; </span><br><span class="line">       file&#123;</span><br><span class="line">              path =&gt; &quot;/home/app/logbak/%&#123;+YYYY.MM.dd&#125;-file.txt&quot;</span><br><span class="line">              # 设置根据原始数据格式保存，不会带Json格式</span><br><span class="line">              codec =&gt; line &#123;format =&gt; &quot;%&#123;[collectValue]&#125;&quot;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>json: 将字段内容为json格式的数据进行解析</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    source =&gt; &quot;message&quot;     #要解析的字段名</span><br><span class="line">    target =&gt; &quot;msg_json&quot;    #解析后的存储字段，默认和message同级别</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>geoip: 根据ip地址提供对应的地域信息，比如经纬度、城市名等</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  geoip &#123;</span><br><span class="line">    source =&gt; &quot;clientip&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ruby: 最灵活的插件，可以以ruby语言来随心所欲的修改Logstash Event对象</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filter&#123;</span><br><span class="line">    ruby&#123;</span><br><span class="line">        code =&gt; &apos;size = event.get(&quot;message&quot;).size;</span><br><span class="line">                event.set(&quot;message_size&quot;,size)&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ruby &#123;</span><br><span class="line">        code =&gt; &quot;event.set(&apos;@read_timestamp&apos;,event.get(&apos;@timestamp&apos;))&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、遇到的问题"><a href="#四、遇到的问题" class="headerlink" title="四、遇到的问题"></a>四、遇到的问题</h2><h3 id="4-1-时区问题"><a href="#4-1-时区问题" class="headerlink" title="4.1 时区问题"></a>4.1 时区问题</h3><p>Elasticsearch 内部，对时间类型字段，是统一采用 UTC 时间，存成 long 长整形数据的！对日志统一采用 UTC 时间存储，是国际安全/运维界的一个通识——欧美公司的服务器普遍广泛分布在多个时区里。使用ruby过滤就可以了。</p><h3 id="4-2-和filebeat的对比选择"><a href="#4-2-和filebeat的对比选择" class="headerlink" title="4.2 和filebeat的对比选择"></a>4.2 和filebeat的对比选择</h3><p>filebeat是一个轻量级的日志收集器，如果每台服务器上面都安装一个logstash的话会造成性能的浪费。常用的做法就是通过filebeat将日志收集起来发送给logstash，之后logstash将数据同步给elasticsearch或者数据库。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><ul><li>输入(input): <a href="https://yq.aliyun.com/articles/152043?utm_content=m_27192" target="_blank" rel="noopener">https://yq.aliyun.com/articles/152043?utm_content=m_27192</a></li><li>过滤(filter): <a href="https://blog.csdn.net/wfs1994/article/details/80862952" target="_blank" rel="noopener">https://blog.csdn.net/wfs1994/article/details/80862952</a></li><li>输出(output): <a href="https://www.cnblogs.com/niutao/p/10909461.html" target="_blank" rel="noopener">https://www.cnblogs.com/niutao/p/10909461.html</a></li></ul>]]></content>
    
    
    <summary type="html">在linux环境装了一个logstash，遇到了好几个问题，记录一下笔记，以后安装的时候方便快速解决。</summary>
    
    
    
    <category term="tool" scheme="https://gaoqisen.github.io/categories/tool/"/>
    
    
    <category term="logstash" scheme="https://gaoqisen.github.io/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习</title>
    <link href="https://gaoqisen.github.io/java/jvm.html"/>
    <id>https://gaoqisen.github.io/java/jvm.html</id>
    <published>2020-06-11T11:30:19.000Z</published>
    <updated>2020-06-30T17:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JVM运行时数据区"><a href="#一、JVM运行时数据区" class="headerlink" title="一、JVM运行时数据区"></a>一、JVM运行时数据区</h2><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200612094240.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200612094240.png"></p><h3 id="1-1-线程私有"><a href="#1-1-线程私有" class="headerlink" title="1.1 线程私有"></a>1.1 线程私有</h3><ul><li>程序计数器(Program Counter Register)</li><li>本地方法栈(Native Method Stack)</li><li>虚拟机栈(VM Stack)</li></ul><h3 id="1-2-线程共享"><a href="#1-2-线程共享" class="headerlink" title="1.2 线程共享"></a>1.2 线程共享</h3><ul><li>堆(Heap)</li><li>方法区(Method Area)</li></ul><h2 id="二、名词解释"><a href="#二、名词解释" class="headerlink" title="二、名词解释"></a>二、名词解释</h2><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>指向当前线程所执行的字节码指令的行号(地址)，是一块较小的内存空间。是线程在让出时间片的时候记录的行号，下次线程获取到时间片之后就可以从程序计数器记录的行号处执行程序。各个线程之间的程序计数器独立存储互不影响，是唯一一个不会出现内存溢出的区域，字节码解释器通过改变程序计数器来依次读取指令,从而实现代码的流程控制。</p><h3 id="2-2-本地方法栈"><a href="#2-2-本地方法栈" class="headerlink" title="2.2 本地方法栈"></a>2.2 本地方法栈</h3><p>和虚拟机栈类似，区别就是虚拟机栈执行的是java方法服务，本地方法栈执行的Native方法服务。</p><h3 id="2-3-虚拟机栈"><a href="#2-3-虚拟机栈" class="headerlink" title="2.3 虚拟机栈"></a>2.3 虚拟机栈</h3><p>也叫java栈，由多个栈帧组成。栈帧是虚拟机进行方法调用和执行的数据结构。一个方法从调用开始到执行完成，就是一个栈帧在虚拟机中的入栈到出栈的过程。每个栈帧都包含局部变量表、方法出口、操作数栈、动态链接。</p><ul><li>局部变量表: 存放方法参数和方法内部定义的局部变量</li><li>操作数栈：操作栈，后入先出栈。调用其他方法时通过操作数栈进行传递参数</li><li>动态链接：堆中的对象是指向方法区中的一个类元信息的，类元信息是指向具体的类的，通过动态链接，就可以让对象直接指向类</li><li>方法出口：方法结束的时候要进行当前栈帧出栈，方法正常返回或者出现异常返回数据是用来帮助恢复上层方法的执行状态。</li></ul><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><p>Java虚拟机中内存最大的一块，是垃圾回收最重要的区域也叫gc堆。用来存放对象实例，几乎所有的对象实例和数组都在这里分配内存。按照垃圾回收的分代垃圾回收算法可以分为新生代、老年代</p><ul><li>新生代：新生代又分为伊甸园和幸存区<ul><li>伊甸园(eden)：新生的对象都存放到此区域，在进行一次垃圾回收(minor GC)之后就会将对象的年龄加1，并把对象移动到幸存区</li><li>幸存区有两个为了在进行一次垃圾清理之后把幸存的对象存放在另一块区域From Survivor、To Suvrivor。每次清理都会将对象的年龄加1，默认对象的年龄达到15岁(通过参数 - XX:MaxTenuringThreshold设置)之后就会把对象移动到老年代</li></ul></li><li>老年代：老年代中的对象生命周期长、存活率高、回收的速度就比较慢(major GC)。但是当老年代的内存满了之后就会出发一次完整的垃圾回收(full gc 新生代老年代的完整回收会造成STW)</li></ul><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><h4 id="2-5-1-永久代"><a href="#2-5-1-永久代" class="headerlink" title="2.5.1 永久代"></a>2.5.1 永久代</h4><p>保存被加载过的每一个类的信息，这些信息由类加载器在加载类的时候，从类的源文件中抽取出来，static变量信息也保存在方法区中(类的元数据)。方法区是线程共享的如果多个线程使用一个类的时候如果这个类没有被加载，则只有一个线程去加载类信息，其他线程等待(永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式java8之前)</p><h4 id="2-5-2-元空间"><a href="#2-5-2-元空间" class="headerlink" title="2.5.2 元空间"></a>2.5.2 元空间</h4><p>HotSpot虚拟机在java8之后已经取消了永久代，改为元空间，类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。这项改造也是有必要的，永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。永久代中的元数据的位置也会随着一次full GC发生移动，比较消耗虚拟机性能。同时，HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化。</p><h4 id="2-5-3-扩展"><a href="#2-5-3-扩展" class="headerlink" title="2.5.3 扩展"></a>2.5.3 扩展</h4><table><thead><tr><th>JDK版本</th><th>方法区的实现</th><th>运行时常量池所在的位置</th></tr></thead><tbody><tr><td>JDK6</td><td>PermGen space（永久代）</td><td>PermGen space（永久代）</td></tr><tr><td>JDK7</td><td>PermGen space（永久代）</td><td>Heap（堆）</td></tr><tr><td>JDK8</td><td>Metaspace（元空间）</td><td>Heap（堆）</td></tr></tbody></table><ul><li><p>为什么java8要移除永久代</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低</li></ol></li></ul><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><ul><li>元空间： <a href="https://www.jianshu.com/p/66e4e64ff278" target="_blank" rel="noopener">https://www.jianshu.com/p/66e4e64ff278</a></li><li>虚拟机栈：<a href="https://www.jianshu.com/p/ecfcc9fb1de7" target="_blank" rel="noopener">https://www.jianshu.com/p/ecfcc9fb1de7</a></li><li>永久代和元空间的区别：<a href="https://blog.csdn.net/xiaojin21cen/article/details/104267301" target="_blank" rel="noopener">https://blog.csdn.net/xiaojin21cen/article/details/104267301</a></li><li>执行引擎：<a href="https://juejin.im/entry/589546638d6d8100583615ee" target="_blank" rel="noopener">https://juejin.im/entry/589546638d6d8100583615ee</a></li></ul>]]></content>
    
    
    <summary type="html">JVM在运行java程序的时候，会把内存分为很多个区域，之前一直没有了解过JVM，这次好好学习一下。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java jvm" scheme="https://gaoqisen.github.io/tags/java-jvm/"/>
    
  </entry>
  
  <entry>
    <title>关于WebCenter的一些想法</title>
    <link href="https://gaoqisen.github.io/java/webCenterIdea.html"/>
    <id>https://gaoqisen.github.io/java/webCenterIdea.html</id>
    <published>2020-06-07T12:23:12.000Z</published>
    <updated>2020-06-08T05:56:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前一家公司上班的时候写了两个官网和一个教育类型的网站这种网站都需要一个后台的管理系统用来管理后台用户、权限、角色，这些功能都差不多是一样的，后台的UI框架结构也是一样的。开始的时候是用jQuery+html写了头部、菜单栏、底部这些公用的html，之后又用Vue写了头部、菜单栏、底部。基本上每个后台管理项目都需要写这些公用的模块，前前后后都写了好多次这种代码。在空闲的时候想了一下，如果后面还有这种类似的网站的话，也是避免不了会写这种重复的代码，感觉会有如下几种弊端:</p><ol><li>为了简化开发直接复制之前的代码，在复制代码之后需要花大量的时间去调试程序排查是否有复制遗漏的地方。</li><li>每次都重写这种代码的话，工作量势必会增加，而且还是重复性的工作。</li></ol><p>想利用了面向对象三大特征之一的封装特征，把这些公用的功能都封装在一起。以后就不用在写这种重复的代码了。这段时间公司也在使用XXL-JOB分布式调度工具，XXL-JOB就是一个服务端和多个客服端的模式，服务端负责调度其他的客户端。于是就想有一个服务端专门负责管理用户、权限、角色、菜单这些功能。然后客服端去调用服务端提供的接口就可以实现这些重复的功能了。<br>于是在空闲的时候就开发了一个乞丐版的Webcenter如下:</p><ol><li>服务端：提供SSO单点登录功能、用户管理、角色管理、系统管理、菜单管理、权限管理等功能。</li><li>客户端脚手架: 用来初始化SpringBoot项目和Vue后台项目，目的就是为了不写重复的代码。</li></ol><p>有了这个服务端之后，以后开发后台管理系统只需要启动服务端，然后利用客服端脚手架即可快速创建后台管理系统。在已经安装了redis和mysql的情况下基本上只需要10分钟就可以进行自己业务逻辑的开发了。<br>也不知道功能怎么样，希望大家提供宝贵的意见。<br>项目地址：<a href="https://github.com/gaoqisen/gqs-webcenter" target="_blank" rel="noopener">https://github.com/gaoqisen/gqs-webcenter</a></p>]]></content>
    
    
    <summary type="html">开发这么久了，一直在学习各种各样的技术，也一直在遗忘自己所学到的技术。为了能遗忘的稍微慢些，于是想写一个Web项目提升自己的技能，也方便自己以后可以有复制代码的仓库。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://gaoqisen.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>简单的权限管理小工具</title>
    <link href="https://gaoqisen.github.io/java/webcenter.html"/>
    <id>https://gaoqisen.github.io/java/webcenter.html</id>
    <published>2020-05-13T12:50:11.000Z</published>
    <updated>2020-06-11T18:44:10.000Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>    </p><h3 align="center">GQS-WEBCENTER, 一个轻量级的WEB中心，简单的权限管理(乞丐版)<br><p></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>之前开发了好几个后台的管理系统，每次都需要写一遍登录逻辑、菜单路由、用户管理、角色管理、权限管理这些功能。为了以后再开发这种系统的时候不用再写这些重复的程序，就把这些通用的功能抽象成为了一个简单的权限管理服务(WebCenter)，WebCenter专门负责单点登录、权限管理、菜单配置、用户管理、角色管理、系统管理等。为了在创建系统的时候更简单，于是开发了一个gqs-webcenter-client.jar并上传到了中央仓库，之后创建系统的时候只需要引入这个jar包就可以集成WebCenter。每次创建项目的时候后端都需要添加配置引入jar包，前端都需要配置动态路由，为了简化到都不用复制重复的代码，于是开发了一个web-cli的npm<a href="#jsjjs">脚手架</a>。在安装脚手架之后就可以直接初始化项目并进行业务逻辑的开发。</p><h3 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h3><ol><li>简单：安装好WebCenter服务端后，后端项目引入gqs_webcenter_client.jar。前端利用webc脚手架初始化项目，即可进行业务逻辑的开发。</li><li>动态：服务端可以动态配置各个系统的菜单、菜单图标、角色、权限、以及REST接口的权限。</li></ol><h3 id="1-3-功能"><a href="#1-3-功能" class="headerlink" title="1.3 功能"></a>1.3 功能</h3><ol><li>用户管理：增加多个用户，管理用户的账号密码等</li><li>角色管理：动态分配角色的权限，前端页面进行权限控制之后，可以实现不同的角色登录展示不同的菜单。</li><li>REST接口管理：各个系统注册到服务端后可以配置接口的调用权限（所有人可以访问、登录后可以访问、必须有权限才可以访问）</li><li>系统管理：给各个系统分配clientId和密匙，用于系统的单点登录</li><li>菜单管理：管理各个系统的菜单、路由、图标等。</li></ol><h3 id="1-4-下载"><a href="#1-4-下载" class="headerlink" title="1.4 下载"></a>1.4 下载</h3><table><thead><tr><th>介绍</th><th>地址</th></tr></thead><tbody><tr><td>后端</td><td><a href="https://github.com/gaoqisen/gqs-webcenter" target="_blank" rel="noopener">https://github.com/gaoqisen/gqs-webcenter</a></td></tr><tr><td>前端</td><td><a href="https://github.com/gaoqisen/webcenter-vue-cli" target="_blank" rel="noopener">https://github.com/gaoqisen/webcenter-vue-cli</a></td></tr></tbody></table><h3 id="1-5-环境"><a href="#1-5-环境" class="headerlink" title="1.5 环境"></a>1.5 环境</h3><p>Maven3+<br>Jdk1.8+<br>Mysql5.7+<br>Vue3.10.0+<br>Webpack4.0.0+ </p><h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><h3 id="2-1-运行Webcenter服务端"><a href="#2-1-运行Webcenter服务端" class="headerlink" title="2.1 运行Webcenter服务端"></a>2.1 运行Webcenter服务端</h3><h4 id="2-1-1-方式一-docker-推荐"><a href="#2-1-1-方式一-docker-推荐" class="headerlink" title="2.1.1 方式一(docker 推荐)"></a>2.1.1 方式一(docker 推荐)</h4><blockquote><p>先执行 docker network create net_webcenter 创建网络。该docker-compose安装了redis、mysql和webcenter3个服务，是否暴露端口可以自行修改。如果本地已经安装了mysql和redis可以只安装my_webcenter容器，安装的时候需要将容器之前的容器名改为db_mysql和db_redis并创建net_webcenter网络将db_mysql和db_redis加入到该网络中。启动成功之后将sql导入到数据库中访问 <a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 即可。docker容器通信可以参考: <a href="https://www.cnblogs.com/kevingrace/p/6590319.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/6590319.html</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2.0&apos;</span><br><span class="line">services:</span><br><span class="line">  db_mysql:</span><br><span class="line">    restart: always</span><br><span class="line">    image: mysql:5.7.22</span><br><span class="line">    container_name: db_mysql</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    command:</span><br><span class="line">      --character-set-server=utf8mb4</span><br><span class="line">      --collation-server=utf8mb4_general_ci</span><br><span class="line">      --explicit_defaults_for_timestamp=true</span><br><span class="line">      --lower_case_table_names=1</span><br><span class="line">      --max_allowed_packet=128M</span><br><span class="line">      --sql-mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysqldata:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      - net</span><br><span class="line">  db_redis:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: db_redis</span><br><span class="line">    command: redis-server --requirepass 123456</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redisdata:/data</span><br><span class="line">    networks:</span><br><span class="line">      - net</span><br><span class="line">  my_webcenter:</span><br><span class="line">    image: registry.cn-hangzhou.aliyuncs.com/gqs/webcenter:1.0.1</span><br><span class="line">    container_name: my_webcenter</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - net</span><br><span class="line">networks:</span><br><span class="line">  net:</span><br><span class="line">    external: </span><br><span class="line">      # 请先创建net_webcenter网络</span><br><span class="line">      name: net_webcenter</span><br></pre></td></tr></table></figure><h4 id="2-1-2-方式二-jar包"><a href="#2-1-2-方式二-jar包" class="headerlink" title="2.1.2 方式二(jar包)"></a>2.1.2 方式二(jar包)</h4><ol><li><p>环境准备</p><ul><li>请先安装Redis、Mysql、JDK1.8。</li><li>获取 “WebCenter数据库初始化SQL脚本(/db/<a href="https://github.com/gaoqisen/gqs-webcenter/blob/master/db/webcenter.sql" target="_blank" rel="noopener">webcenter.sql</a>)” 并执行。</li></ul></li><li><p>获取jar包</p><ul><li>github: <a href="https://github.com/gaoqisen/gqs-webcenter/releases" target="_blank" rel="noopener">https://github.com/gaoqisen/gqs-webcenter/releases</a></li><li>gitee: <a href="https://gitee.com/gaoqisen/gqs-webcenter/releases" target="_blank" rel="noopener">https://gitee.com/gaoqisen/gqs-webcenter/releases</a></li><li>网盘: <a href="https://c-t.work/s/8db595c7ac4f44" target="_blank" rel="noopener">https://c-t.work/s/8db595c7ac4f44</a>   密码: 7x8yr4</li></ul></li><li><p>启动jar包</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 默认mysql密码123456，redis密码123456启动</span><br><span class="line">nohub jara -Xms1024m -Xmx1024m -jar webcenter-console-1.0.0.jar</span><br><span class="line">// 修改mysql密码，redis密码</span><br><span class="line">nohup java -Xms1024m -Xmx1024m -jar webcenter-console-1.0.0.jar --spring.database.username=root --spring.database.password=23456 --spring.redis.password=23456</span><br></pre></td></tr></table></figure></li></ol><p>即可访问<a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 。</p><h3 id="2-2-客户端搭建"><a href="#2-2-客户端搭建" class="headerlink" title="2.2 客户端搭建"></a>2.2 客户端搭建</h3><h4 id="2-1-方式一-前后端不分离"><a href="#2-1-方式一-前后端不分离" class="headerlink" title="2.1 方式一(前后端不分离)"></a>2.1 方式一(前后端不分离)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 全局安装webcenter客服端脚手架</span><br><span class="line">npm install webc-cli -g</span><br><span class="line">// 之前有安装的需要更新到1.0.3版本</span><br><span class="line">npm update webc-cli -g</span><br><span class="line">// 安装成功之后执行webc命令, 查看是否安装成功</span><br><span class="line">webc </span><br><span class="line">// 快速搭建项目(搭建的直接就是SpringBoot项目,通过IntelliJ IDEA可以直接运行，前端Vue代码放在src/main/resources/webpage目录下)</span><br><span class="line">webc boot</span><br><span class="line">// 进入到前端目录</span><br><span class="line">cd demo/src/main/resources/webpage</span><br><span class="line">// 安装依赖，如果没有安装cnpm需要先安装：npm install cnpm</span><br><span class="line">cnpm install</span><br><span class="line">// 启动前端服务</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src="https://gaoqisen.github.io/GraphBed/202006/20200602095927.png" alt="https://gaoqisen.github.io/GraphBed/202006/20200602095927.png"></p><ul><li>快速搭建的项目main方法启动之后接口通过<a href="http://localhost:8001/ArtifactID" target="_blank" rel="noopener">http://localhost:8001/ArtifactID</a> 访问</li><li>前端项目启动后，开发环境通过<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 访问即可</li><li>本地开发时将webcenter.client.forestage配置设置为true，方便本地vue开发。打包上线时改为false。</li><li>打包上线运行时，需要先在/src/main/resources/webpage目录下npm run build(将vue静态文件打包到resources/public里面)之后在maven clean install。</li><li>打包上线后ArtifactID就是上下文路径，通过<a href="http://localhost:8001/ArtifactID" target="_blank" rel="noopener">http://localhost:8001/ArtifactID</a> 进行访问，如：<a href="http://localhost:8001/demo" target="_blank" rel="noopener">http://localhost:8001/demo</a></li><li>前后端不分离搭建后，打包为一个jar包，静态文件通过SpringBoot内置的tomcat访问。前后端分离的项目前端静态文件可以用nginx进行代理。(前后端不分离的搭建成功之后就可以开发业务逻辑了)<ul><li>开发环境搭建完成之后，需要启动3个服务。（Webcenter服务端:8000, Vue前端8080，Maven后端8001）</li></ul></li></ul><blockquote><p>IntelliJ IDEA打开vue的node_modules会出现假死现象，<a href="https://www.dvy.com.cn/2017/11/22/4535.html" target="_blank" rel="noopener">解决办法</a>： Editor&gt;&gt;File Types&gt;&gt;在Ignore files and folders中添加;node_modules</p></blockquote><h4 id="2-2-方式二-前后端分离"><a href="#2-2-方式二-前后端分离" class="headerlink" title="2.2 方式二(前后端分离)"></a>2.2 方式二(前后端分离)</h4><p><img src="https://gaoqisen.github.io/GraphBed/202005/20200527215308.png" alt="https://gaoqisen.github.io/GraphBed/202005/20200527215308.png"></p><h5 id="2-2-1-创建Maven后端"><a href="#2-2-1-创建Maven后端" class="headerlink" title="2.2.1 创建Maven后端"></a>2.2.1 创建Maven后端</h5><blockquote><p>创建出springBoot项目之后可以把配置文件改为yml格式，因为后面的配置都是基于yml的。如果需要用properties格式的话可以在<a href="https://www.toyaml.com/index.html" target="_blank" rel="noopener">https://www.toyaml.com/index.html</a> 里面进行转换。创建成功之后引入maven依赖、添加配置、创建WebCenterConfig.java即可。</p></blockquote><ol><li><p>Maven引入依赖</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.gaoqisen&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gqs-webcenter-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">### pom.xml测试用例</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;demo&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;name&gt;demo&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.github.gaoqisen&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;gqs-webcenter-client&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加application.yml的配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /sample</span><br><span class="line">spring:</span><br><span class="line">  jackson:</span><br><span class="line">    default-property-inclusion: non_null</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss</span><br><span class="line">    time-zone: GMT+8</span><br><span class="line">  application:</span><br><span class="line">    name: webcenter-sample</span><br><span class="line">  ### 需要和服务端的redis是同一个</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    password: 123456</span><br><span class="line">    port: 6379</span><br><span class="line">    timeout: 60000</span><br><span class="line">webcenter:</span><br><span class="line">  # 服务端</span><br><span class="line">  server:</span><br><span class="line">    host: localhost</span><br><span class="line">    # 如果服务端端口改了的话，此处的端口应保持一致</span><br><span class="line">    port: 8000</span><br><span class="line">    # 通过服务端的系统管理里面获取</span><br><span class="line">    clientid: WZUIIXWZUIIX</span><br><span class="line">    secretkey: qOIWRbzeFvOnXUYTspfSt2ibfJPe1vtG</span><br><span class="line">  ### 客服端配置，是否前后端分离，用于单点登录的地址跳转。forestage为false时，host和port可以不写</span><br><span class="line">  client:</span><br><span class="line">    forestage: true</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 8080</span><br></pre></td></tr></table></figure></li><li><p>创建WebCenterConfig.java文件，用于将客户端交给spring管理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebCenterConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityInterceptor securityInterceptor() &#123;</span><br><span class="line">        return new SecurityInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(securityInterceptor()).excludePathPatterns(&quot;/static/*&quot;)</span><br><span class="line">                .excludePathPatterns(&quot;/error&quot;).addPathPatterns(&quot;/**&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    @DependsOn(&quot;webCenterConsole&quot;)</span><br><span class="line">    public WebCenterClientBeanFactory springClientBeanFactory() &#123;</span><br><span class="line">        return new WebCenterClientBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebCenterInitializing webCenterInitializing() &#123;</span><br><span class="line">        return new WebCenterInitializing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebCenterConsole webCenterConsole()&#123;</span><br><span class="line">        WebCenterConsole webCenterConsole = new WebCenterConsole();</span><br><span class="line">        return webCenterConsole;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @DependsOn(&quot;redisConnectionFactory&quot;)</span><br><span class="line">    public ApiController apiController() &#123;</span><br><span class="line">        return new ApiController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        StringRedisTemplate template = new StringRedisTemplate(redisConnectionFactory);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="2-2-2-创建Vue前端"><a href="#2-2-2-创建Vue前端" class="headerlink" title="2.2.2 创建Vue前端"></a>2.2.2 创建Vue前端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 全局安装webcenter客服端脚手架</span><br><span class="line">npm install webc-cli -g</span><br><span class="line">// 安装成功之后执行webc命令, 查看是否安装成功</span><br><span class="line">webc </span><br><span class="line">// 查看所有的脚手架</span><br><span class="line">webc list</span><br><span class="line">// 初始化一个名为sample的前端项目（集成了动态菜单和单点登录）</span><br><span class="line">webc init webcenter sample</span><br></pre></td></tr></table></figure><blockquote><p>完成上面的搭建之后，启动Maven后端和Vue前端就可以直接开发自己的业务逻辑了。</p></blockquote><h2 id="三、功能介绍"><a href="#三、功能介绍" class="headerlink" title="三、功能介绍"></a>三、功能介绍</h2><h3 id="3-1-系统配置"><a href="#3-1-系统配置" class="headerlink" title="3.1 系统配置"></a>3.1 系统配置</h3><p>给各个系统分配clientId和密匙，应用名称必须和客户端的spring.application.name一致。每新建一个系统都需要生成不同的clientId和密钥，并更改系统的配置。</p><h3 id="3-2-权限配置"><a href="#3-2-权限配置" class="headerlink" title="3.2 权限配置"></a>3.2 权限配置</h3><p>权限配置在新建角色的时候进行配置，如果需要修改权限要在修改角色里面进行修改（修改操作是将之前角色和权限的关联信息全部删除之后，新增选择的权限）。修改角色的权限之后，需要用户退出后重新登陆生效。前端的页面权限用如下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 权限将斜杠改为冒号即可。@PathVariable类型的接口去掉/&#123;*&#125;如:</span><br><span class="line">// sys/menu/save, sys:menu:save</span><br><span class="line">// sys/menu/info/&#123;id&#125;, sys:menu:info</span><br><span class="line">&lt;el-button v-if=&quot;isAuth(&apos;sys:menu:save&apos;)&quot; &gt;新增&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-菜单配置"><a href="#3-3-菜单配置" class="headerlink" title="3.3 菜单配置"></a>3.3 菜单配置</h3><p>菜单分为目录和菜单两种，需要单独给每个系统添加菜单和目录，目录可以多层级。路由就是创建的.vue文件的路径。如:/sys/log, 就在views/sys里面创建log.vue。动态路由就会自动路由到log.vue里面。菜单创建好之后需要给对应的角色赋予菜单权限，子系统退出后重新登录生效。</p><h3 id="3-4-REST接口配置"><a href="#3-4-REST接口配置" class="headerlink" title="3.4 REST接口配置"></a>3.4 REST接口配置</h3><ul><li>后端接口通过@ApiOperation注解标识接口名称，如：@ApiOperation(“接口备注”)</li><li>rest接口有3种权限：公开、登录、权限。客户端启动之后自动注册接口到服务端默认为公开所有人都可以访问的权限。改为登录接口之后，访问的权限就必须登录之后才可以访问。需要权限的接口级别最高必须在权限里面给角色配置了权限才可以访问。</li></ul><h2 id="四、脚手架介绍"><a href="#四、脚手架介绍" class="headerlink" title="四、脚手架介绍"></a>四、<span id="jsjjs">脚手架介绍</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 命令</span><br><span class="line">webc -h // 查看命令帮助</span><br><span class="line">webc -V // 查看版本号</span><br><span class="line">webc add // 增加模版</span><br><span class="line">webc list // 查看所有的模版</span><br><span class="line">webc init webcenter sample  // 通过webcenter模版创建一个名为sample的项目</span><br><span class="line">webc boot // 快速创建一个springBoot项目</span><br></pre></td></tr></table></figure><ul><li>webc add: 可以自己写前端的脚手架。会替换package.json里面用户信息描述等。</li><li>webc boot: 创建的是一个固定的格式，包含springBoot和Vue前端的代码。vue代码在resources/webpage里面。在本地开发的时候可以启动两个端口如：8001后端代码，8080前端代码。后面打包的时候在webpage目录下运行npm run build就会把前端的静态代码打包到resources/public里面，在项目根目录下运行maven clean install就可以把前端代码和后端代码打成一个包，开发的时候可以是前后端分离的开发模式，打包之后就是一个jar包，简化了前后端分离的nginx配置。如果需要前后端分离部署的话，只需要把resources/public里面的静态文件拷贝到其他目录下面，nginx指定路径就可以了。</li></ul><h2 id="五、结构"><a href="#五、结构" class="headerlink" title="五、结构"></a>五、结构</h2><h3 id="4-1-Webcenter项目结构"><a href="#4-1-Webcenter项目结构" class="headerlink" title="4.1 Webcenter项目结构"></a>4.1 Webcenter项目结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">──gqs-webcenter</span><br><span class="line">  ├── db  // 数据库</span><br><span class="line">  │   └── webcenter.sql // 数据库初始化脚本</span><br><span class="line">  ├── gqs-webcenter-client  // 客服端</span><br><span class="line">  ├── gqs-webcenter-common  // 通用工具</span><br><span class="line">  ├── gqs-webcenter-component  // 通用组件</span><br><span class="line">  │   ├── gqs-webcenter-redis  // redis组件</span><br><span class="line">  │   ├── gqs-webcenter-webapi  // swagger组件</span><br><span class="line">  ├── gqs-webcenter-console  // 控制台，需要编译打包的模块</span><br><span class="line">  ├── gqs-webcenter-sample  // 简单的客服端例子</span><br><span class="line">  ├── gqs-webcenter-service  // 服务层，数据访问层</span><br><span class="line">  ├── gqs-webcenter-webpage  // 前端项目,build之后将静态文件打包到了 gqs-webcenter-console的resource/public里面</span><br><span class="line">  └── readme.md  // 项目介绍</span><br></pre></td></tr></table></figure><h3 id="4-2-数据库结构"><a href="#4-2-数据库结构" class="headerlink" title="4.2 数据库结构"></a>4.2 数据库结构</h3><table><thead><tr><th>名称</th><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>sys_code</td><td>系统编码表</td><td>用来保存系统信息、clientId、密匙等</td></tr><tr><td>sys_code_menu</td><td>系统菜单关联表</td><td>系统和菜单的对应关系</td></tr><tr><td>sys_menu</td><td>菜单表</td><td>保存菜单和目录信息</td></tr><tr><td>sys_rest</td><td>rest接口表</td><td>保存各个系统的REST接口和权限</td></tr><tr><td>sys_role</td><td>角色表</td><td>角色的相关信息</td></tr><tr><td>sys_role_menu</td><td>角色菜单关联表</td><td>角色可以查看的菜单</td></tr><tr><td>sys_role_rest</td><td>角色接口关联表</td><td>角色可以访问的接口</td></tr><tr><td>sys_user</td><td>用户表</td><td>用户的相关信息</td></tr><tr><td>sys_user_role</td><td>角色表</td><td>用户关联的角色，一个用户对应多个角色</td></tr></tbody></table><h3 id="4-3-Vue项目引入的主要插件。"><a href="#4-3-Vue项目引入的主要插件。" class="headerlink" title="4.3 Vue项目引入的主要插件。"></a>4.3 Vue项目引入的主要插件。</h3><table><thead><tr><th>名称</th><th>介绍</th><th>版本</th><th>地址</th></tr></thead><tbody><tr><td>element-ui</td><td>饿了么后端UI框架</td><td>2.8.2</td><td><a href="https://element.eleme.cn/2.8/#/zh-CN/component/installation" target="_blank" rel="noopener">https://element.eleme.cn/2.8/#/zh-CN/component/installation</a></td></tr><tr><td>fortawesome</td><td>图标库</td><td>5.13</td><td><a href="http://www.fontawesome.com.cn/faicons/" target="_blank" rel="noopener">http://www.fontawesome.com.cn/faicons/</a></td></tr><tr><td>vue-router</td><td>路由</td><td>3.0.7</td><td><a href="https://cn.vuejs.org/v2/guide/routing.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/routing.html</a></td></tr><tr><td>vuex</td><td>状态管理</td><td>3.3.0</td><td><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh/</a></td></tr><tr><td>axios</td><td>HTTP库</td><td>0.19.2</td><td><a href="http://www.axios-js.com/zh-cn/docs/" target="_blank" rel="noopener">http://www.axios-js.com/zh-cn/docs/</a></td></tr></tbody></table><h3 id="4-4-Vue结构"><a href="#4-4-Vue结构" class="headerlink" title="4.4 Vue结构"></a>4.4 Vue结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── build  // 构建</span><br><span class="line">├── config  // 配置文件</span><br><span class="line">├── index.html  // 入口文件</span><br><span class="line">├── node_modules  // 依赖下载的包</span><br><span class="line">├── package.json // 依赖</span><br><span class="line">├── src </span><br><span class="line"> |  ├── App.vue  // 入口</span><br><span class="line"> |  ├── assets  // 静态文件</span><br><span class="line"> |  ├── components  // 组件</span><br><span class="line"> |  ├── main.js  // 入口js文件</span><br><span class="line"> |  ├── router  // 路由</span><br><span class="line"> |  ├── store  // 状态状态管理</span><br><span class="line"> |  ├── utils  // 工具</span><br><span class="line"> |   └── views  // 视图，需要开发的代码位置</span><br><span class="line">└── static  // 静态文件</span><br></pre></td></tr></table></figure><h2 id="六、问答"><a href="#六、问答" class="headerlink" title="六、问答"></a>六、问答</h2><ol><li>SpringBoot项目依赖了webcenter-client.jar后集成了那些功能？<br> 答:  提供了单点登录、动态菜单、动态权限功能。</li><li>前端Vue通过脚手架初始化之后有那些功能？<br> 答：实现了动态路由，菜单直接在服务端的菜单管理里面进行配置。</li><li>客服端与服务端之间如何通信？<br> 答: 之间的通信通过Redis的异步消息队列实现。</li></ol><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><ul><li>动态路由：<a href="https://github.com/renrenio/renren-fast-vue" target="_blank" rel="noopener">https://github.com/renrenio/renren-fast-vue</a></li><li>脚手架开发：<a href="https://juejin.im/post/5c94fef7f265da60fd0c15e8" target="_blank" rel="noopener">https://juejin.im/post/5c94fef7f265da60fd0c15e8</a></li><li>Maven上传jar包: <a href="https://www.sojson.com/blog/250.html" target="_blank" rel="noopener">https://www.sojson.com/blog/250.html</a></li></ul></h3>]]></content>
    
    
    <summary type="html">GQS-WEBCENTER, 一个轻量级的WEB中心，简单的权限管理和登录。</summary>
    
    
    
    <category term="java" scheme="https://gaoqisen.github.io/categories/java/"/>
    
    
    <category term="java springBoot" scheme="https://gaoqisen.github.io/tags/java-springBoot/"/>
    
  </entry>
  
</feed>
